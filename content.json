{"meta":{"title":"小涵的米奇妙妙屋","subtitle":"","description":"","author":"Szh","url":"https://www.hanhan0223.cn","root":"/"},"pages":[{"title":"分类","date":"2022-01-08T09:17:16.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"categories/index.html","permalink":"https://www.hanhan0223.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-08T09:15:58.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"tags/index.html","permalink":"https://www.hanhan0223.cn/tags/index.html","excerpt":"","text":""},{"title":"我焯!原!","date":"2022-08-23T15:54:17.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"scripts/genshin/index.html","permalink":"https://www.hanhan0223.cn/scripts/genshin/index.html","excerpt":"","text":"查询原神面板"},{"title":"关于我","date":"2022-01-07T11:49:11.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"about/index.html","permalink":"https://www.hanhan0223.cn/about/index.html","excerpt":"","text":"​ 杭电计算机研一在读。 ​ 摸鱼时间搭个静态网站，学习一下前端相关的东西（主要是云服务器要到期了，没折扣续不起了==）。 ​ To be continued …"}],"posts":[{"title":"LeetCode--2023.4","slug":"LeetCode--2023.4","date":"2023-04-01T02:32:55.000Z","updated":"2023-04-06T12:56:13.890Z","comments":true,"path":"原理/LeetCode--2023.4/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode--2023.4/","excerpt":"打卡4月LeetCode2023.4.1831.隐藏个人信息题干太长。 示例 示例 1： 输入：s &#x3D; &quot;AB@qq.com&quot; 输出：&quot;a*****b@qq.com&quot; 示例 2： 输入：s &#x3D; &quot;1(234)567-890&quot; 输出：&quot;***-***-7890&quot;","text":"打卡4月LeetCode2023.4.1831.隐藏个人信息题干太长。 示例 示例 1： 输入：s &#x3D; &quot;AB@qq.com&quot; 输出：&quot;a*****b@qq.com&quot; 示例 2： 输入：s &#x3D; &quot;1(234)567-890&quot; 输出：&quot;***-***-7890&quot; 解法基本思路：模拟？ 这也算算法题。。吗？ 代码class Solution &#123; public: string maskPII(string s) &#123; if(s[0] &gt;&#x3D; &#39;A&#39;)&#123; int split &#x3D; s.find(&#39;@&#39;); for(int i &#x3D; split + 1; i &lt; s.length(); ++i)&#123; if(s[i] &lt;&#x3D; &#39;Z&#39; &amp;&amp; s[i] &gt;&#x3D; &#39;A&#39;) s[i] +&#x3D; 32; &#125; if(s[0] &lt;&#x3D; &#39;Z&#39;) s[0] +&#x3D; 32; if(s[split - 1] &lt;&#x3D; &#39;Z&#39;) s[split - 1] +&#x3D; 32; s.replace(1, split - 2, &quot;*****&quot;); &#125; else&#123; for(string::iterator i &#x3D; s.begin(); i &lt; s.end(); ++i)&#123; if(*i &lt; &#39;0&#39;) s.erase(i--); &#125; int len &#x3D; s.length(); if(len &#x3D;&#x3D; 10) return &quot;***-***-&quot; + s.substr(6, 4); else if(len &#x3D;&#x3D; 11) return &quot;+*-***-***-&quot; + s.substr(7, 4); else if(len &#x3D;&#x3D; 12) return &quot;+**-***-***-&quot; + s.substr(8, 4); else if(len &#x3D;&#x3D; 13) return &quot;+***-***-***-&quot; + s.substr(9, 4); &#125; return s; &#125; &#125;; 54.螺旋矩阵、剑指 Offer 29. 顺时针打印矩阵题干给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 示例 1： 输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 解法基本思路：模拟过程 相比于 59.螺旋矩阵Ⅱ ，这题的长宽不一定相同，因此不再适用按圈缩减的方法。 维护上、下、左、右四个边界的下标。 第一次移动，从左到右移动一整行，移动后直接将1~4从上图中抹掉，变成了一个 4 x 2 的矩阵。如何抹掉？维护的上边界加一即可。因为循环都是统一从一个边界到另一个边界的。 第二次移动，从上到下，移动后抹去8、12，相当于右边界减一。这样下一次移动中从右到左时从右边界开始就是从11开始的，顺序不会错乱。 第三从右往左，第四次从下往上，四次组成一次大循环。 每当有两个对应边界错位（左 &gt; 右，上 &gt; 下）时，就直接结束了。例如当仅剩一行时，上下边界重合，抹去这行时，无论up++还是down–，都会出现错位，以此为结束的判断依据。 思路清晰，逻辑明了。 代码class Solution &#123; public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; int up &#x3D; 0, left &#x3D; 0; int down &#x3D; matrix.size() - 1, right &#x3D; matrix[0].size() - 1; while(1)&#123; for(int i &#x3D; left; i &lt;&#x3D; right; ++i) res.push_back(matrix[up][i]); if(++up &gt; down) break; for(int i &#x3D; up; i &lt;&#x3D; down; ++i) res.push_back(matrix[i][right]); if(--right &lt; left) break; for(int i &#x3D; right; i &gt;&#x3D; left; --i) res.push_back(matrix[down][i]); if(--down &lt; up) break; for(int i &#x3D; down; i &gt;&#x3D; up; --i) res.push_back(matrix[i][left]); if(++left &gt; right) break; &#125; return res; &#125; &#125;; 11.盛最多水的容器题干给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。 示例 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 示例 2： 输入：height &#x3D; [1,1] 输出：1 解法基本思路：双指针 代码很简单，这题主要在于思路上：为什么双指针按代码所示方法往中间移动时不会漏掉某种情况呢？ 容量和两个因素有关：双指针的距离、双指针中短的那个的高度。 开始双指针在两端，距离是最大的，此时移动指针若想要让容量更大，就必须提高双指针中短的那个的高度，也就是把短的指针往中间移动找找有没有更高的位置。这样移动下来就不存在漏掉某种最大的情况了。 代码class Solution &#123; public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int n &#x3D; height.size()， res &#x3D; 0; int l &#x3D; 0, r &#x3D; n - 1; while(l &lt; r)&#123; int area &#x3D; min(height[l], height[r]) * (r - l); res &#x3D; max(res, area); if(height[l] &lt; height[r]) l++; else r--; &#125; return res; &#125; &#125;; 2023.4.31053.交换一次的先前排列题干给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。 如果无法这么操作，就请返回原数组。 示例 示例 1： 输入：arr &#x3D; [3,2,1] 输出：[3,1,2] 示例 2： 输入：arr &#x3D; [1,9,4,6,7] 输出：[1,7,4,6,9] 解法基本思路：贪心 对于数组中的两元素下标 i 、j 且 i &lt; j**，若交换 arr[i] 和 arr[j] 得到的新数组按字典序排列比原数组小，显然有**arr[i] &gt; arr[j] 。因此符合题意要求的交换会使得数组 arr[i] 在下标 i 处的元素变小。那么为了得到按字典序排列小于原数组的最大新数组，尽可能地保持前面的元素不变是这一步的最优解，即让 i 最大化。 也就是说，从右往左遍历，找到的第一个arr[i] &gt; arr[i + 1] 处，就是需要被交换的 i 。 显然，找到 i 后，j 需要在 i 右半边去找。在满足 arr[i] &gt; arr[j] 的情况下，取最大的 arr[j] 是这一步的最优解，但需要注意元素可能存在重复的情况需要排除，此时把大的值换到相同数字的最左边，在小于原序列的状态下得到的序列是更大的，因此取最大的、j 尽量小的 arr[j] 为最优解。 代码class Solution &#123; public: vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; arr) &#123; for(int i &#x3D; arr.size() - 2; i &gt;&#x3D; 0; --i)&#123; if(arr[i] &gt; arr[i + 1])&#123; for(int j &#x3D; arr.size() - 1; j &gt; i; --j)&#123; if(arr[j] &lt; arr[i] &amp;&amp; arr[j] !&#x3D; arr[j - 1])&#123; swap(arr[j], arr[i]); return arr; &#125; &#125; &#125; &#125; return arr; &#125; &#125;; 31.下一个排列题干整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。必须 原地 修改，只允许使用额外常数空间。 示例 示例 1： 输入：nums &#x3D; [1,2,3] 输出：[1,3,2] 示例 2： 输入：nums &#x3D; [3,2,1] 输出：[1,2,3] 解法基本思路：贪心？、双指针？ 这题和今天的每日一题是相同原理，是找大于原序列的最小字典序。 对于数组中的一部分，若完全的降序排列（不存在 arr[i] &lt; arr[i+1]** 的情况），则这段子序列是最大的。那么最优解就是从右往左找到第一个 **arr[i] &gt; arr[i+1] 处，就是从尾部开始的最大子序列长度再加一，i 即是要交换的位置。 显然，找到 i 后，j 需要在 i 右半边去找。在满足 arr[i] &lt; arr[j] 的情况下，取最小的 arr[j] 是这一步的最优解，此题不需要考虑元素重复的情况，因为换哪个都一样。 交换完成后，由于 i 增大了，要找大于原序列的最小字典序，右侧的子序列自然是要最小的，因此升序排列即可。 若找不到这样的 i ，说明原序列就是最大字典序，直接把整个数组升序排列即可。 代码class Solution &#123; public: void nextPermutation(vector&lt;int&gt;&amp; nums)&#123; for(int i &#x3D; nums.size() - 2; i &gt;&#x3D; 0; --i)&#123; if(nums[i] &lt; nums[i+1])&#123; for(int j &#x3D; nums.size() - 1; j &gt; i; --j)&#123; if(nums[j] &gt; nums[i])&#123; swap(nums[j], nums[i]); sort(nums.begin()+i+1,nums.end()); return; &#125; &#125; &#125; &#125; sort(nums.begin(),nums.end()); &#125; &#125;; 2023.4.446.全排列题干给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 示例 1： 输入：nums &#x3D; [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 输入：nums &#x3D; [1] 输出：[[1]] 解法基本思路：回溯、DFS 实际就是一个排列组合问题，每一个数字都要放到最前面，而对剩下的数字里同样是每个数字都要被放在最前（第二个）。。以此类推。这就是分布解决问题的过程。 回溯法采用的是试错思想：当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。这通常是使用递归来实现的。 而本题中不需要判断分步答案是否正确，只需记录所有分布答案即可。 回溯与动态规划的异同： 1.共同点 用于求解多阶段决策问题。即：求解一个问题分为很多步骤（阶段）；每一个步骤（阶段）可以有多种选择。 2.不同点 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果； 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。 对于该题，示例1： 深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」 代码class Solution &#123; public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start &#x3D;&#x3D; end)&#123; res.push_back(nums); return; &#125; for(int i &#x3D; start; i &lt; end; ++i)&#123; swap(nums[start], nums[i]); dfs(res, nums, start + 1, end); swap(nums[start], nums[i]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; dfs(res, nums, 0, nums.size()); return res; &#125; &#125;; 2023.4.52427.公因子的数目解法基本思路：暴力 公因子的最大值就是最大公约数，因此先求最大公约数（库函数 __gcd ），再从1开始循环判断。 代码class Solution &#123; public: int commonFactors(int a, int b) &#123; int divisor &#x3D; __gcd(a, b); int res &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; divisor; ++i) if(a % i &#x3D;&#x3D; 0 &amp;&amp; b % i &#x3D;&#x3D; 0) res++; return res; &#125; &#125;; 2023.4.61017.负二进制转换题干给你一个整数 n ，以二进制字符串的形式返回该整数的 负二进制（base -2）表示。 注意，除非字符串就是 &quot;0&quot;，否则返回的字符串中不能含有前导零。 示例 示例 1： 输入：n &#x3D; 2 输出：&quot;110&quot; 解释：(-2)2 + (-2)1 &#x3D; 2 示例 2： 输入：n &#x3D; 3 输出：&quot;111&quot; 解释：(-2)2 + (-2)1 + (-2)0 &#x3D; 3 解法基本思路：模拟、数学 本题主要用到了十进制转n进制的方法：除n取余，逆序排列。代码模拟了这个过程。 注意：因为填入的结果只有0、1，而余数可能为 -1，可以通过商+1重新计算余数，不影响结果。 代码class Solution &#123; public: string baseNeg2(int n) &#123; if(n &#x3D;&#x3D; 0) return &quot;0&quot;; string res &#x3D; &quot;&quot;; while(n)&#123; int quotient &#x3D; n &#x2F; -2; int remainder &#x3D; n - quotient * -2; if(remainder &lt; 0) remainder &#x3D; n - ++quotient * -2; res +&#x3D; to_string(remainder); n &#x3D; quotient; &#125; return string(res.rbegin(), res.rend()); &#125; &#125;; 47.全排列Ⅱ题干给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 示例 1： 输入：nums &#x3D; [1,1,2] 输出：[[1,1,2],[1,2,1],[2,1,1]] 示例 2： 输入：nums &#x3D; [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 解法基本思路：回溯、DFS 相比于46.全排列，这题在输入数组中存在重复数字，这意味着按照之前的方法会导致重复数字被使用导致排列相同的情况。因此需要判断和剪枝。 首先，要先找到重复数字是哪些，最方便的方法就是先对原数组进行排序，那么是否重复只需和上一个数字比较即可。 其次，因为排序，不能直接在原数组上操作了，需要新开一个数组存储每次排列的结果，通过push和pop来实现状态重置。 接着，就需要找到要被剪枝的部分的判断条件—— 以本题的示例1来说： 可以发现，对于一个重复数字，如果它的上一个相同数字已经被使用了（添加进了数组中），那么该数字是不影响接下来的使用的，因为是添加到上一个数字后面的。而对于未被使用（不在结果数组中）的相同数字，就会导致结果重复。1、1、2中选1和选1，剩下的都是1、2，那么结果也都是一样的，因此可以得到跳过的条件： 遍历到的数字和上一个相同（重复了）且上一个数字未被使用。使用一个数组进行记录使用情况，在递归前后改变状态完成状态重置。 注意： i - 1 越界问题，要加上 i &gt; 0; 由于原数组被排序了，也无法得知上一个被push进数组的是哪个，因此for循环需要全部遍历一遍，对于已经被push的（状态数组为true，直接跳过即可）。 idx用于统计结果数组中已push的数字数量，满了就存储一个结果并开始状态重置。 代码class Solution &#123; public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; sub, vector&lt;bool&gt;&amp; used, vector&lt;int&gt;&amp; nums, int idx)&#123; if(idx &#x3D;&#x3D; nums.size())&#123; res.push_back(sub); return; &#125; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1] &amp;&amp; !used[i-1]) continue; sub.push_back(nums[i]); used[i] &#x3D; true; dfs(res, sub, used, nums, idx + 1); used[i] &#x3D; false; sub.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sub; vector&lt;bool&gt; used(nums.size()); sort(nums.begin(), nums.end()); dfs(res, sub, used, nums, 0); return res; &#125; &#125;; 56.合并区间题干以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 示例 1： 输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 示例 2： 输入：intervals &#x3D; [[1,4],[0,4]] 输出：[[0,4]] 解法基本思路：双指针？ 先对二维数组排序，sort默认按第一列升序排，不需要自定义比较函数（自定义的比较函数会让排序慢上很多，其中单写函数比lambda函数要快一些）。排完序后需要合并的区间必然是连续的。 双指针（这里用了一个大小为2的vector便于存储），只需要判断左区间和上一个的右区间即可。 左区间大，不用合并，则直接将当前区间加入结果，双指针替换为当前区间的左右边界； 左区间小，再判断右区间和上一个的右区间，只有当前右区间更大的时候需要替换右边界的值。 结束循环后，若最后一个区间需要合并，则值已经更新在双指针sub中；若不需要合并，则sub也已经替换为了该区间。仅需将sub再加入结果中即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sub &#x3D; intervals[0]; for(int i &#x3D; 1; i &lt; intervals.size(); ++i)&#123; if(intervals[i][0] &lt;&#x3D; sub[1])&#123; if(intervals[i][1] &gt; sub[1]) sub[1] &#x3D; intervals[i][1]; &#125; else&#123; res.push_back(sub); sub &#x3D; intervals[i]; &#125; &#125; res.push_back(sub); return res;56 &#125; &#125;; 57.插入区间题干给你一个 无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 示例 1： 输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8] 输出：[[1,2],[3,10],[12,16]] 解法基本思路：模拟 遍历一遍，每个元素判断以下三种状态： 完全在插入区间左边，直接push 与插入区间有重叠，求他们的并集，更新插入区间的左右边界。 完全在插入区间右侧，需要判断插入区间是否push了，没push就push一下，然后push本次元素。 如果遍历完都没有push过，那么最后push插入区间。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; bool merged &#x3D; false; vector&lt;vector&lt;int&gt;&gt; res; for (auto&amp; range: intervals) &#123; if (range[1] &lt; newInterval[0]) res.push_back(range); else if (range[0] &gt; newInterval[1]) &#123; if (!merged) &#123; res.push_back(newInterval); merged &#x3D; true; &#125; res.push_back(range); &#125; else &#123; newInterval[0] &#x3D; min(newInterval[0], range[0]); newInterval[1] &#x3D; max(newInterval[1], range[1]); &#125; &#125; if (!merged) &#123; res.push_back(newInterval); &#125; return res; &#125; &#125;; 73.矩阵置0题干给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 你能想出一个仅使用常量空间的解决方案吗？ 示例 示例 1： 输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]] 输出：[[1,0,1],[0,0,0],[1,0,1]] 示例 2： 输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]] 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]] 解法基本思路：模拟 仅用常数空间，那只能利用原数组进行操作，也就是挑一行和一列记录该行/列是否有0。于是问题转化为了如何记录这一行一列本身是否有0？ 思考过程中发现，第一行是最先遍历的话，就能先知道这一行是否有0，那么这一行的值就不重要了，可以用来存储。那么对于列来说，如果是行内遍历列的话（for循环行在外面），只需要维护一个标志位，每次行内遍历时先判断的是第一列，如果是0，标志位置位，就知道了第一列是否有0。这样第一列的值也不重要了（判断过了），也可以用来存储了。 最后按照第一行和第一列的记录情况把对应行列置0。注意跟上述过程相反，为了将记录信息保存到最后，从右下角开始遍历，先向左（到第一列时，这个位置的记录就不需要了。根据标志位对第一列单独置0）再向上。 代码class Solution &#123; public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; bool col0 &#x3D; false; int row &#x3D; matrix.size(); int col &#x3D; matrix[0].size(); for(int i &#x3D; 0; i &lt; row; ++i)&#123; if(matrix[i][0] &#x3D;&#x3D; 0) col0 &#x3D; true; for(int j &#x3D; 1; j &lt; col; ++j)&#123; if(matrix[i][j] &#x3D;&#x3D; 0)&#123; matrix[i][0] &#x3D; 0; matrix[0][j] &#x3D; 0; &#125; &#125; &#125; for(int i &#x3D; row - 1; i &gt;&#x3D; 0; --i)&#123; for(int j &#x3D; col - 1; j &gt;&#x3D; 1; --j) if(matrix[i][0] &#x3D;&#x3D; 0 || matrix[0][j] &#x3D;&#x3D; 0) matrix[i][j] &#x3D; 0; if(col0) matrix[i][0] &#x3D; 0; &#125; &#125; &#125;;","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"},{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"CPP基础笔记","slug":"CPP基础笔记","date":"2023-03-18T08:14:14.000Z","updated":"2023-03-18T08:44:05.047Z","comments":true,"path":"uncategorized/CPP基础笔记/","link":"","permalink":"https://www.hanhan0223.cn/uncategorized/CPP%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"变量和基本类型类型转换 - p35tips 当赋给无符号类型一个超出它表示范围的值时，结果为初始值对该类型表示数值总数的取模后的余数。例如-1赋给unsigned char结果为255。 当赋给无符号类型一个超出它表示范围的值时，结果未定义。 避免无法预知和依赖于实现环境（int长度）的行为。 当在程序中某处使用了算术类型的值而其实所需的是另一种类型的值时，同样会进行类型转换。例如 if ( 2 ) 就是true的意思。 当从无符号数中减去一个值时，要确保结果不是负数。 切勿混用带符号和无符号类型。 字面值 - p39tips 字符串字面值实际为常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符 ‘\\0’, 因此字面值的实际长度要比内容多1。 nullptr是指针字面值。 定义和声明 - p42","text":"变量和基本类型类型转换 - p35tips 当赋给无符号类型一个超出它表示范围的值时，结果为初始值对该类型表示数值总数的取模后的余数。例如-1赋给unsigned char结果为255。 当赋给无符号类型一个超出它表示范围的值时，结果未定义。 避免无法预知和依赖于实现环境（int长度）的行为。 当在程序中某处使用了算术类型的值而其实所需的是另一种类型的值时，同样会进行类型转换。例如 if ( 2 ) 就是true的意思。 当从无符号数中减去一个值时，要确保结果不是负数。 切勿混用带符号和无符号类型。 字面值 - p39tips 字符串字面值实际为常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符 ‘\\0’, 因此字面值的实际长度要比内容多1。 nullptr是指针字面值。 定义和声明 - p42tips 定义于任何函数体外的变量会初始化为0，定义在函数体内的不会被初始化。 声明规定了变量的名字和类型，定义还申请内存空间和初始值。 extern用于声明，若给声明的变量赋值，extern失效。 引用 - p50tips C++11新增右值引用，常说的引用为左值引用。 引用相当于给一个已存在的对象起一个别名，本质为一个指针常量。 引用必须被初始化，且无法换绑。 修改引用的值相当于修改引用绑定的对象。 引用的作用 函数参数，其作用与指针作为函数参数相似，函数对形参的操作，等于对实参本身进行操作。 C++中推荐使用引用而非指针作为函数的参数，指针作为函数形参变量时，调用函数时仍需要在内存中分配空间。（函数调用时，系统采用值传递的方式将实参的值传递给形参，系统会在内存中开辟空间来存储形参变量，并将实参的值复制给形参， 而采用引用作为函数形参，只要传给函数实参的别名，不需要耗费时间在内存中开辟空间存储形参，使用引用，可以提高函数的时间效率，并节省内存空间。） 常量引用。修饰形参，防止误操作。可以对const修饰的变量的引用直接赋值。 函数的返回值。不能返回局部变量的引用。（在内存中不会产生返回值的副本，函数返回值是一个临时对象，临时对象的生命周期在一个完整的语句结束。 ） 指针 - p52tips","categories":[],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"}]},{"title":"LeetCode每日一题--3月及以前","slug":"LeetCode每日一题--3月及以前","date":"2022-11-04T06:33:06.000Z","updated":"2023-04-01T08:21:10.140Z","comments":true,"path":"原理/LeetCode每日一题--3月及以前/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--3%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/","excerpt":"记录每日一题2022.11.4754.到达终点数字题干在一根无限长的数轴上，你站在0的位置，终点在target的位置。 你可以做一些数量的移动 numMoves : 每次你可以选择向左或向右移动。 第 i 次移动（从 i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。 给定整数 target ，返回：到达目标所需的最小移动次数(即最小 numMoves）","text":"记录每日一题2022.11.4754.到达终点数字题干在一根无限长的数轴上，你站在0的位置，终点在target的位置。 你可以做一些数量的移动 numMoves : 每次你可以选择向左或向右移动。 第 i 次移动（从 i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。 给定整数 target ，返回：到达目标所需的最小移动次数(即最小 numMoves） 示例 输入: target &#x3D; 2 输出: 3 解释: 第一次移动，从 0 到 1; 第二次移动，从 1 到 -1; 第三次移动，从 -1 到 2 。 输入: target &#x3D; 3 输出: 2 解释: 第一次移动，从 0 到 1; 第二次移动，从 1 到 3 。 解法本题主要偏向于数学计算，代码性不强。 首先target关于0对称，因此正负与numMoves无关，为便于计算，将target统一为正数。 分析从最简单的情况开始： 向右走numMoves步 未达到target。那就继续走。 正好达到target。此时numMoves为最小值，return。 越过了target。 越过target后，到达dist。同有三种情况 dist与target差值为偶数，最好解决，只需要将某些步的方向变为左，一加变一减，就可以弥补差值，正好到达target。此时返回值不变，仍为 numMoves 。 差值为奇数，此时需要 numMoves++ ，多走一步，若差值变为偶数（此时差值为奇数，走的步长也为奇数，和就是偶数），则问题转化为上1，返回值为 numMoves + 1 。 多走一步，差值仍为奇数，此时再走一步，差值必然变为偶数（同上，走两步的步长必然是一奇一偶，奇数+奇数必是偶数），转化为上1，返回值为numMoves + 2。 以上，代码转化为判断numMoves当前的步长和是否越过了target，以及越过后与target的差值的奇偶。 代码int reachNumber(int target) &#123; target &#x3D; abs(target); int dist &#x3D; 0, numMoves &#x3D; 0; while(dist &lt; target || (dist - target) % 2)&#123; numMoves++; dist +&#x3D; numMoves; &#125; return numMoves; &#125; 优化 int reachNumber(int target) &#123; target &#x3D; abs(target); int n &#x3D; ceil((-1 + sqrt(8L * target + 1)) &#x2F; 2); &#x2F;&#x2F; 注意 8*target 会超过 int 范围 return (n * (n + 1) &#x2F; 2 - target) % 2 &#x3D;&#x3D; 0 ? n : n + 1 + n % 2; &#125; 2022.11.7816.模糊坐标题干我们有一些二维坐标，如 “(1, 3)” 或 “(2, 0.5)”，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。 原始的坐标表示法不会存在多余的零，所以不会出现类似于**”00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”**形式的数字。 最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。 示例 示例 1: 输入: &quot;(123)&quot; 输出: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;] 示例 2: 输入: &quot;(00011)&quot; 输出: [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;] 解释: 0.0, 00, 0001 或 00.01 是不被允许的。 示例 3: 输入: &quot;(100)&quot; 输出: [(10, 0)] 解释: 1.0 是不被允许的 解法本题实际是两次二分，先将字符串用 “, ” 分为两部分，再用 “.” 分别插入到这两部分中的每个位置，判断是否为一个符合要求的字符串。 最简单的暴力解法： for循环从每个位置将字符串分为A、B两部分； 对每个A、B，再次for循环从每个位置插入 “.” ，将符合要求的字符串分别存入vector； 最后用双for循环从两个vector中取值排列组合，存入返回值的vector中。 仅在插入 “.” 时，需要考虑以下异常情况： 若A、B为 “0” 或首位非0，则其整体为一个有效字符串存储。 for循环插入小数点时，若遇到首位为0时，仅允许在0后插入。 for循环插入小数点时，若遇到末位为0时，不允许插入。 有限状态机： 代码class Solution &#123; public: vector&lt;string&gt; classifyNumber(string s)&#123; vector&lt;string&gt; rst; if(s &#x3D;&#x3D; &quot;0&quot; || s[0] !&#x3D; &#39;0&#39;) rst.push_back(s); for(int i &#x3D; 1; i &lt; s.size(); ++i)&#123; if(i !&#x3D; 1 &amp;&amp; s[0] &#x3D;&#x3D; &#39;0&#39; || s.back() &#x3D;&#x3D; &#39;0&#39;) continue; rst.push_back(s.substr(0, i) + &quot;.&quot; + s.substr(i)); &#125; return rst; &#125; vector&lt;string&gt; ambiguousCoordinates(string s) &#123; vector&lt;string&gt; rst; s &#x3D; s.substr(1, s.size() - 2); for(int i &#x3D; 1; i &lt; s.size(); ++i)&#123; vector&lt;string&gt; lnum &#x3D; classifyNumber(s.substr(0, i)); if(lnum.empty()) continue; vector&lt;string&gt; rnum &#x3D; classifyNumber(s.substr(i)); if(rnum.empty()) continue; for(int i &#x3D; 0; i &lt; lnum.size(); i++)&#123; for(int j &#x3D; 0; j &lt; rnum.size(); j++)&#123; rst.push_back(&quot;(&quot; + lnum[i] + &quot;, &quot; + rnum[j] + &quot;)&quot;); &#125; &#125; &#125; return rst; &#125; &#125;; for循环中，相比于**++i，i++需要多开辟一个临时变量来存储i自加后的值**，因此前者性能更好。 2022.11.81684.统一一致字符串的数目题干给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。 请你返回 words 数组中 一致字符串 的数目。 示例 示例 1: 输入：allowed &#x3D; &quot;ab&quot;, words &#x3D; [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;] 输出：2 解释：字符串 &quot;aaab&quot; 和 &quot;baa&quot; 都是一致字符串，因为它们只包含字符 &#39;a&#39; 和 &#39;b&#39; 。 示例 2: 输入：allowed &#x3D; &quot;abc&quot;, words &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;] 输出：7 解释：所有字符串都是一致的。 示例 3: 输入：allowed &#x3D; &quot;cad&quot;, words &#x3D; [&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;] 输出：4 解释：字符串 &quot;cc&quot;，&quot;acd&quot;，&quot;ac&quot; 和 &quot;d&quot; 是一致字符串。 解法本题实际是如何判断一个字符串中的每个字符是否都在另一个字符串中出现过的问题。 最简单的暴力解法就是循环words中字符串的每个字符与allowed中的每个字符进行比较，看是否都能匹配上，全匹配上了计数加一。有无法匹配到的跳出循环，判断该字符串为不一致。 解法2：位运算 定义一个32位的int变量，26个字符，各占一位，占据低26位；通过将字符与 ‘a’ 作差计算相应字符需要向左移位多少。某一位为1，表示该位对应的字符存在。 计算出allowed字符串对应的int值standard，和words中的每个字符串对应的值作或运算，若仍为standard原值，说明该字符串的字符均在allowed中，计数num++。 相比于暴力循环，在内存消耗差不多的情况下，提高了1/3速度。 代码class Solution &#123; public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) &#123; int num &#x3D; 0; auto convert &#x3D; [](string&amp; str)&#123; int rst &#x3D; 0; for(int i &#x3D; 0; i &lt; str.length(); ++i)&#123; rst |&#x3D; 1 &lt;&lt; (str[i] - &#39;a&#39;); &#125; return rst; &#125;; int standard &#x3D; convert(allowed); for(int i &#x3D; 0; i &lt; words.size(); ++i)&#123; if (standard &#x3D;&#x3D; (standard | convert(words[i]))) num++; &#125; return num; &#125; &#125;; 这里使用了匿名函数的方式来封装统一的转换方法。好处是可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。 2022.11.9764.最大加号标志题干在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。**mines[i] = [xi, yi]**表示 grid[xi][yi] == 0 返回 grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。 一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。 示例 示例 1: 输入: n &#x3D; 5, mines &#x3D; [[4, 2]] 输出: 2 解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。 示例 2: 输入: n &#x3D; 1, mines &#x3D; [[0, 0]] 输出: 0 解释: 没有加号标志，返回 0 。 解法本题实际是一个动态规划问题。动态规划的核心思想就是——拆分子问题，记住过往，减少重复计算 题中要求十字的最大阶数，但实际上最大阶数是由中心到四个方向上的连续1数量中的最小值决定的。那么问题转变为了：先求每个点为中心到四个方向上的连续1数量中的最小值，再从中取最大值。 如何求四个方向的最小值？假设简化一下，只求左方向的值怎么求？只需要计算每个点左边最长的连续1的格子数，那么十字就是上述的四次重复。初始化时先假设每个点连续1的数量均为网格的宽度n（即最大值），维护一个自加变量left记录连续1的数量。当在一行中从左向右遍历时，如果遇到0，自加变量清零，否则left++。每次自加后与原先该点记录的值取最小值，更新该点的值。 在重复时，同一个点都会经过四个方向的遍历，但只会保留到四个方向里面的最小值了。遍历结束后，得到一个二维的记录每个点最大十字阶数的向量，取里面的最大值即可。 代码class Solution &#123; public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) &#123; &#x2F;&#x2F; 初始化矩阵 vector&lt;vector&lt;int&gt; &gt; grid(n, vector&lt;int&gt;(n, n)); for(int i &#x3D; 0; i &lt; mines.size(); ++i) grid[mines[i][0]][mines[i][1]] &#x3D; 0; &#x2F;&#x2F; 遍历 int left, right, top, bottom; for(int i &#x3D; 0; i &lt; n; ++i)&#123; left &#x3D; 0; right &#x3D; 0; top &#x3D; 0; bottom &#x3D; 0; for(int j &#x3D; 0, k &#x3D; n - 1; j &lt; n; ++j, --k)&#123; left &#x3D; grid[i][j] ? left + 1 : 0; right &#x3D; grid[i][k] ? right + 1 : 0; top &#x3D; grid[j][i] ? top + 1 : 0; bottom &#x3D; grid[k][i] ? bottom + 1 : 0; grid[i][j] &#x3D; left &lt; grid[i][j] ? left : grid[i][j]; grid[i][k] &#x3D; right &lt; grid[i][k] ? right : grid[i][k]; grid[j][i] &#x3D; top &lt; grid[j][i] ? top : grid[j][i]; grid[k][i] &#x3D; bottom &lt; grid[k][i] ? bottom : grid[k][i]; &#125; &#125; int max &#x3D; 0; for(int i &#x3D; 0; i &lt; n; ++i)&#123; for(int j &#x3D; 0; j &lt; n; ++j)&#123; if (max &lt; grid[i][j]) max &#x3D; grid[i][j]; &#125; &#125; return max; &#125; &#125;; 注：vector的初始化方式。 vector采用 for(auto&amp; item : vector) 的形式遍历较为方便，但是速度较普通for循环更慢，但是不用担心越界问题。 2022.11.111704.判断字符串的两半是否相似题干给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。 两个字符串 相似 的前提是它们都含有相同数目的元音（**’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s** 可能同时含有大写和小写字母。 如果 a 和 b 相似，返回 true ；否则，返回 false 。 示例 示例 1: 输入：s &#x3D; &quot;book&quot; 输出：true 解释：a &#x3D; &quot;bo&quot; 且 b &#x3D; &quot;ok&quot; 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。 示例 2: 输入：s &#x3D; &quot;textbook&quot; 输出：false 解释：a &#x3D; &quot;text&quot; 且 b &#x3D; &quot;book&quot; 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。 解法本题实际就是一次for循环，对字符串s的每个字符判断一次是否为元音即可，中间记录下前后半的元音个数。 可优化的点在于 1.不必for循环整个字符串，由于a、b长度相同，可以只for循环前一半（类似双指针？）。 2.只需维护一个变量记录元音数量即可，左加右减，节约内存。 代码class Solution &#123; public: bool halvesAreAlike(string s) &#123; auto isVowel &#x3D; [](char c)&#123; int val &#x3D; c - &#39;A&#39;; if (val &#x3D;&#x3D; 0 || val &#x3D;&#x3D; 4 || val &#x3D;&#x3D; 8 || val &#x3D;&#x3D; 14 || val &#x3D;&#x3D; 20 || val &#x3D;&#x3D; 32 || val &#x3D;&#x3D; 36 || val &#x3D;&#x3D; 40 || val &#x3D;&#x3D; 46 || val &#x3D;&#x3D; 52 ) return true; else return false; &#125;; int cnt &#x3D; 0; int len &#x3D; s.length() &#x2F; 2; for(int i &#x3D; 0; i &lt; len; ++i)&#123; cnt +&#x3D; isVowel(s[i]) ? 1 : 0; cnt -&#x3D; isVowel(s[i + len]) ? 1 : 0; &#125; return cnt &#x3D;&#x3D; 0; &#125; &#125;; 我这里直接写了个匿名函数通过ASCII的差值判断是否为元音，还可以用集合。 unordered_set&lt;char&gt; vowels &#x3D; &#123;&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;, &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;&#125;; cnt +&#x3D; vowels.count(s[i]); 2022.12.61805.字符串中不同整数的数目题干给你一个字符串 word ，该字符串由数字和小写英文字母组成。 请你用空格替换每个不是数字的字符。例如，**”a123bc34d8ef34”** 将会变成 “ 123 34 8 34” 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：**”123”、”34”、”8”** 和 “34” 。 返回对 word 完成替换后形成的 不同 整数的数目。 只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。 示例 示例 1: 输入：word &#x3D; &quot;a123bc34d8ef34&quot; 输出：3 解释：不同的整数有 &quot;123&quot;、&quot;34&quot; 和 &quot;8&quot; 。注意，&quot;34&quot; 只计数一次。 示例 2: 输入：word &#x3D; &quot;leet1234code234&quot; 输出：2 示例 3: 输入：word &#x3D; &quot;a1b01c001&quot; 输出：1 解释：&quot;1&quot;、&quot;01&quot; 和 &quot;001&quot; 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。 解法本题解法就是双指针和C++集合不能有重复项特点的应用。 先用一个头指针 i ，for循环遍历字符串的每一项，判断是否为数字（ASCII码值小于58，09是4857），如果为数字，进行三步操作： 1.使用另一个指针 j ，从 i 处开始向后扫，直到扫到非数字字符。 2.移动 i ，从该串数字的最高位开始判断有无0，有前导0的位全部去掉。 3.将过滤后的字符串加入集合Set中。 代码class Solution &#123; public: int numDifferentIntegers(string word) &#123; set&lt;string&gt; nums; int j, len &#x3D; word.length(); for(int i &#x3D; 0; i &lt; len; i++)&#123; if(word[i] &lt; 58)&#123; j &#x3D; i; while(word[j] &lt; 58 &amp;&amp; j &lt; len) j++; while(word[i] &#x3D;&#x3D; 48 &amp;&amp; j - i &gt; 1) i++; nums.insert(word.substr(i, j - i)); i &#x3D; j; &#125; &#125; return nums.size(); &#125; &#125;; 2022.12.71775.通过最少操作次数使数组的和相等题干给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。 请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。 示例 示例 1: 输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [1,1,2,2,2,2] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums2[0] 变为 6 。 nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [6,1,2,2,2,2] 。 - 将 nums1[5] 变为 1 。 nums1 &#x3D; [1,2,3,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。 - 将 nums1[2] 变为 2 。 nums1 &#x3D; [1,2,2,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。 示例 2: 输入：nums1 &#x3D; [1,1,1,1,1,1,1], nums2 &#x3D; [6] 输出：-1 解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。 示例 3: 输入：nums1 &#x3D; [6,6], nums2 &#x3D; [1] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums1[0] 变为 2 。 nums1 &#x3D; [2,6], nums2 &#x3D; [1] 。 - 将 nums1[1] 变为 2 。 nums1 &#x3D; [2,2], nums2 &#x3D; [1] 。 - 将 nums2[0] 变为 4 。 nums1 &#x3D; [2,2], nums2 &#x3D; [4] 。 解法本题用到了贪心思想，即一个问题拆解成多个步骤，每个步骤采用最优的解法。 在本题中，要让两个数组以最少步骤达到和相同，就代表每一步缩小的差距越大越好，也就是**优先把和小的数组里的 1 变成 6 ，把和大的数组中的 6 变成 1.**以此类推，接下来是5、2；4、3······当走到其中一步时差距缩小为非正数时，说明该步就是最后一步了。 并且1变6和6变1的意义是相同的，都是缩小了5的差距，因此从节约空间的角度考虑，可以只维护一个长度为6的1维数组，记录操作的分布情况（缩小543210的差距）。 代码class Solution &#123; public: int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int diff &#x3D; accumulate(nums1.begin(), nums1.end(), 0) - accumulate(nums2.begin(), nums2.end(), 0); if (diff &lt; 0) return minOperations(nums2, nums1); if (diff &#x3D;&#x3D; 0) return 0; int cnt[6] &#x3D; &#123;0&#125;; int i &#x3D; 0, count &#x3D; 0; for(;i &lt; nums1.size();++i) ++cnt[nums1[i] - 1]; for(i &#x3D; 0;i &lt; nums2.size();++i) ++cnt[6 - nums2[i]]; for(i &#x3D; 5;i &gt; 0; --i)&#123; while(cnt[i] &gt; 0 &amp;&amp; diff &gt; 0)&#123; diff -&#x3D; i; --cnt[i]; count++; &#125; &#125; return diff &gt; 0 ? -1 : count; &#125; &#125;; accumulate属于numeric头文件，作用是计算数组或C++容器指定地址范围内的成员的和。 参数1、2分别为 容器 / 数组 指向要计算的第一个元素和最后一个元素的 迭代器 / 首地址 ，参数3为累加的初始值。 这里为了下面for循环存储操作的分布情况，固定了nums1的和要大于nums2；若是小于，就调换输入顺序重新执行函数（这里测试过，相比于swap调换两个vector，这种方式要快一些）。这里心机的把 diff == 0 的情况放在了 diff &lt; 0 下面，大部分情况下应该都是不相等的，这样可以少点计算量（dog）。 2022.12.91780.判断一个数字是否可以表示成三的幂的和题干给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。 对于一个整数 y ，如果存在整数 x 满足 y == 3^x ，我们称这个整数 y 是三的幂。 示例 示例 1: 输入：n &#x3D; 12 输出：true 解释：12 &#x3D; 3^1 + 3^2 示例 2: 输入：n &#x3D; 91 输出：true 解释：91 &#x3D; 3^0 + 3^2 + 3^4 示例 3: 输入：n &#x3D; 21 输出：false 解法基本思路： 看示例1可知，满足条件的数为3的不同次幂的和，那么必然能被3整除，看示例2可知另一情况，3^0为1，也就是除以3余数为1，但是也满足条件。当示例1中除以3，得到4，又变成了示例2的情况，即3^0 + 3的幂。 于是得到满足条件的整数一定具有以下性质： 除以3以后余数必为1或0； 性质1得到的商依旧满足性质1，直至商为0。 代码class Solution &#123; public: bool checkPowersOfThree(int n) &#123; while(n)&#123; if (n % 3 &#x3D;&#x3D; 2) return false; n &#x2F;&#x3D; 3; &#125; return true; &#125; &#125;; 2023.2.81233.删除子文件夹（未完结）题干你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：**’/‘** 后跟一个或者多个小写英文字母。 例如，”/leetcode“ 和 “/leetcode/problems“ 都是有效的路径，而空字符串和 “/“ 不是。 示例 示例 1: 输入：folder &#x3D; [&quot;&#x2F;a&quot;,&quot;&#x2F;a&#x2F;b&quot;,&quot;&#x2F;c&#x2F;d&quot;,&quot;&#x2F;c&#x2F;d&#x2F;e&quot;,&quot;&#x2F;c&#x2F;f&quot;] 输出：[&quot;&#x2F;a&quot;,&quot;&#x2F;c&#x2F;d&quot;,&quot;&#x2F;c&#x2F;f&quot;] 解释：&quot;&#x2F;a&#x2F;b&quot; 是 &quot;&#x2F;a&quot; 的子文件夹，而 &quot;&#x2F;c&#x2F;d&#x2F;e&quot; 是 &quot;&#x2F;c&#x2F;d&quot; 的子文件夹。 示例 2: 输入：folder &#x3D; [&quot;&#x2F;a&quot;,&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;] 输出：[&quot;&#x2F;a&quot;] 解释：文件夹 &quot;&#x2F;a&#x2F;b&#x2F;c&quot; 和 &quot;&#x2F;a&#x2F;b&#x2F;d&quot; 都会被删除，因为它们都是 &quot;&#x2F;a&quot; 的子文件夹。 示例 3: 输入: folder &#x3D; [&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;ca&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;] 输出: [&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;ca&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;] 解法基本思路： 先按照字典序排序（/a，/a/b，/a/b/c，/b），这样在遍历时只需要和上一个被加入的非子文件夹比较（因为相同根文件夹情况下先短后长排序），便于排除。 将第一个文件夹加入输出，遍历folder中的剩余文件夹，作如下判断： 1.当前字符串长度比上一个被加入的字符串短的，必然是根文件夹名改变了，是非子文件夹，加入。 2.当前字符串的前n个字符与上一个被加入的字符串完全相同且第n+1个字符为 ‘/’ 的，必然是子文件夹，排除。 解法2：字典树 代码class Solution &#123; public: vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) &#123; sort(folder.begin(), folder.end()); vector&lt;string&gt; rst &#x3D; &#123;folder[0]&#125;; for(int i &#x3D; 1; i &lt; folder.size(); ++i)&#123; int ori_len &#x3D; rst.back().size(); int cur_len &#x3D; folder[i].size(); if (ori_len &gt;&#x3D; cur_len || !(rst.back() &#x3D;&#x3D; folder[i].substr(0, ori_len) &amp;&amp; folder[i][ori_len] &#x3D;&#x3D; &#39;&#x2F;&#39;)) rst.push_back(folder[i]); &#125; return rst; &#125; &#125;; 2023.2.91797.设计一个验证系统题干你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类： AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。 如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 所有 generate 函数的调用都会包含独一无二的 tokenId 值。 所有函数调用中，currentTime 的值 严格递增 。 所有函数的调用次数总共不超过 2000 次。 示例 输入： [&quot;AuthenticationManager&quot;, &quot;renew&quot;, &quot;generate&quot;, &quot;countUnexpiredTokens&quot;, &quot;generate&quot;, &quot;renew&quot;, &quot;renew&quot;, &quot;countUnexpiredTokens&quot;] [[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]] 输出： [null, null, null, 1, null, null, null, 0] 解释： AuthenticationManager authenticationManager &#x3D; new AuthenticationManager(5); &#x2F;&#x2F; 构造 AuthenticationManager ，设置 timeToLive &#x3D; 5 秒。 authenticationManager.renew(&quot;aaa&quot;, 1); &#x2F;&#x2F; 时刻 1 时，没有验证码的 tokenId 为 &quot;aaa&quot; ，没有验证码被更新。 authenticationManager.generate(&quot;aaa&quot;, 2); &#x2F;&#x2F; 时刻 2 时，生成一个 tokenId 为 &quot;aaa&quot; 的新验证码。 authenticationManager.countUnexpiredTokens(6); &#x2F;&#x2F; 时刻 6 时，只有 tokenId 为 &quot;aaa&quot; 的验证码未过期，所以返回 1 。 authenticationManager.generate(&quot;bbb&quot;, 7); &#x2F;&#x2F; 时刻 7 时，生成一个 tokenId 为 &quot;bbb&quot; 的新验证码。 authenticationManager.renew(&quot;aaa&quot;, 8); &#x2F;&#x2F; tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，且 8 &gt;&#x3D; 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。 authenticationManager.renew(&quot;bbb&quot;, 10); &#x2F;&#x2F; tokenId 为 &quot;bbb&quot; 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。 authenticationManager.countUnexpiredTokens(15); &#x2F;&#x2F; tokenId 为 &quot;bbb&quot; 的验证码在时刻 15 过期，tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。 解法基本思路： 采用哈希表存储 [tokenId，过期时间点] 这一键值对，保存信息。 因为提到了currentTime是严格递增的，因此在存储id时可以不用队列，直接用顺序表存储。 因为函数总调用次数不超过2000次，因此甚至不需要对表进行维护（即删除过期id）。 代码class AuthenticationManager &#123; public: AuthenticationManager(int timeToLive) &#123; liveTime &#x3D; timeToLive; &#125; void generate(string tokenId, int currentTime) &#123; liveIds[tokenId] &#x3D; currentTime + liveTime; &#125; void renew(string tokenId, int currentTime) &#123; if (liveIds[tokenId] &gt; currentTime) generate(tokenId, currentTime); &#125; int countUnexpiredTokens(int currentTime) &#123; int cnt &#x3D; 0; for (auto iter &#x3D; liveIds.begin(); iter !&#x3D; liveIds.end(); ++iter) &#123; if (iter-&gt;second &gt; currentTime) cnt++; &#125; return cnt; &#125; private: int liveTime; unordered_map&lt;string, int&gt; liveIds; &#125;; &#x2F;** * Your AuthenticationManager object will be instantiated and called as such: * AuthenticationManager* obj &#x3D; new AuthenticationManager(timeToLive); * obj-&gt;generate(tokenId,currentTime); * obj-&gt;renew(tokenId,currentTime); * int param_3 &#x3D; obj-&gt;countUnexpiredTokens(currentTime); *&#x2F; 2023.2.112335.装满杯子所需的最短总时长题干现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。 示例 示例 1: 输入：amount &#x3D; [1,4,2] 输出：4 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯温水。 第 2 秒：装满一杯温水和一杯热水。 第 3 秒：装满一杯温水和一杯热水。 第 4 秒：装满一杯温水。 可以证明最少需要 4 秒才能装满所有杯子。 示例 2: 输入：amount &#x3D; [5,4,4] 输出：7 示例 3: 输入：amount &#x3D; [5,0,0] 输出：5 解法基本思路： 简单的贪心算法。每次循环先排序，取较大的两个各减一，直至全为0. 代码class Solution &#123; public: int fillCups(vector&lt;int&gt;&amp; amount) &#123; int turns &#x3D; 0; while(amount[0] + amount[1] + amount[2]) &#123; sort(amount.begin(), amount.end()); turns++; amount[2]--; if (amount[1] &gt; 0) amount[1]--; &#125; return turns; &#125; &#125;; 2023.2.131234.替换子串得到平衡字符串题干有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。 假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。 给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。 你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。 请返回待替换子串的最小可能长度。 如果原字符串自身就是一个平衡字符串，则返回 0。 示例 示例 1: 输入：s &#x3D; &quot;QWER&quot; 输出：0 解释：s 已经是平衡的了。 示例 2: 输入：s &#x3D; &quot;QQWE&quot; 输出：1 解释：我们需要把一个 &#39;Q&#39; 替换成 &#39;R&#39;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。 示例 3: 输入：s &#x3D; &quot;QQQQ&quot; 输出：3 解释：我们可以替换后 3 个 &#39;Q&#39;，使 s &#x3D; &quot;QWER&quot;。 解法基本思路： 最终目标是四个字符的数量都达到 n/4 个时，改动字符串的长度怎么取最短。很容易想到双指针来控制应该改动的部分的首尾。 因为替换字符串内的字符都可以任选，那么只要保证该子串外的字符数达标即可。那么判断条件就是子串外的四个字符数均小于等于 n/4 个。 先统计一遍原字符串中的四个字符数。 移动右指针时将子串外对应字符数-1，移动左指针+1。 以右指针为基准进行for循环，通过左指针右移压缩改动字符串的长度，找出符合标准的最小值即可。 代码class Solution &#123; public: int balancedString(string s) &#123; int len &#x3D; s.length(); int num &#x3D; len &#x2F; 4, cnt[&#39;X&#39;] &#x3D; &#123;0&#125;; for (char&amp; c : s) &#123; cnt[c]++; &#125; if (cnt[&#39;Q&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;W&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;E&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;R&#39;] &#x3D;&#x3D; num) return 0; int res &#x3D; len, left &#x3D; 0; for (int right &#x3D; 0; right &lt; len; ++right) &#123; cnt[s[right]]--; while (left &lt;&#x3D; right &amp;&amp; cnt[&#39;Q&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;W&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;E&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;R&#39;] &lt;&#x3D; num) &#123; res &#x3D; min(res, right - left + 1); cnt[s[left++]]++; &#125; &#125; return res; &#125; &#125;; 2023.2.181237.找出给定方程的正整数解题干给你一个函数 f(x, y) 和一个目标结果 z，函数公式未知，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。满足条件的结果数对可以按任意顺序返回。 尽管函数的具体式子未知，但它是单调递增函数，也就是说： f(x, y) &lt; f(x + 1, y)f(x, y) &lt; f(x, y + 1) 函数接口定义如下： interface CustomFunction &#123; public: &#x2F;&#x2F; Returns some positive integer f(x, y) for two positive integers x and y based on a formula. int f(int x, int y); &#125;; 你的解决方案将按如下规则进行评判： 判题程序有一个由 CustomFunction 的 9 种实现组成的列表，以及一种为特定的 z 生成所有有效数对的答案的方法。 判题程序接受两个输入：function_id（决定使用哪种实现测试你的代码）以及目标结果 z 。 判题程序将会调用你实现的 findSolution 并将你的结果与答案进行比较。 如果你的结果与答案相符，那么解决方案将被视作正确答案，即 Accepted 。 示例 示例 1: 输入：function_id &#x3D; 1, z &#x3D; 5 输出：[[1,4],[2,3],[3,2],[4,1]] 解释：function_id &#x3D; 1 暗含的函数式子为 f(x, y) &#x3D; x + y 以下 x 和 y 满足 f(x, y) 等于 5： x&#x3D;1, y&#x3D;4 -&gt; f(1, 4) &#x3D; 1 + 4 &#x3D; 5 x&#x3D;2, y&#x3D;3 -&gt; f(2, 3) &#x3D; 2 + 3 &#x3D; 5 x&#x3D;3, y&#x3D;2 -&gt; f(3, 2) &#x3D; 3 + 2 &#x3D; 5 x&#x3D;4, y&#x3D;1 -&gt; f(4, 1) &#x3D; 4 + 1 &#x3D; 5 示例 2: 输入：function_id &#x3D; 2, z &#x3D; 5 输出：[[1,5],[5,1]] 解释：function_id &#x3D; 2 暗含的函数式子为 f(x, y) &#x3D; x * y 以下 x 和 y 满足 f(x, y) 等于 5： x&#x3D;1, y&#x3D;5 -&gt; f(1, 5) &#x3D; 1 * 5 &#x3D; 5 x&#x3D;5, y&#x3D;1 -&gt; f(5, 1) &#x3D; 5 * 1 &#x3D; 5 提示： 1 &lt;= function_id &lt;= 9 1 &lt;= z &lt;= 100 题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。 在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。 解法基本思路： 这个题目我觉得题干有非常多的无效信息，因为f（x，y）是具体实现不可见的函数。 实际有效的信息只有两条： f（x，y）是单调递增函数 x，y的取值范围均为 [1, 1000] 那么我们可以采用枚举的方式（遍历），分别将x，y的值设为区间的两端（原因后面可以体会到） x初始为1最小，y初始为1000最大（即x只能递增，y只能递减），计算f（x，y）有三种结果 当f（x，y）&lt; z 时，由单调性可知，f（x，y-1）同样小于z，而我们的目标是等于z，此时唯一的动作就是x++； 当f（x，y）&gt; z 时，同理，只能y–； 当f（x，y）== z 时，存储这一对x，y，同时x++，y–（两个同时增减，因为只变动一个没有意义，必然不可能等于z）。 代码&#x2F;* * &#x2F;&#x2F; This is the custom function interface. * &#x2F;&#x2F; You should not implement it, or speculate about its implementation * class CustomFunction &#123; * public: * &#x2F;&#x2F; Returns f(x, y) for any given positive integers x and y. * &#x2F;&#x2F; Note that f(x, y) is increasing with respect to both x and y. * &#x2F;&#x2F; i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1) * int f(int x, int y); * &#125;; *&#x2F; class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) &#123; vector&lt;vector&lt;int&gt;&gt; res; int x &#x3D; 1, y &#x3D; 1000; while(x &lt;&#x3D; 1000 &amp;&amp; y) &#123; int rst &#x3D; customfunction.f(x, y); if (rst &lt; z) x++; else if (rst &gt; z) y--; else res.push_back(&#123;x++, y--&#125;); &#125; return res; &#125; &#125;; 2023.2.202347.最好的扑克手牌题干给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。 下述是从好到坏你可能持有的 手牌类型 ： “Flush“：同花，五张相同花色的扑克牌。 “Three of a Kind“：三条，有 3 张大小相同的扑克牌。 “Pair“：对子，两张大小一样的扑克牌。 “High Card“：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。 示例 示例 1: 输入：ranks &#x3D; [13,2,3,1,9], suits &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;] 输出：&quot;Flush&quot; 示例 2: 输入：ranks &#x3D; [4,4,2,4,4], suits &#x3D; [&quot;d&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 输出：&quot;Three of a Kind&quot; 示例 3: 输入：ranks &#x3D; [10,10,2,12,9], suits &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;d&quot;] 输出：&quot;Pair&quot; 解法基本思路： 简单题，没啥说的，翻译一下就是： 先判断suits里的元素是否均相同； 再判断ranks里是否存在三个/两个/不存在相同的元素； 代码class Solution &#123; public: string bestHand(vector&lt;int&gt;&amp; ranks, vector&lt;char&gt;&amp; suits) &#123; if (equal(suits.begin()+1, suits.end(), suits.begin())) return &quot;Flush&quot;; int cnt[14] &#x3D; &#123;0&#125;; bool isPair &#x3D; false; for(int i &#x3D; 0; i &lt; ranks.size(); ++i)&#123; if(++cnt[ranks[i]] &#x3D;&#x3D; 3) return &quot;Three of a Kind&quot;; isPair |&#x3D; cnt[ranks[i]] &#x3D;&#x3D; 2; &#125; return isPair ? &quot;Pair&quot; : &quot;High Card&quot;; &#125; &#125;; 2023.2.242357.使数组中所有元素都等于0题干给你一个非负整数数组 nums 。在一步操作中，你必须： 选出一个正整数 x ，x 需要小于或等于 nums 中 最小 的 非零 元素。 nums 中的每个正整数都减去 x。 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。 示例 示例 1: 输入：nums &#x3D; [1,5,0,3,5] 输出：3 解释： 第一步操作：选出 x &#x3D; 1 ，之后 nums &#x3D; [0,4,0,2,4] 。 第二步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,2,0,0,2] 。 第三步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,0,0,0,0] 。 示例 2: 输入：nums &#x3D; [0] 输出：0 解法基本思路： 简单题，没啥说的，每一步都找一个最小的正整数减掉，直到全为0。 不必要真去减，如示例1，第一步减1后3变成2，正好是第二步减的数，也就是说只需要记录之前减的总数（上一个需要被减的数本身）就行。 代码class Solution &#123; public: int minimumOperations(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int lastNum &#x3D; 0, cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if (nums[i] - lastNum &gt; 0) &#123; lastNum &#x3D; nums[i]; cnt++; &#125; &#125; return cnt; &#125; &#125;; 2023.2.251247.交换字符使得字符串相同题干有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x“ 和 “y“，你需要通过「交换字符」的方式使这两个字符串相同。 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 **s1[i] 和 s2[j]**，但不能交换 **s1[i] 和 s1[j]**。 最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。 示例 示例 1: 输入：s1 &#x3D; &quot;xx&quot;, s2 &#x3D; &quot;yy&quot; 输出：1 解释：交换 s1[0] 和 s2[1]，得到 s1 &#x3D; &quot;yx&quot;，s2 &#x3D; &quot;yx&quot;。 示例 2: 输入：s1 &#x3D; &quot;xy&quot;, s2 &#x3D; &quot;yx&quot; 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 &#x3D; &quot;yy&quot;，s2 &#x3D; &quot;xx&quot; 。 交换 s1[0] 和 s2[1]，得到 s1 &#x3D; &quot;xy&quot;，s2 &#x3D; &quot;xy&quot; 。 示例 3: 输入：s1 &#x3D; &quot;xx&quot;, s2 &#x3D; &quot;xy&quot; 输出：-1 解法基本思路： 首先统计两个字符串同一位置下的字符不同的数量，因为交换只会发生在不同处。 不同有两种情况，xy和yx。 根据上述三个示例可以得出结论，对于每2对不同的字符： 若为同一形式（均为xy），只需要对角交换1次即可相同； 若为不同形式（xy和yx），需要先同位置交换1次变为示例1，再对角交换一次； 若仅有一对不同，无法交换至相同。 可以得出结论： xy、yx和为奇数，无法相同，返回-1； 若和为偶数，分为两种情况，xy、yx均为偶数或奇数； 若均为偶数，按照每两对1次的情况，只需要 xy / 2 + yx / 2 次 若均为奇数，则在除去每两对一次的情况下，会留存一对示例2情况； 结合3、4可得共 xy / 2 + yx / 2 + xy % 2 + yx % 2 次。 代码class Solution &#123; public: int minimumSwap(string s1, string s2) &#123; int xy &#x3D; 0, yx &#x3D; 0; for(int i &#x3D; 0; i &lt; s1.length(); ++i)&#123; xy +&#x3D; s1[i] &lt; s2[i]; yx +&#x3D; s1[i] &gt; s2[i]; &#125; if ((xy + yx) % 2) return -1; return xy &#x2F; 2 + yx &#x2F; 2 + xy % 2 + yx % 2; &#125; &#125;; 2023.2.271144.递减元素使数组成锯齿状题干给你一个整数数组 nums，每次操作会从中选择一个元素并将该元素的值减少 1。 如果符合下列情况之一，则数组 A 就是 锯齿数组： 每个偶数索引对应的元素都大于相邻的元素，即 A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; … 每个奇数索引对应的元素都大于相邻的元素，即 A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; … 返回将数组 nums 转换为锯齿数组所需的最小操作次数。 示例 示例 1: 输入：nums &#x3D; [1,2,3] 输出：2 解释：我们可以把 2 递减到 0，或把 3 递减到 1。 示例 2: 输入：nums &#x3D; [9,6,1,6,2] 输出：4 解法基本思路： 枚举呗。 奇数和偶数下标各遍历一遍，每次都判断和两边的差值，记录最大值求和即可。 排除掉当元素处于数组边界时越界的问题，最后比较两种哪种小。 代码class Solution &#123; public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) &#123; int cnt[2] &#x3D; &#123;0&#125;; for(int i &#x3D; 0; i &lt; 2; ++i)&#123; for(int j &#x3D; i; j &lt; nums.size(); ++j, ++j)&#123; int step &#x3D; 0; if(j) step &#x3D; max(step, nums[j] - nums[j - 1] + 1); if(j &lt; nums.size()-1) step &#x3D; max(step, nums[j] - nums[j + 1] + 1); cnt[i] +&#x3D; step; &#125; &#125; return min(cnt[0], cnt[1]); &#125; &#125;; 面试题16.07.最大数值题干编写一个方法，找出两个数字 a 和 b 中最大的那一个。不得使用if-else或其他比较运算符。 示例 示例 1: 输入： a &#x3D; 1, b &#x3D; 2 输出： 2 解法基本思路： 首先考虑到的就是不用比较符号如何出现控制输出a还是b呢？ 想到了类似门电路，用0和1控制就行，也就是 a * (condition ^ 1) + b * condition ; 那么什么运算结果是0和1呢，很容易想到通过位运算获取符号位。 于是得到以下代码： class Solution &#123; public: int maximum(int a, int b) &#123; &#x2F;&#x2F; 注意当值为负数时，右移高位是会补1的，因此需要把计算结果转为无符号 int signSub &#x3D; static_cast&lt;unsigned&gt;(a - b) &gt;&gt; 31; return a * (signSub ^ 1) + b * signSub; &#125; &#125;; 提交时出现了问题 signed integer overflow: 2147483647 - -2147483648 cannot be represented in type &#39;int&#39; 忘记考虑了溢出的问题，在 a - b 时就溢出了。当a和b同号时，不存在溢出问题，可以直接用上述方法，只有当ab异号时需要考虑溢出问题。 可以发现，当a和b异号时，若a为负数，符号位1，需要输出b，也就是signSub = 1；a为正数，符号位0，输出a，signSub = 0. 可以得到此时的处理方法，signSub = a符号位 ^ b符号位 ^ b符号位。 在不使用比较运算符的情况下，可以用 &amp;&amp; 作为if判断使用。 代码 class Solution &#123; public: int maximum(int a, int b) &#123; int signA &#x3D; static_cast&lt;unsigned&gt;(a) &gt;&gt; 31; int signB &#x3D; static_cast&lt;unsigned&gt;(b) &gt;&gt; 31; int signSub &#x3D; signA ^ signB ^ signB; int temp &#x3D; (signA ^ signB ^ 1) &amp;&amp; (signSub &#x3D; static_cast&lt;unsigned&gt;(a - b) &gt;&gt; 31); return a * (signSub ^ 1) + b * signSub; &#125; &#125;; 2023.2.282363.合并相似的物品题干给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质： items[i] = [valuei, weighti] 其中 valuei 表示第 i 件物品的 价值 ，weighti 表示第 i 件物品的 重量 。 items 中每件物品的价值都是 唯一 的 。 请你返回一个二维数组 ret，其中 **ret[i] = [valuei, weighti]**， weighti 是所有价值为 valuei 物品的 重量之和 。 注意： ret 应该按价值 升序 排序后返回。 1 &lt;= valuei, weighti &lt;= 1000 示例 示例 1: 输入：items1 &#x3D; [[1,1],[4,5],[3,8]], items2 &#x3D; [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 示例 2: 输入：items1 &#x3D; [[1,1],[3,2],[2,3]], items2 &#x3D; [[2,1],[3,2],[1,3]] 输出：[[1,4],[2,4],[3,4]] 示例 3: 输入：items1 &#x3D; [[1,3],[2,2]], items2 &#x3D; [[7,1],[2,2],[1,4]] 输出：[[1,7],[2,4],[7,1]] 解法基本思路： 就是求出现过的每种价值的总重量，价值不重复，自然想到了哈希，开一个 cnt[1001] ，下标表示价值。 刚好，需要按照价值升序排序，从小到大遍历cnt即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int cnt[1001] &#x3D; &#123;0&#125;; for(int i &#x3D; 0; i &lt; items1.size(); ++i)&#123; cnt[items1[i][0]] +&#x3D; items1[i][1]; &#125; for(int i &#x3D; 0; i &lt; items2.size(); ++i)&#123; cnt[items2[i][0]] +&#x3D; items2[i][1]; &#125; for(int i &#x3D; 0; i &lt; 1001; ++i)&#123; if(cnt[i]) ret.push_back(&#123;i, cnt[i]&#125;); &#125; return ret; &#125; &#125;; 191.位1的个数题干编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示：输入必须是长度为 32 的 二进制串 。 示例 示例 1: 输入：n &#x3D; 00000000000000000000000000001011 输出：3 示例 2: 输入：n &#x3D; 11111111111111111111111111111101 输出：31 解法基本思路： 位运算，每位都和1与一下就行。 尝试了一下发现，1移位和n与 ，比 n移位和1与 速度快。 代码class Solution &#123; public: int hammingWeight(uint32_t n) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; 32; ++i)&#123; if ((n &amp; (1 &lt;&lt; i)) &gt; 0) cnt++; &#125; return cnt; &#125; &#125;; 2023.3.12373.矩阵中的局部最大值题干给你一个大小为 n x n 的整数矩阵 grid 。 生成一个大小为 (n - 2) x (n - 2) 的整数矩阵 maxLocal ，并满足： maxLocal[i] [j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。 返回生成的矩阵 示例 示例 1: 输入：grid &#x3D; [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] 输出：[[9,9],[8,6]] 示例 2: 输入：grid &#x3D; [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] 输出：[[2,2,2],[2,2,2],[2,2,2]] 解法基本思路： 暴力for循环。。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; largestLocal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int size &#x3D; grid.size(); vector&lt;vector&lt;int&gt;&gt; res(size - 2, vector&lt;int&gt;(size - 2)); for(int i &#x3D; 0; i &lt; size - 2; ++i)&#123; for(int j &#x3D; 0; j &lt; size - 2; ++j)&#123; for(int x &#x3D; i; x &lt; i + 3; ++x)&#123; for(int y &#x3D; j; y &lt; j + 3; ++y)&#123; res[i][j] &#x3D; max(res[i][j], grid[x][y]); &#125; &#125; &#125; &#125; return res; &#125; &#125;; 2023.3.2面试题05.02.二进制数转字符串题干二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。 如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。 提示： 32位包括输出中的 &quot;0.&quot; 这两位。 题目保证输入用例的小数位数最多只有 6 位 示例 示例 1: 输入：0.625 输出：&quot;0.101&quot; 示例 2: 输入：0.1 输出：&quot;ERROR&quot; 提示：0.1无法被二进制准确表示 解法基本思路： double小数的二进制转化方法，以0.625为例： 0.625 * 2 = 1.25，取整数位1作为小数点后第一位； （1.25 - 1）* 2 = 0.5，取整数位0作为小数点后第二位； 0.5 * 2 = 1，取整数位1作为小数点后第三位； 此时剩余数1 - 1 = 0，不再继续。 解法2： 一种数学证明过程。 代码class Solution &#123; public: string printBin(double num) &#123; string res &#x3D; &quot;0.&quot;; while(res.size() &lt; 32 &amp;&amp; num)&#123; num *&#x3D; 2; if (num &lt; 1) res +&#x3D; &quot;0&quot;; else &#123; res +&#x3D; &quot;1&quot;; --num; &#125; &#125; return num ? &quot;ERROR&quot; : res; &#125; &#125;; 2023.3.31487.保证文件名唯一题干给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。 由于两个文件不能共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。 返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。 示例 示例 1: 输入：names &#x3D; [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;] 输出：[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;] 示例 2: 输入：names &#x3D; [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;] 输出：[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;] 示例 3: 输入：names &#x3D; [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;] 输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;] 解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。 解法基本思路： 看到 “ 唯一 ” ，马上就想到了哈希表。key为实际文件名，value记录当前文件名加上后缀时当前存在的最大值。 直接使用输入的names，用哈希表判断是否有重名，只对重名的元素进行修改并记录在哈希表中，节约空间。 执行用时只击败了18%用户，，，不知时间上还可以怎么缩减。 代码class Solution &#123; public: vector&lt;string&gt; getFolderNames(vector&lt;string&gt;&amp; names) &#123; unordered_map&lt;string, int&gt; hash; for(int i &#x3D; 0; i &lt; names.size(); ++i)&#123; if(hash[names[i]])&#123; int cnt &#x3D; hash[names[i]] - 1; while(hash[names[i] + &quot;(&quot; + to_string(++cnt) + &quot;)&quot;]); hash[names[i]] &#x3D; cnt; names[i] +&#x3D; &quot;(&quot; + to_string(cnt) + &quot;)&quot;; &#125; hash[names[i]] &#x3D; 1; &#125; return names; &#125; &#125;; 1967.作为子字符串出现在单词中的字符串数目题干给你一个字符串数组 patterns 和一个字符串 word ，统计 patterns 中有多少个字符串是 word 的子字符串。返回字符串数目。 子字符串 是字符串中的一个连续字符序列。 示例 示例 1: 输入：patterns &#x3D; [&quot;a&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;d&quot;], word &#x3D; &quot;abc&quot; 输出：3 示例 2: 输入：patterns &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], word &#x3D; &quot;aaaaabbbbb&quot; 输出：2 示例 3: 输入：patterns &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;], word &#x3D; &quot;ab&quot; 输出：3 解法一开始看到字符串匹配，第一反应就是经典的KMP算法。(印象深刻，考研那会儿在k = next[k];上卡了好久hhh) 然而在实际场景中，需要匹配的字符串都是较短且无序随机的，初始化的时间开销、额外的空间开销反而会更消耗资源，在字符串搜索中并不实用。因此提交代码后发现执行用时和内存消耗都不低。 查询了一下，在例如Java的String.indexOf中，使用的是暴力方法进行字符串匹配。在glibc中的strstr函数，则采用的是Two-Way算法。 这些库函数均未使用KMP算法，原因在于： KMP需要对字符串预处理，这个需要花时间，如果做多次查找的话，这部分预处理的时间可以分摊到多次查找里面，平摊后时间较短，但是如果只做一次查找，这部分时间是不能忽略的。 KMP的核心思想是跳跃遍历(而不是逐个字节遍历)但是跳跃遍历破坏了CPU对内存的预取且不能进行SIMD优化。 代码class Solution &#123; public: vector&lt;int&gt; getNextArr(string p)&#123; vector&lt;int&gt; next(p.length()); next[0] &#x3D; -1; int k &#x3D; -1, j &#x3D; 0; while(j &lt; p.length() - 1)&#123; if(k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) next[++j] &#x3D; ++k; else k &#x3D; next[k]; &#125; return next; &#125; int kmp(string pattern, string word)&#123; int i &#x3D; 0, j &#x3D; 0; int pLen &#x3D; pattern.length(), wLen &#x3D; word.length(); vector&lt;int&gt; next &#x3D; getNextArr(pattern); while(i &lt; wLen &amp;&amp; j &lt; pLen)&#123; if(j &#x3D;&#x3D; -1 || word[i] &#x3D;&#x3D; pattern[j])&#123; ++i; ++j; &#125; else&#123; j &#x3D; next[j]; &#125; &#125; return j &#x3D;&#x3D; pattern.length() ? 1 : 0; &#125; int numOfStrings(vector&lt;string&gt;&amp; patterns, string word) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; patterns.size(); ++i) cnt +&#x3D; kmp(patterns[i], word); return cnt; &#125; &#125;; 2023.3.51599.经营摩天轮的最大利润题干你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。 给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。 你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。 返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。 示例 示例 1: 输入：customers &#x3D; [8,3], boardingCost &#x3D; 5, runningCost &#x3D; 6 输出：3 解释：座舱上标注的数字是该座舱的当前游客数。 1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 &#x3D; $14 。 2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 &#x3D; $28 。 3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 &#x3D; $37 。 轮转 3 次得到最大利润，最大利润为 $37 。 示例 2: 输入：customers &#x3D; [10,9,6], boardingCost &#x3D; 6, runningCost &#x3D; 4 输出：7 解释： 1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 &#x3D; $20 。 2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 &#x3D; $40 。 3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 &#x3D; $60 。 4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 &#x3D; $80 。 5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 &#x3D; $100 。 6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 &#x3D; $120 。 7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 &#x3D; $122 。 轮转 7 次得到最大利润，最大利润为$122 。 示例 3: 输入：customers &#x3D; [3,4,0,5,1], boardingCost &#x3D; 1, runningCost &#x3D; 92 输出：-1 解释： 1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 &#x3D; -$89 。 2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 &#x3D; -$177 。 3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 &#x3D; -$269 。 4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 &#x3D; -$356 。 5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 &#x3D; -$447 。 利润永不为正，所以返回 -1 。 解法基本思路： 最开始直接排除掉哪怕坐满（4个游客）都不盈利的情况。 之后一遍for循环肯定是要的，得到在没有新游客来时，轮转的最大收益及所在轮次。 这时计算出每次轮转盈利时需要的最小游客数。 对剩下排队的人数进行判断，如果剩下的人数超过了最小值，则按照4个一轮的最大收益方案计算，一定为最大收益。轮次数加上剩余人数 / 4的商，若余数依旧大于最小值，再加一。 需要注意的是，存在之前for循环中前面的轮次的盈利额与后面轮次的盈利额相同时不更新轮次数的情况，因此有多余人数的情况下，需要先更新轮次数至n。 （总感觉逻辑有哪里不完善。。） 代码class Solution &#123; public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) &#123; if(4 * boardingCost - runningCost &lt;&#x3D; 0) return -1; int curP &#x3D; 0, leftP &#x3D; 0, curVal &#x3D; 0, maxVal &#x3D; 0; int turns &#x3D; -1; for(int i &#x3D; 0; i &lt; customers.size(); ++i)&#123; leftP +&#x3D; customers[i]; curP &#x3D; min(4, leftP); curVal +&#x3D; curP * boardingCost - runningCost; leftP -&#x3D; curP; if(curVal &gt; maxVal)&#123; turns &#x3D; i + 1; maxVal &#x3D; curVal; &#125; &#125; int minP &#x3D; runningCost &#x2F; boardingCost + 1; if (leftP &gt;&#x3D; minP)&#123; if(turns &lt; customers.size()) turns &#x3D; customers.size(); turns +&#x3D; leftP &#x2F; 4 + (leftP % 4 &gt;&#x3D; minP ? 1 : 0); &#125; return turns; &#125; &#125;; 2023.3.61653.使字符串平衡的最少删除次数题干给你一个字符串 s ，它仅包含字符 ‘a’ 和 ‘b’ 。 你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i &lt; j ，且 s[i] = ‘b’ 的同时 s[j]= ‘a’ ，此时认为 s 是 平衡 的。 请你返回使 s 平衡 的 最少 删除次数。 示例 示例 1: 输入：s &#x3D; &quot;aababbab&quot; 输出：2 解释：你可以选择以下任意一种方案： 下标从 0 开始，删除第 2 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aaabbb&quot;）， 下标从 0 开始，删除第 3 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aabbbb&quot;）。 示例 2: 输入：s &#x3D; &quot;bbaaaaabb&quot; 输出：2 解释：唯一的最优解是删除最前面两个字符。 解法基本思路： 存在这么一条分割线，使得通过最少次改动让线左边的字母全是a，右边全是b。 那么把s中每个字符后的位置分别作为分割线，计算需要修改的值，记录其中最小的即可。 如果再对分割线左右进行遍历，双重循环比较浪费时间，可以采用前缀和的方式。 先记录整个 s 中 a 的个数，分割线共有 s.length + 1 个位置，在 s[0] 左边时，意味着整个s中的a都需要修改，把a的个数作为修改次数。 此后分割线每往右移动一格，判断移动时跨过的字符是否为a，如果为a，需要将之前统计的次数 -1 ，若为b，则还需要再 + 1 。 最后返回每个位置中的最小值即可。 代码class Solution &#123; public: int minimumDeletions(string s) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length(); ++i) cnt +&#x3D; &#39;b&#39; - s[i]; int res &#x3D; cnt; for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; cnt -&#x3D; &#39;b&#39; - s[i] ? 1 : -1; res &#x3D; min(res, cnt); &#125; return res; &#125; &#125;; 优化动态规划 将问题拆分，考虑s的最后一个字符： 为 b ，无需删除，问题规模缩小为：使 s 的前 n − 1 个字符平衡的最少删除次数； 为 a ，两种情况，1.删除，问题规模缩小为： 使 s 的前 n − 1 个字符平衡的最少删除次数 + 1；2.保留，需要删除前面的所有 b 。选择其中次数最少的。 定义一个 f[i] 表示：使 s 的前 i 个字符平衡的最少删除次数，可以得到： 为 b ，f[i] = f[i - 1]； 为 a ，min(f[i - 1] + 1, b的数量) 最终答案为 f[n] 。 推理这个公式时，实际是上述思路的逆过程，拆分时从后开始由大到小，计算时从前开始由小到大。 class Solution &#123; public: int minimumDeletions(string s) &#123; int f &#x3D; 0, cnt_b &#x3D; 0; for (char c : s) if (c &#x3D;&#x3D; &#39;b&#39;) ++cnt_b; else f &#x3D; min(f + 1, cnt_b); return f; &#125; &#125;; 2023.3.71422.分割字符串的最大得分题干给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。 「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 示例 示例 1: 输入：s &#x3D; &quot;011101&quot; 输出：5 示例 2: 输入：s &#x3D; &quot;1111&quot; 输出：3 解法基本思路： 和昨天那题一模一样的思路。 代码class Solution &#123; public: int maxScore(string s) &#123; int cnt1 &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; cnt1 +&#x3D; s[i] - &#39;0&#39;; &#125; int maxVal &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length() - 1; ++i)&#123; cnt1 +&#x3D; s[i] - &#39;0&#39; ? -1 : 1; maxVal &#x3D; max(maxVal, cnt1); &#125; return maxVal; &#125; &#125;; 2023.3.8剑指offer47.礼物的最大价值题干在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 示例 1: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 解法基本思路： 从其中一格到它的右下角只有两种拿法，往下往右或者往右往下，取决于两个里选哪个。第一反应就是动态规划。 如示例1，22处的最大值取决于11的最大值加上12和21中的最大值 ——&gt; 11的最大值取决于00的最大值加上01和10中的最大值. 设 res{i}{j} 为该处的最大值，则有 res{i}{j} = max(res{i - 1}{j}，res{i}{j - 1}) + grid{i - 1}{j - 1}， 结果为res{m}{n} 代码class Solution &#123; public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m &#x3D; grid.size(), n &#x3D; grid[0].size(); vector&lt;vector&lt;int&gt;&gt; res(m+1, vector&lt;int&gt;(n+1)); for(int i &#x3D; 1; i &lt;&#x3D; m; ++i)&#123; for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123; res[i][j] &#x3D; max(res[i - 1][j], res[i][j - 1]) + grid[i - 1][j - 1]; &#125; &#125; return res[m][n]; &#125; &#125;; 剑指offer Ⅱ 060.出现频率最高的k个数字题干给定一个整数数组 nums 和一个整数 k ，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。 进阶：所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 示例 示例 1: 输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2 输出: [1,2] 示例 2: 输入: nums &#x3D; [1], k &#x3D; 1 输出: [1] 解法基本思路： 第一遍for循环遍历，用哈希表存储每个数字出现的次数。 使用优先队列（底层是堆实现），自定义比较方式为从小到大（小根堆），这样堆顶元素是最小的，便于排除。 第二遍for循环将前k个数字出现的次数加入队列，之后的数字若出现次数更多，替换堆顶元素。 代码class Solution &#123; public: struct cmp &#123; bool operator()(pair&lt;int,int&gt; &amp;m,pair&lt;int,int&gt; &amp;n) &#123; return m.second&gt;n.second; &#125; &#125;; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; cnt; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; cnt[nums[i]]++; &#125; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,cmp&gt; q; for(auto x : cnt)&#123; if(q.size() &#x3D;&#x3D; k)&#123; if(x.second &gt; q.top().second)&#123; q.pop(); q.push(x); &#125; &#125; else q.push(x); &#125; vector&lt;int&gt; res; while(!q.empty())&#123; res.push_back(q.top().first); q.pop(); &#125; return res; &#125; &#125;; 2023.3.92379.得到K个黑块的最少涂色次数题干给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 ‘W‘ 要么是 ‘B‘ ，表示第 i 块的颜色。字符 ‘W‘ 和 ‘B‘ 分别表示白色和黑色。 给你一个整数 k ，表示想要 连续 黑色块的数目。每一次操作中，你可以选择一个白色块将它 涂成 黑色块。 请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。 示例 示例 1: 输入：blocks &#x3D; &quot;WBBWWBBWBW&quot;, k &#x3D; 7 输出：3 解释：一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。得到 blocks &#x3D; &quot;BBBBBBBWBW&quot; 。 可以证明无法用少于 3 次操作得到 7 个连续的黑块。所以我们返回 3 。 示例 2: 输入：blocks &#x3D; &quot;WBWBBBW&quot;, k &#x3D; 2 输出：0 解释：不需要任何操作，因为已经有 2 个连续的黑块。所以我们返回 0 。 解法基本思路： 把白色变成黑色的最少操作次数，其实就是求长为k的滑动窗口内白色的数量。 维护双指针增减白色的数量，取最小值即可。 代码class Solution &#123; public: int minimumRecolors(string blocks, int k) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; k; ++i)&#123; if(blocks[i] - &#39;B&#39;) ++cnt; &#125; int res &#x3D; cnt; for(int i &#x3D; k; i &lt; blocks.length(); ++i)&#123; if(blocks[i] - &#39;B&#39;) ++cnt; if(blocks[i - k] - &#39;B&#39;) --cnt; res &#x3D; min(res, cnt); &#125; return res; &#125; &#125;; 1753.移除石子的最大得分题干你正在玩一个单人游戏，面前放置着大小分别为 a、b 和 c 的 三堆 石子。 每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。 给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。 示例 示例 1: 输入：a &#x3D; 2, b &#x3D; 4, c &#x3D; 6 输出：6 解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是： - 从第一和第三堆取，石子状态现在是 (1, 4, 5) - 从第一和第三堆取，石子状态现在是 (0, 4, 4) - 从第二和第三堆取，石子状态现在是 (0, 3, 3) - 从第二和第三堆取，石子状态现在是 (0, 2, 2) - 从第二和第三堆取，石子状态现在是 (0, 1, 1) - 从第二和第三堆取，石子状态现在是 (0, 0, 0) 总分：6 分 。 示例 2: 输入：a &#x3D; 4, b &#x3D; 4, c &#x3D; 6 输出：7 解法基本思路： 同2335. 代码class Solution &#123; public: int maximumScore(int a, int b, int c) &#123; int res &#x3D; 0; vector&lt;int&gt; arr &#x3D; &#123;a, b, c&#125;; sort(arr.begin(), arr.end()); while(arr[1] !&#x3D; 0)&#123; arr[1]--; arr[2]--; res++; sort(arr.begin(), arr.end()); &#125; return res; &#125; &#125;; 优化 class Solution &#123; public: int maximumScore(int a, int b, int c) &#123; int d &#x3D; max(max(a, b), c), ab &#x3D; a + b + c - d; return ab &lt; d ? ab : (a + b + c) &#x2F; 2; &#125; &#125;; 2023.3.101590.使数组和能被P整除题干给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。 请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。 子数组 定义为原数组中连续的一组元素。 示例 示例 1: 输入：nums &#x3D; [3,1,4,2], p &#x3D; 6 输出：1 解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。 示例 2: 输入：nums &#x3D; [1,2,3], p &#x3D; 3 输出：0 示例 3: 输入：nums &#x3D; [1,2,3], p &#x3D; 7 输出：-1 解法基本思路： **tips1: ** 哨兵思想的应用，处理当前缀和求余等于0时的情况，此时 i 作为下标，表示的位置为第 i + 1 个，因此设为-1。 tips2: 存在前缀和的余数小于总和余数的情况，因此需要 + p ，保证为正数。 tips3: 一开始用的 if(hash[target]) 进行判断，调试时发现这样会产生 hash[target] = 0 的初始化操作，影响后续判断计算，因此改用成员函数count。 代码class Solution &#123; public: int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123; int mod &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i) mod &#x3D; (mod + nums[i]) % p; if(mod &#x3D;&#x3D; 0) return 0; int cur &#x3D; 0, target &#x3D; 0, res &#x3D; nums.size(); unordered_map&lt;int, int&gt; hash; &#x2F;&#x2F; tips1 hash[0] &#x3D; -1; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; cur &#x3D; (cur + nums[i]) % p; &#x2F;&#x2F; tips2 target &#x3D; (cur - mod + p) % p; &#x2F;&#x2F; tips3 if(hash.count(target)) res &#x3D; min(res, i - hash[target]); hash[cur] &#x3D; i; &#125; return res &#x3D;&#x3D; nums.size() ? -1 : res; &#125; &#125;; 2023.3.132383.赢得比赛需要的最少训练时长题干你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。 另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。 你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。 击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少 energy[i] 。 在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。 返回击败全部 n 个对手需要训练的 最少 小时数目。 示例 示例 1: 输入：initialEnergy &#x3D; 5, initialExperience &#x3D; 3, energy &#x3D; [1,4,3,2], experience &#x3D; [2,6,3,1] 输出：8 示例 2: 输入：initialEnergy &#x3D; 2, initialExperience &#x3D; 4, energy &#x3D; [1], experience &#x3D; [3] 输出：0 解法基本思路： 自身的精力要加到比energy数组的和多1，自身的经验只要每次比当前比较的数多1即可。 代码class Solution &#123; public: int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) &#123; int sumE &#x3D; 0, addEx, minH; for(int i &#x3D; 0; i &lt; energy.size(); ++i) sumE +&#x3D; energy[i]; minH &#x3D; sumE &lt; initialEnergy ? 0 : sumE - initialEnergy + 1; for(int i &#x3D; 0; i &lt; experience.size(); ++i)&#123; addEx &#x3D; initialExperience &gt; experience[i] ? 0 : experience[i] - initialExperience + 1; minH +&#x3D; addEx; initialExperience +&#x3D; experience[i] + addEx; &#125; return minH; &#125; &#125;; 2023.3.141605.给定行和列的和求可行矩阵题干给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。 请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。 请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。 示例 示例 1: 输入：rowSum &#x3D; [3,8], colSum &#x3D; [4,7] 输出：[[3,0], [1,7]] 示例 2: 输入：rowSum &#x3D; [5,7,10], colSum &#x3D; [8,6,8] 输出：[[0,5,0], [6,1,0], [2,0,8]] 示例 3: 输入：rowSum &#x3D; [0], colSum &#x3D; [0] 输出：[[0]] 解法基本思路： 由于保证存在解，直接用贪心即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; restoreMatrix(vector&lt;int&gt;&amp; rowSum, vector&lt;int&gt;&amp; colSum) &#123; int row &#x3D; rowSum.size(), col &#x3D; colSum.size(); vector&lt;vector&lt;int&gt;&gt; res(row, vector&lt;int&gt;(col)); for(int i &#x3D; 0; i &lt; row; ++i)&#123; for(int j &#x3D; 0; j &lt; col; ++j)&#123; res[i][j] &#x3D; min(rowSum[i], colSum[j]); rowSum[i] -&#x3D; res[i][j]; colSum[j] -&#x3D; res[i][j]; &#125; &#125; return res; &#125; &#125;; 2023.3.151615.最大网络秩题干n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。 两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。 整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。 示例 示例 1: 输入：n &#x3D; 4, roads &#x3D; [[0,1],[0,3],[1,2],[1,3]] 输出：4 解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。 示例 2: 输入：n &#x3D; 5, roads &#x3D; [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] 输出：5 解释：共有 5 条道路与城市 1 或 2 相连。 示例 3: 输入：n &#x3D; 8, roads &#x3D; [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] 输出：5 解释：2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。 解法基本思路： 暴力解法。统计与每个城市相连的道路数cnt，统计每对城市间是否存在道路，可计算得城市对a、b的最大网络秩为 **cnt[a] + cnt[b] - connected[a] [b]**。 遍历所有不重复的城市对即可。 代码class Solution &#123; public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; vector&lt;int&gt; cnt(n); vector&lt;vector&lt;int&gt;&gt; connected(n, vector&lt;int&gt;(n)); for(auto pair : roads)&#123; cnt[pair[0]]++; cnt[pair[1]]++; connected[pair[0]][pair[1]] &#x3D; 1; connected[pair[1]][pair[0]] &#x3D; 1; &#125; int maxRank &#x3D; 0, rank; for(int i &#x3D; 0; i &lt; n ; ++i)&#123; for(int j &#x3D; i + 1; j &lt; n ; ++j)&#123; rank &#x3D; cnt[i] + cnt[j] - connected[i][j]; maxRank &#x3D; max(maxRank, rank); &#125; &#125; return maxRank; &#125; &#125;; 441.排列硬币题干你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。 示例 示例 1: 输入：n &#x3D; 5 输出：2 示例 2: 输入：n &#x3D; 8 输出：3 解法 解方程 二分查找 代码1.因为n取值很大，乘以常数后可能超出int取值范围，因此需转化为long long型。 class Solution &#123; public: int arrangeCoins(int n) &#123; return static_cast&lt;int&gt;((sqrt(8 * (long long)n + 1) - 1) &#x2F; 2); &#125; &#125;; 2.一开始使用了暴力for循环，太慢了，就想到了二分进行优化。 class Solution &#123; public: int arrangeCoins(int n) &#123; int l &#x3D; 1, r &#x3D; n; while(l &lt; r)&#123; int mid &#x3D; l + (r - l + 1) &#x2F; 2; if((long long)mid * (mid + 1) &lt;&#x3D; (long long)2 * n) l &#x3D; mid; else r &#x3D; mid - 1; &#125; return l; &#125; &#125;; LCP 02.分式简化题干有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？ 连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。 输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组**[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1**。 示例 示例 1: 输入：cont &#x3D; [3, 2, 0, 2] 输出：[13, 4] 解释：原连分数等价于3 + (1 &#x2F; (2 + (1 &#x2F; (0 + 1 &#x2F; 2))))。注意[26, 8], [-13, -4]都不是正确答案。 示例 2: 输入：cont &#x3D; [0, 0, 3] 输出：[3, 1] 解释：如果答案是整数，令分母为1即可。 解法数学 代码class Solution &#123; public: vector&lt;int&gt; fraction(vector&lt;int&gt;&amp; cont) &#123; int m &#x3D; 1, n &#x3D; 0; for(int i &#x3D; cont.size() - 1; i &gt; 0; --i)&#123; int temp &#x3D; m; m &#x3D; cont[i] * m + n; n &#x3D; temp; &#125; return &#123;cont[0] * m + n, m&#125;; &#125; &#125;; 2023.3.172389.和有限的最长子序列题干给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。 返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和 小于等于 queries[i] 的 子序列 的 最大 长度 。 子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。 示例 示例 1: 输入：nums &#x3D; [4,5,2,1], queries &#x3D; [3,10,21] 输出：[2,3,4] 示例 2: 输入：nums &#x3D; [2,3,4,5], queries &#x3D; [1] 输出：[0] 解法基本思路： 先给nums排个序，然后for循环比较queries每个元素最大比前几个nums的元素和大就行。 自己的方法是直接暴力求和一个个比较过去； 题解采用了前缀和统计+二分查找的方法来优化比较的起始位置，但是实际提交发现在给定的测试用例中好像并没有比暴力快。 哦，我就看了个标题，代码里用的 upper_bound() 库函数，难怪比我自己实现的快。 代码class Solution &#123; public: &#x2F;&#x2F; 我的方案 vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; queries.size(); ++i)&#123; int sum &#x3D; 0, cnt &#x3D; 0; while(queries[i] &gt;&#x3D; sum &amp;&amp; cnt &lt; nums.size()) sum +&#x3D; nums[cnt++]; if(sum &gt; queries[i]) cnt--; queries[i] &#x3D; cnt; &#125; return queries; &#125; &#125;; class Solution &#123; public: &#x2F;&#x2F; 题解方法：前缀和+二分查找 int binarySearch(vector&lt;int&gt;&amp; nums, int num)&#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt; r)&#123; int mid &#x3D; (r - l + 1) &#x2F; 2 + l; if (nums[mid] &lt;&#x3D; num) l &#x3D; mid; else r &#x3D; mid - 1; &#125; return l; &#125; vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123; vector&lt;int&gt; sums(nums.size()); sort(nums.begin(), nums.end()); sums[0] &#x3D; nums[0]; for(int i &#x3D; 1; i &lt; nums.size(); ++i)&#123; sums[i] &#x3D; nums[i] + sums[i - 1]; &#125; for(int i &#x3D; 0; i &lt; queries.size(); ++i)&#123; int idx &#x3D; binarySearch(nums, queries[i]); while(queries[i] &lt; sums[idx] &amp;&amp; idx &gt;&#x3D; 0)&#123; if(--idx &lt; 0) break; &#125; queries[i] &#x3D; idx + 1; &#125; return queries; &#125; &#125;; 1254.统计封闭岛屿的数目题干二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。 请返回 封闭岛屿 的数目。 示例 示例 1: 输入：grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] 输出：2 示例 2: 输入：grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] 输出：1 解法基本思路： 可以发现封闭岛屿必然不会出现在矩阵的边缘，因为需要被1全包裹。 也就是说可以先统计全部的岛屿数量，然后去除在边缘的岛屿就是答案。 可以用DFS，向四个方向搜索来找到一个连通域（想到了图像处理里的找连通域，简化版）。但是不方便在DFS函数中去统计总数，所以想到了标记（覆盖 / 污染）。 DFS的作用为标记一整个连通域为1. 那么只要先把边缘的连通域都标记为1，之后剩下的连通域每标记一个，就cnt++就行。 代码class Solution &#123; public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y)&#123; int m &#x3D; grid.size(), n &#x3D; grid[0].size(); if(x &lt; 0 || x &gt;&#x3D; m || y &lt; 0 || y &gt;&#x3D; n) return; if(grid[x][y]) return; grid[x][y] &#x3D; 2; dfs(grid, x, y + 1); dfs(grid, x + 1, y); dfs(grid, x, y - 1); dfs(grid, x - 1, y); &#125; int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m &#x3D; grid.size(), n &#x3D; grid[0].size(); for(int i &#x3D; 0; i &lt; m; ++i)&#123; dfs(grid, i, 0); dfs(grid, i, n - 1); &#125; for(int i &#x3D; 0; i &lt; n; ++i)&#123; dfs(grid, 0, i); dfs(grid, m - 1, i); &#125; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; m; ++i)&#123; for(int j &#x3D; 0; j &lt; n; ++j)&#123; if(!grid[i][j])&#123; cnt++; dfs(grid, i, j); &#125; &#125; &#125; return cnt; &#125; &#125;; 2023.3.181616.分割两个字符串得到回文串题干给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。 当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。 注意， x + y 表示连接字符串 x 和 y 。 示例 示例 1: 输入：a &#x3D; &quot;x&quot;, b &#x3D; &quot;y&quot; 输出：true 示例 2: 输入：a &#x3D; &quot;abdef&quot;, b &#x3D; &quot;fecab&quot; 输出：true 解法基本思路： 双指针。 回文串其实是分为两部分对应的。第一部分是a的头和b的尾（可能为空），第二部分是ab任一的中部（也可能为空）。 那么只需要维护两个指针，分别从a头b尾向中间扫描对比，遇到不同的字符就跳转到第二部分，a和b中间部分（区间 [l, r]）若是回文串，则返回ture。否则再从b头a尾开始重复一遍。 写法可能有点问题，和一个题解思路相同但是速度慢了一些。 代码class Solution &#123; public: bool isPalindrome(string s, int l, int r)&#123; while(s[l] &#x3D;&#x3D; s[r])&#123; if(r - l &gt; 2)&#123; l++; r--; &#125; else return true; &#125; return false; &#125; bool checkPalindromeFormation(string a, string b) &#123; int l &#x3D; 0, r &#x3D; b.length() - 1; while(a[l] &#x3D;&#x3D; b[r])&#123; if(r - l &gt; 2)&#123; l++; r--; &#125; else return true; &#125; if(isPalindrome(a, l, r) || isPalindrome(b, l, r)) return true; l &#x3D; 0; r &#x3D; a.length() - 1; while(b[l] &#x3D;&#x3D; a[r])&#123; if(r - l &gt; 2)&#123; l++; r--; &#125; else return true; &#125; if(isPalindrome(b, l, r) || isPalindrome(a, l, r)) return true; return false; &#125; &#125;; 2032.至少在两个数组中出现的值题干给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 元素各不相同的 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。 示例 示例 1: 输入：nums1 &#x3D; [1,1,3,2], nums2 &#x3D; [2,3], nums3 &#x3D; [3] 输出：[3,2] 示例 2: 输入：nums1 &#x3D; [1,2,2], nums2 &#x3D; [4,3,3], nums3 &#x3D; [5] 输出：[] 解法基本思路：枚举。 代码class Solution &#123; public: vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) &#123; vector&lt;int&gt; res; int cnt1[101] &#x3D; &#123;0&#125;; int cnt2[101] &#x3D; &#123;0&#125;; int cnt3[101] &#x3D; &#123;0&#125;; for(auto x : nums1) cnt1[x] &#x3D; 1; for(auto x : nums2) cnt2[x] &#x3D; 1; for(auto x : nums3) cnt3[x] &#x3D; 1; for(int i &#x3D; 1; i &lt; 101; ++i)&#123; if(cnt1[i] + cnt2[i] + cnt3[i] &gt; 1) res.push_back(i); &#125; return res; &#125; &#125;; 1984.学生分数的最小差值题干给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。 从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。 返回可能的 最小差值 。 示例 示例 1: 输入：nums &#x3D; [90], k &#x3D; 1 输出：0 示例 2: 输入：nums &#x3D; [9,4,1,7], k &#x3D; 2 输出：2 解法基本思路： 先给nums排序，然后遍历找长度为k的子数组的最大差值中的最小值。 代码class Solution &#123; public: int minimumDifference(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int minSub &#x3D; nums.back() - nums[0]; for(int i &#x3D; 0; i &lt; nums.size() - k + 1; ++i) minSub &#x3D; min(minSub, nums[i + k - 1] - nums[i]); return minSub; &#125; &#125;; 2465.不同的平均值数目题干给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。 只要 nums 不是 空数组，你就重复执行以下步骤： 找到 nums 中的最小值，并删除它。 找到 nums 中的最大值，并删除它。 计算删除两数的平均值。 比方说，2 和 3 的平均值是 (2 + 3) / 2 = 2.5 。返回上述过程能得到的 不同 平均值的数目。 注意 ，如果最小值或者最大值有重复元素，可以删除任意一个。 示例 示例 1: 输入：nums &#x3D; [4,1,4,0,3,5] 输出：2 示例 2: 输入：nums &#x3D; [1,100] 输出：1 解法基本思路： 先给nums排序，然后双指针每次分别从头尾各取一个值计算平均值加入哈希表，最后返回哈希表中的键值对数。 代码class Solution &#123; public: int distinctAverages(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;double, int&gt; res; sort(nums.begin(), nums.end()); for(int i &#x3D; 0, j &#x3D; nums.size() - 1; i &lt; nums.size() &#x2F; 2; ++i, --j) res[(nums[i] + nums[j]) &#x2F; 2.0] &#x3D; 1; return res.size(); &#125; &#125;; 8.字符串转换整数题干实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例 示例 1: 输入：s &#x3D; &quot;42&quot; 输出：42 示例 2: 输入：s &#x3D; &quot; -42&quot; 输出：-42 示例 3： 输入：s &#x3D; &quot;4193 with words&quot; 输出：4193 解法基本思路： 简单的if判断。 结果可能超出int，因此用long long存储； 用sign为1 或 -1表示符号位方便计算； 宏定义 INT_MAX 和 INT_MIN 。 代码class Solution &#123; public: int myAtoi(string s) &#123; int sign &#x3D; 1; bool isPre &#x3D; true; long long res &#x3D; 0; for(auto x : s)&#123; if(isPre)&#123; if(x &#x3D;&#x3D; &#39; &#39;) continue; else if(x &#x3D;&#x3D; &#39;+&#39;) isPre &#x3D; false; else if(x &#x3D;&#x3D; &#39;-&#39;)&#123; isPre &#x3D; false; sign &#x3D; -1; &#125; else if(x &gt;&#x3D; &#39;0&#39; &amp;&amp; x &lt;&#x3D; &#39;9&#39;)&#123; isPre &#x3D; false; res &#x3D; x - &#39;0&#39;; &#125; else return 0; &#125; else&#123; if(x &gt;&#x3D; &#39;0&#39; &amp;&amp; x &lt;&#x3D; &#39;9&#39;)&#123; res &#x3D; res * 10 + x - &#39;0&#39;; if(res * sign &gt; INT_MAX) return INT_MAX; if(res * sign &lt; INT_MIN) return INT_MIN; &#125; else return res * sign; &#125; &#125; return res * sign; &#125; &#125;; 2023.3.212469.温度转换题干给你一个四舍五入到两位小数的非负浮点数 celsius 来表示温度，以 摄氏度（Celsius）为单位。 你需要将摄氏度转换为 开氏度（Kelvin）和 华氏度（Fahrenheit），并以数组 ans = [kelvin, fahrenheit] 的形式返回结果。 返回数组 ans 。与实际答案误差不超过 10e-5 的会视为正确答案。 开氏度 = 摄氏度 + 273.15 华氏度 = 摄氏度 * 1.80 + 32.00 示例 示例 1: 输入：celsius &#x3D; 36.50 输出：[309.65000,97.70000] 示例 2: 输入：celsius &#x3D; 122.11 输出：[395.26000,251.79800] 解法基本思路：。。。 代码class Solution &#123; public: vector&lt;double&gt; convertTemperature(double celsius) &#123; return &#123;celsius + 273.15, celsius * 1.8 + 32&#125;; &#125; &#125;; 2023.3.262395.和相等的子数组题干给你一个下标从 0 开始的整数数组 nums ，判断是否存在 两个 长度为 2 的子数组且它们的 和 相等。注意，这两个子数组起始位置的下标不相同 。如果这样的子数组存在，请返回 true，否则返回 false 。 子数组 是一个数组中一段连续非空的元素组成的序列。 示例 示例 1: 输入：nums &#x3D; [4,2,4] 输出：true 示例 2: 输入：nums &#x3D; [0,0,0] 输出：true 解法基本思路：哈希表的唯一性作为判断依据。 代码class Solution &#123; public: bool findSubarrays(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; sums; for(int i &#x3D; 1; i &lt; nums.size(); ++i)&#123; int sum &#x3D; nums[i-1] + nums[i]; if(sums.count(sum)) return true; sums.emplace(sum); &#125; return false; &#125; &#125;; 215.数组中的第K个最大元素题干给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 示例 1: 输入: [3,2,1,5,6,4], k &#x3D; 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6], k &#x3D; 4 输出: 4 解法基本思路： 要求时间复杂度为 O(n) 。快排和堆排的时间复杂度均为O(nlogn) ，本题实际用到了其中的一部分：快排的单趟排序和堆排的建堆，都是 O(n) 的时间复杂度。 以快排从大到小为例， 每次单趟排序把一个数放到正确的位置上。此时该位置左边的数都大于该值，右边都小于。该值所在位置和 k - 1 进行比较即可判断在该值的哪一边。然后缩小排序范围，仅在其中一边的范围内再次进行单趟排序，直至位置为 k - 1 为止。 代码class Solution &#123; public: int quickSingleSort(vector&lt;int&gt;&amp; nums, int l, int r)&#123; int pivot &#x3D; l; while(l &lt; r)&#123; while(l &lt; r &amp;&amp; nums[pivot] &gt;&#x3D; nums[r]) r--; while(l &lt; r &amp;&amp; nums[pivot] &lt;&#x3D; nums[l]) l++; if(l &lt; r) swap(nums[l], nums[r]); &#125; swap(nums[pivot], nums[l]); return l; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(1)&#123; int idx &#x3D; quickSingleSort(nums, l, r); if(idx &#x3D;&#x3D; k - 1) return nums[idx]; else if(idx &lt; k - 1) l &#x3D; idx + 1; else r &#x3D; idx - 1; &#125; &#125; &#125;; 1588.所有奇数长度子数组的和题干给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 进阶：你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？ 示例 示例 1: 输入：arr &#x3D; [1,4,2,5,3] 输出：58 示例 2: 输入：arr &#x3D; [1,2] 输出：3 解法基本思路：问题转化为数学题了属于是。 转化为：统计数组中每个元素出现在所有不同子数组中的次数。 可以发现，在一个奇数长度子数组中，除去一个指定元素外，剩余元素数量必然为偶数，那么可以得到：该元素左右两侧的元素数量的奇偶性相同。 以示例1为例，1的左侧数量0，右侧数量4，那么左侧奇数可选组合为0，偶数可选组合为1（只有一个0）；右侧奇数可选组合数为2（1、3），偶数可选3（0、2、4），那么1可能的所有组合数为：0 * 2 + 1 * 3 = 3。可以得到：元素总出现次数 = 左侧偶数选择 * 右侧偶数选择 + 左侧奇数选择 * 右侧奇数选择。 根据2中规律，只需for循环一次即可，也就是 O(n) 时间复杂度。 代码class Solution &#123; public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int n &#x3D; arr.size(); int res &#x3D; 0; for(int i &#x3D; 0; i &lt; n; ++i)&#123; int lEven &#x3D; i &#x2F; 2 + 1; int rEven &#x3D; (n - i - 1) &#x2F; 2 + 1; int lOdd &#x3D; (i + 1) &#x2F; 2; int rOdd &#x3D; (n - i) &#x2F; 2; int num &#x3D; lEven * rEven + lOdd * rOdd; res +&#x3D; num * arr[i]; &#125; return res; &#125; &#125;; 2023.3.271638.统计只差一个字符的子串数目题干给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。 比方说， “computer” and “computation” 只有一个字符不同： ‘e’/‘a’ ，所以这一对子字符串会给答案加 1 。 请你返回满足上述条件的不同子字符串对数目。 示例 示例 1: 输入：s &#x3D; &quot;aba&quot;, t &#x3D; &quot;baba&quot; 输出：6 示例 2: 输入：s &#x3D; &quot;ab&quot;, t &#x3D; &quot;bb&quot; 输出：3 解法基本思路：枚举。 双层for循环，枚举 s 和 t 中的每个 i 、j ，当这两个字符不同时，子串的其余字符均相同。 此时对这两个字符分别向左和右扩散比较，相同则计数（l、r）+1，不同则停止。可以发现这样的不同子串有 （1 + l）*（1 + r）个。对枚举的每个字符进行这样的操作，统计总子串数即可。 代码class Solution &#123; public: int countSubstrings(string s, string t) &#123; int m &#x3D; s.length(), n &#x3D; t.length(); int res &#x3D; 0; for(int i &#x3D; 0; i &lt; m; ++i)&#123; for(int j &#x3D; 0; j &lt; n; ++j)&#123; if(s[i] !&#x3D; t[j])&#123; int l &#x3D; 1, r &#x3D; 1; int p &#x3D; i - 1, q &#x3D; j - 1; while(p &gt;&#x3D; 0 &amp;&amp; q &gt;&#x3D; 0 &amp;&amp; s[p--] &#x3D;&#x3D; t[q--]) l++; p &#x3D; i + 1, q &#x3D; j + 1; while(p &lt; m &amp;&amp; q &lt; n &amp;&amp; s[p++] &#x3D;&#x3D; t[q++]) r++; res +&#x3D; l * r; &#125; &#125; &#125; return res; &#125; &#125;; 1438.绝对差不超过限制的最长连续子数组题干给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 。 示例 示例 1: 输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4 输出：2 示例 2: 输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0 输出：3 解法基本思路：双指针滑动窗口。 右指针r主动移动，左指针l被动移动（超出limit时）。需要一个数据结构来维护子数组有序（顺序容器中的map和set），由于存在重复数字，采用multiset。 注： begin() == rend() 均指向第一个元素，rbegin() 指向最后一个元素，end() 指向最后一个元素的下一个。 在multiset中，erase(elem) 擦除的是值等于elem的所有元素。 代码class Solution &#123; public: int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) &#123; multiset&lt;int&gt; sub; int l &#x3D; 0, r &#x3D; 0; int res &#x3D; 0; while(r &lt; nums.size())&#123; sub.emplace(nums[r]); while(*sub.rbegin() - *sub.begin() &gt; limit) sub.erase(sub.find(nums[l++])); res &#x3D; max(res, r - l + 1); r++; &#125; return res; &#125; &#125;; 424.替换后的最长重复字符题干给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。 在执行上述操作后，返回包含相同字母的最长子字符串的长度。 示例 示例 1: 输入：s &#x3D; &quot;ABAB&quot;, k &#x3D; 2 输出：4 示例 2: 输入：s &#x3D; &quot;AABABBA&quot;, k &#x3D; 1 输出：4 解法基本思路：双指针滑动窗口。 和上题（1438）思路类似的滑动窗口双指针，统计需要修改的字符数是否超过k。因为不确定最后的子串是哪个字符，因此先将所有不同字符加入集合，全循环一遍。 代码class Solution &#123; public: int characterReplacement(string s, int k) &#123; unordered_set&lt;char&gt; letter; for(char c : s) letter.emplace(c); int res &#x3D; 0; for(char c : letter)&#123; int l &#x3D; 0, r &#x3D; 0; int cnt &#x3D; 0; while(r &lt; s.length())&#123; if(s[r] !&#x3D; c) cnt++; while(cnt &gt; k)&#123; if(s[l] !&#x3D; c) cnt--; l++; &#125; res &#x3D; max(res, r - l + 1); r++; &#125; &#125; return res; &#125; &#125;; 2023.3.281092.最短公共超序列（未完结）题干给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。 （如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列） 示例 示例 1: 输入：str1 &#x3D; &quot;abac&quot;, str2 &#x3D; &quot;cab&quot; 输出：&quot;cabac&quot; 解释： str1 &#x3D; &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。 str2 &#x3D; &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。 最终我们给出的答案是满足上述属性的最短字符串。 解法基本思路：动态规划+双指针。 我们要找的目的字符串由三部分组成：两个字符串的最长公共子序列LCS + 第一个字符串除去LCS之后的序列 + 第二个字符串除去LCS之后的序列。同一个字符串中的字符的相对顺序不可改变，所以我们可以用字符串与LCS比较来确定字符的相对位置。 此题转化为了先求解LCS，再去构建目的字符串。 LCS部分： 定义 f [i] [j] ** 表示考虑 str1 的前 i 个字符、str2** 的前 j 的字符所形成的最长公共子序列长度。 可得状态转移方程： 在代码中为了计算方便，在两个string前添加一个空格，令下标从1开始。 构建目的字符串部分： 采用双指针 p、q 分别指向两个string的尾部。 当 p 或 q 走完（p == 0 || q == 0），直接将另一字符串剩余部分加入结果中。 当指向的两个字符相同时，该字符为LCS中的字符，加入结果，双指针同时自减。 根据第一部分得到的状态数组f，判断： **f [p] [q] == f [p - 1] [q] **时，str1[p] 加入结果，p–。 **f [p] [q] == f [p] [q - 1] **时，str2[q] 加入结果，q–。 最后，由于是从尾部向前构造，与实际答案相反，因此需要翻转。 代码class Solution &#123; public: string shortestCommonSupersequence(string str1, string str2) &#123; int m &#x3D; str1.length(), n &#x3D; str2.length(); str1 &#x3D; &quot; &quot; + str1; str2 &#x3D; &quot; &quot; + str2; vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1)); for(int i &#x3D; 1; i &lt;&#x3D; m; ++i)&#123; for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123; if(str1[i] &#x3D;&#x3D; str2[j]) f[i][j] &#x3D; f[i-1][j-1] + 1; else f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]); &#125; &#125; int p &#x3D; m, q &#x3D; n; string res; while(p &gt; 0 || q &gt; 0)&#123; if(p &#x3D;&#x3D; 0) res +&#x3D; str2[q--]; else if(q &#x3D;&#x3D; 0) res +&#x3D; str1[p--]; else&#123; if(str1[p] &#x3D;&#x3D; str2[q])&#123; res +&#x3D; str1[p--]; q--; &#125; else if(f[p][q] &#x3D;&#x3D; f[p-1][q]) res +&#x3D; str1[p--]; else res +&#x3D; str2[q--]; &#125; &#125; return string(res.rbegin(), res.rend()); &#125; &#125;; 1550.存在连续三个奇数的数组题干给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。 示例 示例 1: 输入：arr &#x3D; [2,6,4,1] 输出：false 示例 2: 输入：arr &#x3D; [1,2,34,3,4,5,7,23,12] 输出：true 解法基本思路：简单的if判断。 代码class Solution &#123; public: bool threeConsecutiveOdds(vector&lt;int&gt;&amp; arr) &#123; int limit &#x3D; 0; for(int num : arr)&#123; if(num % 2) limit++; else limit &#x3D; 0; if(limit &gt; 2) return true; &#125; return false; &#125; &#125;; 1991.找到数组的中间位置题干给你一个下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （也就是所有可能中间位置下标最小的一个）。 中间位置 middleIndex 是满足 nums[0] + nums[1] + … + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + … + nums[nums.length-1] 的数组下标。如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ，右边部分的和定义为 0 。 请你返回满足上述条件 最左边 的 middleIndex ，如果不存在这样的中间位置，请你返回 -1 。 示例 示例 1: 输入：nums &#x3D; [2,3,-1,8,4] 输出：3 示例 2: 输入：nums &#x3D; [1,-1,4] 输出：2 解法基本思路：前缀和。 在比较的过程中计算局部前缀和，调用库函数accumulate，相对节约时间和空间一点。 代码class Solution &#123; public: int findMiddleIndex(vector&lt;int&gt;&amp; nums) &#123; int sum &#x3D; accumulate(nums.begin(), nums.end(), 0); int preSum &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if(sum - nums[i] &#x3D;&#x3D; 2 * preSum) return i; preSum +&#x3D; nums[i]; &#125; return -1; &#125; &#125;; 2023.3.291641.统计字典序元音字符串的数目题干给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。 字符串 s 按字典序排列需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。 示例 示例 1: 输入：n &#x3D; 1 输出：5 示例 2: 输入：n &#x3D; 2 输出：15 解法基本思路：动态规划。 代码class Solution &#123; public: int countVowelStrings(int n) &#123; vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(5)); for(int i &#x3D; 0; i &lt; 5; ++i) f[0][i] &#x3D; 1; for(int i &#x3D; 1; i &lt; n; ++i) for(int j &#x3D; 0; j &lt; 5; ++j) for(int k &#x3D; 0; k &lt;&#x3D; j; ++k) f[i][j] +&#x3D; f[i - 1][k]; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; 5; ++i) res +&#x3D; f[n - 1][i]; return res; &#125; &#125;; 优化空间优化：二维数组 ——&gt; 一维数组。 因为最终要求的实际是 n - 1 处的前缀和，过程中的值并不需要，因此可以省略二维数组中的第一维（i），通过直接修改的的方式不断更新一维数组的值直到 n - 1。 class Solution &#123; public: int countVowelStrings(int n) &#123; int f[5] &#x3D; &#123;1, 1, 1, 1, 1&#125;; for(int i &#x3D; 0; i &lt; n - 1; ++i)&#123; int sum &#x3D; 0; for(int j &#x3D; 0; j &lt; 5; ++j)&#123; sum +&#x3D; f[j]; f[j] &#x3D; sum; &#125; &#125; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; 5; ++i) res +&#x3D; f[i]; return res; &#125; &#125;; 15.三数之和题干给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。 请你返回所有和为 0 且不重复的三元组。 注意，输出的顺序和三元组的顺序并不重要。 示例 示例 1: 输入：nums &#x3D; [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2: 输入：nums &#x3D; [0,1,1] 输出：[] 解法基本思路：排序 + 双指针。 考虑到和为0，三数之中必有正负或全0，且顺序不重要，那么先排个序肯定方便计算。 三个数，考虑用三个指针，其中for循环指针指定最左侧的数，从左往右遍历，那么剩下双指针只需要考虑该数右侧的部分即可（避免重复）。 双指针指向该数右侧子数组的两端，分别向中间移动判断。 需要注意的去重情况有： 当最左侧数大于0时，右侧两数也大于0，sum必大于0，直接结束循环。 当最左侧数 nums [i] == nums [i - 1] 时，此时双指针移动得到的三元组是一样的，跳过。 同上，当左指针 nums[l] == nums[l + 1] 时，三元组重复，跳过，l++。 当右指针 nums[r] == nums[r + 1] 时，三元组重复，跳过，r–。 去重后，根据sum的值大于或小于0判断移动右指针还是左指针。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int l &#x3D; i + 1, r &#x3D; nums.size() - 1; if(nums[i] &gt; 0) break; if(i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; while(l &lt; r)&#123; int sum &#x3D; nums[i] + nums[l] + nums[r]; if(sum &#x3D;&#x3D; 0)&#123; while(l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l + 1]) l++; while(l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r - 1]) r--; res.push_back(&#123;nums[i], nums[l++], nums[r--]&#125;); &#125; else if(sum &gt; 0) r--; else l++; &#125; &#125; return res; &#125; &#125;; 16.最接近的三数之和题干给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。 假定每组输入只存在恰好一个解。 示例 示例 1: 输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1 输出：2 示例 2: 输入：nums &#x3D; [0,0,0], target &#x3D; 1 输出：0 解法基本思路：排序 + 双指针。 同15题思路：排序肯定方便计算。三个数三个指针，其中for循环指针指定最左侧的数，从左往右遍历，那么剩下双指针只需要考虑该数右侧的部分即可（避免重复）。双指针指向该数右侧子数组的两端，分别向中间移动判断。 不需要去重，只用计算和与target比较，根据大小判断移动哪个指针； 维护结果变量res，如果 和与target的差值 小于 res与target的差值，就更新res为本次的和。 代码class Solution &#123; public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int res &#x3D; nums[0] + nums[1] + nums[2]; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int l &#x3D; i + 1, r &#x3D; nums.size() - 1; while(l &lt; r)&#123; int sum &#x3D; nums[i] + nums[l] + nums[r]; if(abs(target - sum) &lt; abs(target - res)) res &#x3D; sum; if(sum &gt; target) r--; else if(sum &lt; target) l++; else return res; &#125; &#125; return res; &#125; &#125;; 18.四数之和题干给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 示例 1: 输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2: 输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8 输出：[[2,2,2,2]] 解法基本思路：排序 + 双指针。 思路同15.三数之和，无非外面多加了层循环。 需要注意的去重情况有： 当最左侧数 nums [i] == nums [i - 1] 时，此时双指针移动得到的四元组是一样的，跳过。 当左侧第二个数 nums [j] == nums [j - 1] 时，此时双指针移动得到的四元组是一样的，跳过。 同上，当左指针 nums[l] == nums[l + 1] 时，四元组重复，跳过，l++。 当右指针 nums[r] == nums[r + 1] 时，四元组重复，跳过，r–。 去重后，根据sum的值大于或小于0判断移动右指针还是左指针。 注意越界问题，sum使用 long 记录。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if(i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; for(int j &#x3D; i + 1; j &lt; nums.size(); ++j)&#123; int l &#x3D; j + 1, r &#x3D; nums.size() - 1; if(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue; while(l &lt; r)&#123; long sum &#x3D; (long)nums[i] + nums[j] + nums[l] + nums[r]; if(sum &#x3D;&#x3D; target)&#123; while(l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l + 1]) l++; while(l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r - 1]) r--; res.push_back(&#123;nums[i], nums[j], nums[l++], nums[r--]&#125;); &#125; else if(sum &gt; target) r--; else l++; &#125; &#125; &#125; return res; &#125; &#125;; 2023.3.301637.两点之间不包含任何点的最宽垂直区域题干给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直区域 的宽度。垂直区域 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直区域 为宽度最大的一个垂直区域。 请注意，垂直区域 边上 的点 不在 区域内。 示例 示例 1: 输入：points &#x3D; [[8,7],[9,9],[7,4],[9,7]] 输出：1 示例 2: 输入：points &#x3D; [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]] 输出：3 解法基本思路：排序。 其实就是求所有点 x 坐标之间的最大差值。按第一位排序，然后求最大差值即可。 代码class Solution &#123; public: int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(points.begin(), points.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125;); int res &#x3D; 0; for(int i &#x3D; 1; i &lt; points.size(); ++i) res &#x3D; max(res, points[i][0] - points[i-1][0]); return res; &#125; &#125;; 优化 class Solution &#123; public: int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int n &#x3D; points.size(); vector&lt;int&gt; nums; for (auto&amp; p : points) &#123; nums.push_back(p[0]); &#125; const int inf &#x3D; 1 &lt;&lt; 30; int mi &#x3D; inf, mx &#x3D; -inf; for (int v : nums) &#123; mi &#x3D; min(mi, v); mx &#x3D; max(mx, v); &#125; int bucketSize &#x3D; max(1, (mx - mi) &#x2F; (n - 1)); int bucketCount &#x3D; (mx - mi) &#x2F; bucketSize + 1; vector&lt;pair&lt;int, int&gt;&gt; buckets(bucketCount, &#123;inf, -inf&#125;); for (int v : nums) &#123; int i &#x3D; (v - mi) &#x2F; bucketSize; buckets[i].first &#x3D; min(buckets[i].first, v); buckets[i].second &#x3D; max(buckets[i].second, v); &#125; int ans &#x3D; 0; int prev &#x3D; inf; for (auto [curmin, curmax] : buckets) &#123; if (curmin &gt; curmax) continue; ans &#x3D; max(ans, curmin - prev); prev &#x3D; curmax; &#125; return ans; &#125; &#125;; 704.二分查找题干给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9 输出: 4 示例 2: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出: -1 解法基本思路：二分查找。 当二分查找的双指针是闭区间 [ l, r ] 时while中判断是 &lt;= ；当左闭右开时，while中使用 &lt; ，**r = num.size()**。 代码class Solution &#123; public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if(nums[mid] &#x3D;&#x3D; target) return mid; else if(nums[mid] &gt; target) r &#x3D; mid - 1; else l &#x3D; mid + 1; &#125; return -1; &#125; &#125;; 35.搜索插入位置题干给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。 示例 示例 1: 输入: nums &#x3D; [1,3,5,6], target &#x3D; 5 输出: 2 示例 2: 输入: nums &#x3D; [1,3,5,6], target &#x3D; 7 输出: 4 解法基本思路：二分查找。 和704.二分查找一样，最后return的值改成双指针相遇的位置，就是应该插入的位置。 代码class Solution &#123; public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if(nums[mid] &lt; target) l &#x3D; mid + 1; else if(nums[mid] &gt; target) r &#x3D; mid - 1; else return mid; &#125; return l; &#125; &#125;; 34.在排序数组中查找元素的第一个和最后一个位置题干给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 **[-1, -1]**。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 示例 1: 输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8 输出：[3,4] 示例 2: 输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6 输出：[-1,-1] 解法基本思路：二分查找。 需要两次二分查找，找左边的就不断将右指针向左压缩，找到target后继续压缩直至左右指针重合，找右边同理。 代码class Solution &#123; public: int findRange(vector&lt;int&gt;&amp; nums, int target, bool isLeft)&#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; int res &#x3D; -1; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if(nums[mid] &lt; target) l &#x3D; mid + 1; else if(nums[mid] &gt; target) r &#x3D; mid - 1; else&#123; res &#x3D; mid; if(isLeft) r &#x3D; mid - 1; else l &#x3D; mid + 1; &#125; &#125; return res; &#125; vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; return &#123;findRange(nums, target, true), findRange(nums, target, false)&#125;; &#125; &#125;; 69.x的平方根 、367.有效的完全平方数题干给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 示例 示例 1: 输入：x &#x3D; 4 输出：2 示例 2: 输入：x &#x3D; 8 输出：2 解法基本思路：二分查找。 小数部分舍去，因此结果的平方必然 小于等于 x，因此在该处记录mid值，等到 l 和 r 重合后的mid即为结果。 注意用 long long 存储平方结果。 代码class Solution &#123; public: int mySqrt(int x) &#123; int l &#x3D; 0, r &#x3D; x, res; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if((long long)mid * mid &lt;&#x3D; x)&#123; l &#x3D; mid + 1; res &#x3D; mid; &#125; else r &#x3D; mid - 1; &#125; return res; &#125; &#125;; 27.移除元素、26.删除有序数组中的重复项解法基本思路：双指针。 利用了题意只打印前返回值个数的元素且不在意顺序，因此不需要真删，最后返回头指针的位置即可。 代码&#x2F;&#x2F; 27 class Solution &#123; public: &#x2F;&#x2F; 双指针 int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt;&#x3D; r)&#123; if(nums[l] &#x3D;&#x3D; val) nums[l] &#x3D; nums[r--]; else l++; &#125; return l; &#125; &#x2F;&#x2F; vector方法操作 int removeElement2(vector&lt;int&gt;&amp; nums, int val) &#123; if(nums.empty()) return 0; vector&lt;int&gt;::iterator it &#x3D; nums.begin(); while(it !&#x3D; nums.end())&#123; if(*it &#x3D;&#x3D; val) nums.erase(it); else it++; &#125; return nums.size(); &#125; &#125;; &#x2F;&#x2F; 26 class Solution &#123; public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int l &#x3D; 0; for(int r &#x3D; 0; r &lt; nums.size(); ++r)&#123; if(nums[l] !&#x3D; nums[r]) nums[++l] &#x3D; nums[r]; &#125; return l + 1; &#125; &#125;; 283.移动0解法基本思路：双指针。 确保 r指针 的左边均为非0值，l指针 用于遍历一遍，将所有非0值与 r 所在位置交换。 代码class Solution &#123; public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int r &#x3D; 0; for(int l &#x3D; 0; l &lt; nums.size(); ++l) if(nums[l]) swap(nums[l], nums[r++]); &#125; &#125;; 844.比较含退格的字符串解法基本思路：双指针。 慢指针维护真实的字符串，始终指向真实字符串的后一位（相当于真实字符串的长度）。 快指针用于遍历。非 ‘#’ 时，将快指针指向的字符赋给慢指针位置，慢指针右移；当为 ‘#’ 时，不赋值并慢指针后退。最后慢指针用于截取字符串（前slow个字符）。 代码class Solution &#123; public: string strBack(string s)&#123; int slow &#x3D; 0; for(int fast &#x3D; 0; fast &lt; s.length(); ++fast) if(s[fast] !&#x3D; &#39;#&#39;) s[slow++] &#x3D; s[fast]; else if(slow &gt; 0) slow--; return s.substr(0, slow); &#125; bool backspaceCompare(string s, string t) &#123; return strBack(s) &#x3D;&#x3D; strBack(t); &#125; &#125;; 977.有序数组的平方解法基本思路：双指针。 其实是三指针。 维护一个指针truth指向结果数组的尾部。另外双指针分别指向头尾，将两者中平方更大的数加入结果数组（同时truth指针左移，因为从大到小插入），指针向中间移动。 代码class Solution &#123; public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int truth &#x3D; nums.size() - 1; vector&lt;int&gt; res(nums.size()); for(int i &#x3D; 0, j &#x3D; nums.size() - 1; i &lt;&#x3D; j;)&#123; if(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123; res[truth--] &#x3D; nums[j] * nums[j]; j--; &#125; else&#123; res[truth--] &#x3D; nums[i] * nums[i]; i++; &#125; &#125; return res; &#125; &#125;; 2023.3.312367.算术三元组的数目解法基本思路：哈希表。 因为严格递增，可以用哈希表存储整个数组，然后遍历找另外两个值是否在哈希表中。 代码class Solution &#123; public: int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123; unordered_set&lt;int&gt; res; int cnt &#x3D; 0; for(int c : nums) res.emplace(c); for(int c : nums)&#123; if(res.find(c + diff) !&#x3D; res.end() &amp;&amp; res.find(c + diff * 2) !&#x3D; res.end()) cnt++; &#125; return cnt; &#125; &#125;; 209.长度最小的子数组题干给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 示例 1: 输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 示例 2: 输入：target &#x3D; 4, nums &#x3D; [1,4,4] 输出：1 解法基本思路：双指针、滑动窗口。 依旧是快慢指针，快指针完成一次数组遍历，并累加和至sum中。 每次累加后判断sum与target，若 ≥ ，则记录此时长度，同时慢指针移动，sum减去值，直至小于target。 代码class Solution &#123; public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int slow &#x3D; 0, fast &#x3D; 0; int res &#x3D; INT_MAX, sum &#x3D; 0; for(; fast &lt; nums.size(); ++fast)&#123; sum +&#x3D; nums[fast]; while(sum &gt;&#x3D; target)&#123; res &#x3D; min(res, fast - slow + 1); sum -&#x3D; nums[slow++]; &#125; &#125; return res &#x3D;&#x3D; INT_MAX ? 0 : res; &#125; &#125;; 904.水果成篮题干你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 示例 1: 输入：fruits &#x3D; [1,2,3,2,2] 输出：4 示例 2: 输入：fruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解法基本思路：双指针、滑动窗口、哈希表。 依旧是快慢指针，快指针完成一次数组遍历，用哈希表记录已采摘的每种水果的数量。 当种类数大于2时，将慢指针所指种类的水果数量减1（减至0时将该种类从哈希表中删除），并移动慢指针。 更新每次移动快指针后的最大长度。 代码class Solution &#123; public: int totalFruit(vector&lt;int&gt;&amp; fruits) &#123; unordered_map&lt;int, int&gt; types; int res &#x3D; 0; int slow &#x3D; 0, fast &#x3D; 0; for(;fast &lt; fruits.size(); ++fast)&#123; types[fruits[fast]]++; while(types.size() &gt; 2)&#123; int ex &#x3D; fruits[slow++]; if(--types[ex] &#x3D;&#x3D; 0) types.erase(ex); &#125; res &#x3D; max(res, fast - slow + 1); &#125; return res; &#125; &#125;; 76.最小覆盖子串题干给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 示例 1: 输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot; 输出：&quot;BANC&quot; 示例 2: 输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot; 输出：&quot;a&quot; 解法基本思路：双指针、滑动窗口、哈希表。 典型的滑动窗口思路，窗口扩展时寻找可行解，窗口收缩时优化可行解。 先用哈希表存储 t 串中每种字符的数量，设立双指针。 不断右移快指针，增大滑动窗口，直至包含 t 中所有字符。 右移慢指针，去除不需要的元素，直至遇到一个必须包含的字符，记录最小长度和起始位置。 慢指针右移一位，此时条件不满足，从步骤2继续执行，直至快指针超出 s 的范围。 以上思路遇到的问题： 如何判断窗口内包含了 t 中所有字符？ 步骤1的哈希表，每当快指针增加一个所需字符时，哈希表对应数量减1，慢指针加1。存在负数的情况，因为当添加某个字符数量超过需求时，若窗口压缩时去除了多余的该字符依旧是符合要求的。当哈希表中所有键对应的值均≤ 0 时，表示包含了全部所需字符。 每次判断都要遍历哈希表？ 维护一个变量 needChar 表示所需元素的总数，窗口每次添加所需字符时，哈希表中对应的值和 needChar 同时减1。当 needChar == 0 时，已达标可以进行缩减了。 没有符合要求的子串和全部字符才符合要求这两种情况的区分？ 一开始 minLen 初值设置为 s.length()，发现无法区分这两种情况。修改为 INT_MAX 即可，return时根据 minLen 是否被修改过作出选择。 关于unordered_map 有个注意的点是，当执行 sub[c] &gt; 0 时若map中不存在键c，会生成一个 **sub[c] = 0 **的键值对，因此我通过 在该判断前先判断是否存在该键 来解决，不知是否有更简便的方法TODO。 代码class Solution &#123; public: string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; sub; for(char c: t) sub[c]++; int slow &#x3D; 0, fast &#x3D; 0; int minLen &#x3D; INT_MAX, minLoc &#x3D; 0, needChar &#x3D; t.length(); for(; fast &lt; s.length(); ++fast)&#123; int c &#x3D; s[fast]; if(sub.count(c) &amp;&amp; sub[c]-- &gt; 0) needChar--; if(needChar &#x3D;&#x3D; 0)&#123; while(sub.count(s[slow]) &#x3D;&#x3D; 0 || sub[s[slow]] &lt; 0)&#123; if(sub.count(s[slow])) sub[s[slow]]++; slow++; &#125; if(minLen &gt; fast - slow + 1)&#123; minLen &#x3D; fast - slow + 1; minLoc &#x3D; slow; &#125; sub[s[slow++]]++; needChar++; &#125; &#125; return minLen &gt; s.length() ? &quot;&quot; : s.substr(minLoc, minLen); &#125; &#125;; 59.螺旋矩阵 Ⅱ题干给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 示例 1: 输入：n &#x3D; 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2: 输入：n &#x3D; 1 输出：[[1]] 解法基本思路：模拟过程。 因为是正方形，因此会规律很多。每轮循环计算一圈边界，无论横纵都遵循左闭右开的走法，如下图，即可避免重复。 若 n 为奇数，最中间的值需要单独补充。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n)); int loop &#x3D; n &#x2F; 2; int sx &#x3D; 0, sy &#x3D; 0; int num &#x3D; 0, cnt &#x3D; 1; int i, j; while(loop--)&#123; for(j &#x3D; sy; j &lt; n - cnt; ++j) mat[sy][j] &#x3D; ++num; for(i &#x3D; sx; i &lt; n - cnt; ++i) mat[i][j] &#x3D; ++num; for(; j &gt; sy; --j) mat[i][j] &#x3D; ++num; for(; i &gt; sx; --i) mat[i][j] &#x3D; ++num; sx++; sy++; cnt++; &#125; if(n % 2) mat[n &#x2F; 2][n &#x2F; 2] &#x3D; n * n; return mat; &#125; &#125;;","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"},{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于js跨源请求的解决方案","slug":"关于js跨源请求的解决方案","date":"2022-04-17T15:32:36.000Z","updated":"2022-12-07T15:49:33.233Z","comments":true,"path":"原理/关于js跨源请求的解决方案/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Ejs%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"前言起因是出现了卜算子统计的访问量和访客数一致的bug，于是想换个访客信息统计的API，于是换了百度统计。 一切都很顺利，直至在用XMLHttpRequest向api发送请求的时候，出现了跨源请求问题。 请求是正常发出去的，数据也正常从服务端返回了，但是被浏览器拦截了。 跨源请求相关知识一个 URL 大概包含的部分：scheme://host:port/path?#hash 比如一个 URL 为 http://www.xxx.com:8888/school/student.html，","text":"前言起因是出现了卜算子统计的访问量和访客数一致的bug，于是想换个访客信息统计的API，于是换了百度统计。 一切都很顺利，直至在用XMLHttpRequest向api发送请求的时候，出现了跨源请求问题。 请求是正常发出去的，数据也正常从服务端返回了，但是被浏览器拦截了。 跨源请求相关知识一个 URL 大概包含的部分：scheme://host:port/path?#hash 比如一个 URL 为 http://www.xxx.com:8888/school/student.html， 那么 http 就是 scheme，www.xxx.com 就是 host，8888 就是 port 什么是同源？如果两个 URL 的 scheme://host:port 内容一样，就叫同源。 什么是跨源访问？如果两个 URL 的 scheme、host、port 有任何一个不一样，就不同源。这时候，一个 URL 的脚本从另一个 URL 获取数据，就叫跨源访问。 针对跨源访问，W3C 提出了一个方案叫做 CORS（Cross-Origin Resource Sharing），只有现代浏览器支持此方案。 CORS 的工作方式 浏览器中当前页面的脚本请求另外一个服务器的数据时，浏览器在发起连接的数据报头中附加一个 Origin 报头，表明当前页面的来源，然后向另外一个服务器发起连接 目标服务器接收到浏览器的连接请求后，如果接受请求，则在响应数据流的报头中添加一个Access-Control-Allow-Origin 报头，并给这个报头赋一个值，值为浏览器发过来的 Origin 报头值，或者为 “*”（表示此服务器运行任何跨站请求）。如果不接受请求，则不包含 Access-Control-Allow-Origin 报头。 浏览器接受到返回来的数据包进行解析，如果不包含 Access-Control-Allow-Origin 报头，则丢弃响应数据包。 问题的解决Debug（失败）直接请求后端，可以正常获取到数据。 查看百度统计API允许的域名，是 “ * ” 。 但一旦通过前端js发送请求，就会失败。 怀疑是百度后端的问题=_= 解决上网又搜了一轮，看到有博客说，百度api允许用jsonp动态创建script，通过callback获取数据 于是修改代码如下： 用script的src属性去访问数据端口，然后通过callback回调函数传值回来，这样可以解决问题，但是只能用于GET。 时隔了大半年，才想起来这儿还有个坑。。。","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://www.hanhan0223.cn/tags/javascript/"}]},{"title":"基于STM32F103的实时操作系统","slug":"基于STM32F103的实时操作系统","date":"2022-04-08T05:41:30.000Z","updated":"2022-11-07T10:39:23.771Z","comments":true,"path":"原理/基于STM32F103的实时操作系统/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%9F%BA%E4%BA%8ESTM32F103%E7%9A%84%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"仿照U-COS II写的一个抢占式实时操作系统——Easy OS。目前只实现了任务的简单调度，功能比较单一，后续会不断完善更新。 底层架构STM32硬件支持Cortex-M3内核提供了以下异常： 编号大于15的均属于外部中断。 异常是可以打断正常执行流的事件，这是实现实时操作系统的关键，本文中将会使用——PendSV可悬起异常和SysTick滴答定时器。","text":"仿照U-COS II写的一个抢占式实时操作系统——Easy OS。目前只实现了任务的简单调度，功能比较单一，后续会不断完善更新。 底层架构STM32硬件支持Cortex-M3内核提供了以下异常： 编号大于15的均属于外部中断。 异常是可以打断正常执行流的事件，这是实现实时操作系统的关键，本文中将会使用——PendSV可悬起异常和SysTick滴答定时器。 SysTick系统滴答定时器SysTick是一个24位的系统节拍定时器，具有自动重载和溢出中断功能，所有基于Cortex_M3处理器的微控制器都可以由这个定时器获得一定的时间间隔。 SysTick在实现本文的实时操作系统中起到了非常关键的作用——节拍 / 时间片，它保证了操作系统运行的基准单位。同时，通过将其优先级设置为最高，就可以实现在一个时间片用完之后，稳定触发该异常，从而实现时间片的轮转。 通过以下函数初始化SysTick计数器，设置两次中断之间的时间。 #define TICKS_PER_SEC 1000 SysTick_Config(SystemCoreClock &#x2F; TICKS_PER_SEC); 重装载值 = SysTick 时钟频率(Hz) x 想要的定时时间（S） 例如，SystemCoreClock为72MHZ，想要实现1ms进一次中断，就只需要将TICKS_PER_SEC设置为1000，也就是 x 0.001即可。 PendSV可悬起异常基于其可悬起的特点，将其配置为最低优先级，OS就可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。 悬起 PendSV 的方法是：手工往 NVIC的 PendSV悬起寄存器中写 1。悬起后，如果优先级不够高，则将缓期等待执行。 PendSV的典型使用场合是在上下文切换时（在不同任务之间切换）。 例如，一个系统中有两个就绪的任务，上下文切换被触发的场合可以是：1、执行一个系统调用2、系统滴答定时器（SYSTICK）中断（本文中使用） 为什么PendSV好用，如下： 假设有这么一个系统，里面有两个就绪的任务，并且通过SysTick异常启动上下文切换。但若在产生 SysTick 异常时正在响应一个中断，则 SysTick异常会抢占其 ISR。在这种情况下，OS是不能执行上下文切换的，否则将使中断请求被打断延迟，而且在真实系统中延迟时间还往往不可预知，这是不应该被允许的。 在Cortex-M3中，如果 OS 在某中断活跃时尝试切入线程模式，将触犯用法fault异常。 PendSV完美解决了这个问题。PendSV异常会自动延迟上下文切换的请求，直到其它的 ISR都完成了处理后才放行。为实现这个机制，需要把 PendSV编程为最低优先级的异常。 如果 OS检测到某 IRQ正在活动并且被 SysTick抢占，它将悬起一个 PendSV异常，以便缓期执行 上下文切换。 上图很好的展示了本文实现的操作系统的任务切换的时序实现。 汇编实现使用SysTick异常实现时间片轮转，并触发PendSV中断。 在PendSV中实现上下文的切换。 SysTick汇编函数NVIC_INT_CTRL EQU 0xE000ED04 ; 中断控制寄存器 NVIC_PENDSVSET EQU 0x10000000 ; 触发软中断，通过给NVIC_INT_CTRL第28bit写1 CPU_TASK_SCHEDULE ;OS context switch（任务切换） PUSH &#123;R4, R5&#125; LDR R4, &#x3D;NVIC_INT_CTRL ; R4 &#x3D; NVIC_INT_CTRL（触发 PendSV 异常） LDR R5, &#x3D;NVIC_PENDSVSET ; R5 &#x3D; NVIC_PENDSVSET ; *R4 &#x3D; R5（向 NVIC_INT_CTRL 写入NVIC_PENDSVSET 触发 PendSV 中断） STR R5, [R4] POP &#123;R4, R5&#125; BX LR ; return; align 4 ; 4字节对齐，写于文件末 end 其中中断控制寄存器片段 PendSV汇编函数PendSV_Handler ; 保存现场 CPSID I ; 关中断，任务切换期间要关中断 ; 异常处理或进程切换时，需要保存程序状态寄存器的值，可用该指令读出程序状态寄存器的值，然后保存。 MRS R0, PSP CBZ R0, PendSV_Handler_NoSave ; PSP指针为0就跳转，只在第一次运行时跳转 ;---------------------------------------------------------------------------------------- SUB R0, R0, #0x20 ; R0 &#x3D; R0 - 0x20; STM R0, &#123;R4-R11&#125; ; 将R4-R11的值暂存起来 ;---------------------------------------------------------------------------------- LDR R1, &#x3D;TCB_CurP ; LDR伪指令获取 TCB_CurP-&gt;StackTop 指针 ; R1 &#x3D; *R1; 获取 TCB_CurP-&gt;StackTop 指向的值（这个值是一个地址） LDR R1, [R1] ; *R1 &#x3D; R0; 将现场信息（R4-R11）存入 TCB_CurP-&gt;StackTop 指向的地址所在的内存 STR R0, [R1] ; 由于汇编语言是顺序执行，所以执行完上面那条语句后，在没有跳转等指令的情况下，会接下去执行。 PendSV_Handler_NoSave ; 恢复现场 LDR R0, &#x3D;TCB_CurP ; R0 获取 TCB_CurP-&gt;StackTop 指针 LDR R1, &#x3D;TCB_NextP ; R1 获取 TCB_NextP-&gt;StackTop 指针 LDR R2, [R1] ; R2 获取 TCB_NextP-&gt;StackTop 指向的值 STR R2, [R0] ; 将 TCB_CurP-&gt;StackTop 指向这个值 ; 将 以这个值为地址的内存里的值（也就是之前保存的现场信息）存入R0，开始恢复 LDR R0, [R2] LDM R0, &#123;R4-R11&#125; ; 恢复R4-R11的值到 R0 中 MSR PSP, R0 ; PSP 指向R0（恢复现场） ORR LR, LR, #0x04 ; LR&#x3D;LR|0x04; EXC_RETURN, 第2位赋1表示返回后使用PSP CPSIE I ; 开中断 BX LR ; return; 关于LR寄存器，在出入ISR的时候，LR的值将得到重新的诠释，这种特殊的值称为EXC_RETURN。 EXC_RETURN的二进制值除了最低4位外全为1，而其最低4位则有另外的含义，如下： 关于上下文切换，一个形象的GIF如下所示： 上下文切换，其实就是保存和恢复上图中这些CM3内核寄存器中的值。 寄存器 用途 R0~R3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。 R4~R11 存放函数的局部变量。若被调用函数使用了这些寄存器，返回之前必须恢复这些寄存器的值。 R12 内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。 在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 R13 栈指针 sp。它不能用于任何其它用途。sp 中的值在退出被调用函数时必须与进入时的值相同。 R14 链接寄存器 lr。若保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复。 R15 程序计数器 PC。它不能用于任何其它用途。 CM3处理异常/中断时，硬件会把R0-R3，R12，LR，PC, XPSR自动压栈。然后由PendSV的中断服务程序(后面简称PendSV ISR)手动把R4-R11寄存器压入任务栈中，这样就完成了任务上下文的保存。 恢复下一个任务的寄存器(包含PC)，当恢复PC时就能跳转到任务被打断的地方继续执行。恢复过程正好与保存过程相反，PendSV ISR会先手动地将R4-R11恢复到CM3中，然后在PendSV ISR退出时，CM3硬件会自动将R0-R3，R12，LR, XPSR恢复到CM3的寄存器中。 中断控制的汇编函数CPU_SR_Save ; 关中断（进入临界区） MRS R0, PRIMASK ; 读取 PRIMASK 到 R0,R0 为返回值 ; PRIMASK寄存器只有一位，当这个位置 1 时 就关掉所有可屏蔽的异常 CPSID I ; PRIMASK&#x3D;1,关中断(NMI和硬件FAULT可以响应) BX LR ; 返回 CPU_SR_Restore ;开中断（退出临界区） MSR PRIMASK, R0 ;读取 R0 到 PRIMASK 中,R0 为参数 BX LR c语言定义宏实现调用 u32 CPU_SR; &#x2F;&#x2F; 保存PRIMASK的值(中断开关的状态控制) #define ENTER_CRITICAL() &#123; CPU_SR &#x3D; CPU_SR_Save(); &#125; &#x2F;&#x2F; 关中断 #define EXIT_CRITICAL() &#123; CPU_SR_Restore(CPU_SR); &#125; 初始化的汇编函数NVIC_INT_CTRL EQU 0xE000ED04 ; 中断控制寄存器的地址 NVIC_PENDSVSET EQU 0x10000000 ; 触发软中断，通过给NVIC_INT_CTRL第28bit写1 NVIC_SYSPRI14 EQU 0xE000ED22 ; 系统优先级寄存器(14) 对应 PendSV NVIC_PENDSV_PRI EQU 0xFF ; PendSV 中断优先级为最低(0xFF) CPU_Start CPSID I LDR R0, &#x3D;NVIC_SYSPRI14 ; 初始化PendSV，并设置中断优先级为255，最低 LDR R1, &#x3D;NVIC_PENDSV_PRI STRB R1, [R0] LDR R4, &#x3D;0x0 ; 初始化PSP为0 MSR PSP, R4 LDR R4, &#x3D;NVIC_INT_CTRL ; 先触发一次PendSV异常 LDR R5, &#x3D;NVIC_PENDSVSET STR R5, [R4] CPSIE I 系统结构任务控制块TCB包含三个部分，任务栈顶指针、延时时长以及任务状态 typedef unsigned int STACK_TypeDef; typedef unsigned int PRIO_TypeDef; typedef unsigned int TICKS_TypeDef; typedef void (*TASK_TypeDef)(void); &#x2F;&#x2F; 任务状态 typedef enum TASK_STATUS &#123; TASK_READY &#x3D; 0, &#x2F;&#x2F;就绪 TASK_DELAY &#x3D; 1, &#x2F;&#x2F;延时等待 TASK_SUSPEND &#x3D; 2, &#x2F;&#x2F;挂起 &#125; TASK_STATUS; &#x2F;&#x2F; TCB控制块 typedef struct &#123; STACK_TypeDef *StackTop; &#x2F;&#x2F;任务栈顶指针 TICKS_TypeDef Delay; &#x2F;&#x2F;任务延时时钟 TASK_STATUS State; &#x2F;&#x2F;任务状态 &#125; TASK_TCB, *TCB_Ptr; #define TASKS_NUM 5 &#x2F;&#x2F; 设定运行任务的数量,不包含空闲任务 extern TASK_TCB TCB[TASKS_NUM + 1]; &#x2F;&#x2F; 定义任务控制块TCB数组 extern PRIO_TypeDef PrioCur; &#x2F;&#x2F; 当前任务的优先级 extern PRIO_TypeDef PrioNext; &#x2F;&#x2F; 下一个运行任务的优先级 extern TCB_Ptr TCB_CurP; &#x2F;&#x2F; 当前任务的TCB指针 extern TCB_Ptr TCB_NextP; &#x2F;&#x2F; 下一个运行任务的TCB指针 就绪任务列表extern u32 TaskReadyTable; &#x2F;&#x2F; 就绪任务列表 维护一个任务就绪列表，通过对位进行操作来保存就绪的任务。 每个任务都有相对应的、不同的优先级，以此区分任务。 &#x2F;&#x2F; prio: 任务优先级 #define SetTaskReady(prio) ( TaskReadyTable |&#x3D; 0x01&lt;&lt;prio ) #define DelTaskReady(Prio) ( TaskReadyTable &amp;&#x3D; ~(0x01&lt;&lt;Prio) ) 通过一个简单的for循环获取当前最高优先级的任务（实际就是获取优先级数） u32 i; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); 相应优先级的任务，存于 TCB[i] 中。 任务的创建&#x2F;* --- 创建任务 - *p_Task: 任务函数地址 - *p_Stack：任务栈顶指针 - prio: 任务优先级 *&#x2F; void STM32_TaskCreate(TASK_TypeDef task, STACK_TypeDef *stack, PRIO_TypeDef prio) &#123; STACK_TypeDef *p_stk; p_stk &#x3D; stack; &#x2F;&#x2F;加载栈顶指针 p_stk &#x3D; (STACK_TypeDef *)((STACK_TypeDef)(p_stk) &amp; 0xFFFFFFF8u); *(--p_stk) &#x3D; (STACK_TypeDef)0x01000000uL; &#x2F;&#x2F; xPSR *(--p_stk) &#x3D; (STACK_TypeDef)task; &#x2F;&#x2F; PC指针 &#x2F;&#x2F; 无意义，只为了--p_stk *(--p_stk) &#x3D; (STACK_TypeDef)0x14141414uL; &#x2F;&#x2F; R14 (LR) *(--p_stk) &#x3D; (STACK_TypeDef)0x12121212uL; &#x2F;&#x2F; R12 *(--p_stk) &#x3D; (STACK_TypeDef)0x03030303uL; &#x2F;&#x2F; R3 *(--p_stk) &#x3D; (STACK_TypeDef)0x02020202uL; &#x2F;&#x2F; R2 *(--p_stk) &#x3D; (STACK_TypeDef)0x01010101uL; &#x2F;&#x2F; R1 *(--p_stk) &#x3D; (STACK_TypeDef)0x00000000u; &#x2F;&#x2F; R0 *(--p_stk) &#x3D; (STACK_TypeDef)0x11111111uL; &#x2F;&#x2F; R11 *(--p_stk) &#x3D; (STACK_TypeDef)0x10101010uL; &#x2F;&#x2F; R10 *(--p_stk) &#x3D; (STACK_TypeDef)0x09090909uL; &#x2F;&#x2F; R9 *(--p_stk) &#x3D; (STACK_TypeDef)0x08080808uL; &#x2F;&#x2F; R8 *(--p_stk) &#x3D; (STACK_TypeDef)0x07070707uL; &#x2F;&#x2F; R7 *(--p_stk) &#x3D; (STACK_TypeDef)0x06060606uL; &#x2F;&#x2F; R6 *(--p_stk) &#x3D; (STACK_TypeDef)0x05050505uL; &#x2F;&#x2F; R5 *(--p_stk) &#x3D; (STACK_TypeDef)0x04040404uL; &#x2F;&#x2F; R4 TCB[prio].StackTop &#x3D; p_stk; TCB[prio].Delay &#x3D; 0; TCB[prio].State &#x3D; TASK_READY; &#125; 部分函数接口任务的调度&#x2F;* --- 任务调度 *&#x2F; void SysTaskSchedule(void) &#123; u32 i; if(SCHEDULE &#x3D;&#x3D; 1) &#123; for(i &#x3D; 0; i &lt; TASKS_NUM; i++) &#x2F;&#x2F; 刷新各任务剩余延时时间 &#123; if(TCB[i].State &#x3D;&#x3D; TASK_DELAY ) &#123; TCB[i].Delay--; if(TCB[i].Delay &#x3D;&#x3D; 0) &#x2F;&#x2F; 必须是由定时器减时的才行 &#123; TCB[PrioCur].State &#x3D; TASK_READY; SetTaskReady(i); &#x2F;&#x2F;修改任务就绪表 使任务可以重新运行 &#125; &#125; &#125; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 任务的创建&#x2F;* --- 创建任务 - *p_Task: 任务函数地址 - *p_Stack：任务栈顶指针 - prio: 任务优先级 *&#x2F; void TaskCreate(void (*p_Task)(void), STACK_TypeDef *p_Stack, PRIO_TypeDef prio) &#123; if(prio &lt;&#x3D; TASKS_NUM) &#123; STM32_TaskCreate(p_Task, p_Stack, prio); SetTaskReady(prio); &#125; &#125; 任务的挂起void TaskSuspend(PRIO_TypeDef prio) &#123; u32 i; ENTER_CRITICAL(); TCB[prio].Delay &#x3D; 0; TCB[prio].State &#x3D; TASK_SUSPEND; DelTaskReady(prio); &#x2F;&#x2F; 从任务就绪表上去除标志位 EXIT_CRITICAL(); if(PrioCur &#x3D;&#x3D; prio) &#x2F;&#x2F; 当要挂起的任务为当前任务 重新调度 &#123; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 任务的恢复void TaskResume(PRIO_TypeDef prio) &#123; u32 i; ENTER_CRITICAL(); SetTaskReady(prio); &#x2F;&#x2F; 从任务就绪表上重置标志位 TCB[prio].Delay &#x3D; 0; &#x2F;&#x2F; 将时间计时设为0,延时到 TCB[prio].State &#x3D; TASK_READY; &#x2F;&#x2F; s EXIT_CRITICAL(); if(PrioCur &#x3D;&#x3D; prio) &#x2F;&#x2F; 不执行？ &#123; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 任务的延时&#x2F;* --- 任务延时 - ticks: 延时的节拍数 *&#x2F; void SysTimeDelay(TICKS_TypeDef ticks) &#123; u32 i &#x3D; 0; if (ticks) &#123; ENTER_CRITICAL(); DelTaskReady(PrioCur); TCB[PrioCur].Delay &#x3D; ticks; &#x2F;&#x2F; 设置任务延时节拍数 TCB[PrioCur].State &#x3D; TASK_DELAY; EXIT_CRITICAL(); for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 实例应用测试例程单任务计数#define TASK_2_STK_SIZE 128 static STACK_TypeDef TASK_2_STK[TASK_2_STK_SIZE]; u32 task2count &#x3D; 0; void task_2() &#123; while(1) &#123; task2count++; display(task2count); &#x2F;&#x2F; 数码管显示函数 if (task2count &gt;&#x3D; 9999) &#123; task2count &#x3D; 0; &#125; SysTimeDelay(1); &#125; &#125; int main() &#123; delay_init(72); LED_Configuration(); DigitalTube_Configuration(); LCD_Configuration(); Sys_Init(); &#x2F;&#x2F;TaskCreate(task_1, &amp;TASK_1_STK[TASK_1_STK_SIZE-1], TASK1_PRIO); TaskCreate(task_2, &amp;TASK_2_STK[TASK_2_STK_SIZE-1], TASK2_PRIO); Sys_Start(); return 0; &#125;","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.hanhan0223.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://www.hanhan0223.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"opencv图像算法","slug":"opencv图像算法","date":"2021-12-23T11:36:24.000Z","updated":"2023-03-21T02:41:50.856Z","comments":true,"path":"原理/opencv图像算法/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/","excerpt":"图像低通滤波邻域滤波","text":"图像低通滤波邻域滤波 中值滤波图像的中值滤波是一种非线性图像处理方法,是统计排序滤波器的一种典型应用。中值滤波是通过对邻域内像素按灰度排序的结果决定中心像素的灰度。具体的操作过程如下：用一个奇数点的移动窗口，将窗口中心点的值用窗口内各点的中值代替。假设窗口内有5个点，其值为1,2,3,4和5，那么此窗口内各点的中值即为3，也就是用3来代替中心点的像素值。 中值滤波对于滤除脉冲干扰及图像扫描噪声最为有效，还可以克服线性滤波器（如领域简单平滑滤波）带来的图像细节模糊。 数字图像存在冗余信息，具体分为六大冗余：空间冗余、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余。其中第一个空间冗余就可以很好的解释中值滤波的作用。空间冗余指的是：图像内部相邻像素之间存在较强的相关性而造成的冗余。简单来说就是，同一景物表面上采样点的颜色之间通常存在着空间相关性，相邻各点的取值往往相近或者相同，这就是空间冗余。而脉冲噪声通常是在一个邻域内有一个点或多个点的灰度值很高或很低，这就与周围像素存在较大差异，因此中值滤波能很好的去除这种噪声。 需要注意的是，中值滤波的窗口形状和尺寸对滤波效果影响很大，不同的图像内容和不同的应用要求，往往采用不同的窗口形状和尺寸。常用的中值滤波窗口有线状、方形、圆形、十字形以及圆环形等等。窗口尺寸一般先用3x3,再取5x5逐渐增大，直到滤波效果满意为止。就一般经验来讲，对于有缓变的较长轮廓线物体的图像，采用方形或圆形窗口为宜。对于包含有尖顶物体的图像，用十字形窗口，而窗口大小则以不超过图像中最小有效物体的尺寸为宜。如果图像中点、线、尖角细节较多（感觉就是邻域灰度值变化较大），则不宜采用中值滤波。 自适应中值滤波上面提到常规的中值滤波器，在噪声的密度不是很大的情况下，效果不错。但是密度较高时，常规的中值滤波的效果就不是很好了。有一个选择就是增大滤波器的窗口大小，这虽然在一定程度上能解决上述的问题，但是会给图像造成较大的模糊。 常规的中值滤波器的窗口尺寸是固定大小不变的，就不能同时兼顾去噪和保护图像的细节。这时就要寻求一种改变，根据预先设定好的条件，在滤波的过程中，动态的改变滤波器的窗口尺寸大小，这就是自适应中值滤波器 。在滤波的过程中，自适应中值滤波器会根据预先设定好的条件，改变滤波窗口的尺寸大小，同时还会根据一定的条件判断当前像素是不是噪声，如果是则用邻域中值替换掉当前像素；不是，则不作改变。 自适应中值滤波器有三个目的： 滤除椒盐噪声 平滑其他非脉冲噪声 尽可能的保护图像中细节信息，避免图像边缘的细化或者粗化。 实现过程： 对于每一个像素点的处理，使用一个while循环。在while循环中： 首先，在当前像素点下根据当前尺寸窗口的大小获取数据存入数组； 其次，获取窗口内像素的最大最小值和中值； 再，得到A1（中值 - 最小值），A2（中值 - 最大值）。 预先定义好以下符号： Sxy： 滤波器的作用区域，滤波器窗口所覆盖的区域；Zmin： Sxy中最小的灰度值；Zmax： Sxy中最大的灰度值；Zmed： Sxy中所有灰度值的中值；Zxy： 表示图像中对应像素点的灰度值；Smax： Sxy所允许的最大窗口尺寸； 自适应中值滤波器分为以下两个过程，A和B： A: A1 = Zmed - Zmin A2 = Zmed - Zmax 如果A1&gt;0 且 A2&lt;0，则跳转到B 否则，增大窗口的尺寸 如果增大后的尺寸 ≤ Smax，则重复A 否则，直接输出Zmed B： B1 = Zxy - Zmin B2 = Zxy - Zmax 如果B1&gt;0 且 B2&lt;0，则输出Zxy 否则输出Zmed 实现原理： A步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果Zmed=Zmin或者Zmed=Zmax，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点； 接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，原理同上，因为如果Zxy=Zmin或者Zxy=Zmax，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。 均值滤波一种特殊形式的邻域滤波（邻域算子都是1/M*N）。 图片中一个方块区域（一般为3*3）内，中心点的像素为全部点像素值的平均值。均值滤波就是对于整张图片进行以上操作。 缺陷：均值滤波本身存在着固有的缺陷，即它不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，不能很好地去除噪声点。特别是椒盐噪声 算术均值滤波这是最简单的均值滤波器，可以去除均匀噪声和高斯噪声，但会对图像造成一定程度的模糊。 算术均值滤波器就是简单的计算窗口区域的像素均值，然后将均值赋值给窗口中心点处的像素： 其中，g(s,t)表示原始图像，f(x,y)表示均值滤波后得到的图像，Sxy表示滤波器窗口。 基于上述公式，可以很容易的得到的算术均值滤波器的窗口模板，下面以3×3为例： 几何均值滤波滤波后图像的像素由模板窗口内像素的乘积的1/mn幂给出。 和算术均值滤波器相比，几何均值滤波器能够更好的取出高斯噪声，并且能够更多的保留图像的边缘信息。但其对0值是非常敏感的，在滤波器的窗口内只要有一个像素的灰度值为0，就会造成滤波器的输出结果为0。 公式如下： 谐波均值滤波对盐粒噪声（白噪声）效果较好，不适用于胡椒噪声；比较适合处理高斯噪声。 公式如下： 逆谐波均值滤波 其中Q称为滤波器的阶数，该滤波器可以用来消除椒盐噪声。但是不能同时处理盐粒噪声和胡椒噪声，当Q为正时，可以消除胡椒噪声；当Q为负时，消除盐粒噪声。当Q=0时，该滤波器退化为算术均值滤波器；Q=-1时，退化为谐波均值滤波器。 修正后的alpha均值滤波假设在Sxy模板领域内，去掉g(s,t)中最高灰度值的d/2和最低灰度值的d/2个像素。用gr(s,t)来代替剩余的mn-d个像素。由剩余像素点的平均值形成的滤波器称为修正后的alpha均值滤波器： 其中d取0~m*n-1之间的任意数。 当d=0时，退变为算术均值滤波； 当d=(m*n-1)，退变为中值滤波器； d取其他值时，该滤波器适用于包括多种噪声的情况，如高斯噪声和椒盐噪声混合的情况。 基于局部均方差的图像去噪设x(i,j)为模板中心的灰度值，那么在（2n+1）x（2m+1）的窗口内，其局部均值可以表示为 其局部均方差可以表示为： 加性去噪后的结果为，其中 σ 为输入值： 方差在统计学中表示的是与中心偏离的程度，用来衡量数据的波动性大小。对于图像而言，当上述局部方差比较小，意味着图像中该局部区域属于灰度平坦区，各个像素灰度值相差不大；相反，当上述局部方差比较大的时候，意味着图像中该局部区域属于边缘或者是其他高频部分区域，各个像素的灰度值相差比较大。 当局部属于平坦区时，方差很小，趋近于0。该点滤波之后的像素就是该点的局部平均值。由于该局部各点像素的灰度值相差不大，其局部平均值也与各个像素的灰度值相差不大；当局部属于边缘区域时，方差较大，相对于用户输入的参数可以基本忽略不计，其图像去噪之后，就等于输入的图像灰度值。 这种方法在一定程度上对边缘具有保留，能够保留边缘的同时，进行去噪。 本质上是一个动态均值滤波的过程，在边缘处（即方差较大区域）尽量保留原值，而在平坦处尽量执行均值滤波。 最值滤波最大值和最小值滤波最值滤波就是取kernal排序后得最大值或最小值来取代中心像素作为输出。 分为最大值滤波和最小值滤波，分别相当于形态学操作的膨胀和腐蚀。 中点滤波在上述最值滤波的基础上，取最大值和最小值的平均值作为中心像素点的输出。 双边滤波双边滤波是一种非线性滤波器，它可以达到保持边缘、降噪平滑的效果。和其他滤波原理一样，双边滤波也是采用加权平均的方法，用周边像素亮度值的加权平均代表某个像素的强度，所用的加权平均基于高斯分布[1]。最重要的是，双边滤波的权重不仅考虑了像素的欧氏距离（如普通的高斯低通滤波，只考虑了位置对中心像素的影响），还考虑了像素范围域中的辐射差异（例如卷积核中像素与中心像素之间相似程度、颜色强度，深度距离等），在计算中心像素的时候同时考虑这两个权重。它是一种可以保边去噪的滤波器。之所以可以达到此去噪效果，是因为滤波器是由两个函数构成。一个函数是由几何空间距离决定滤波器系数。另一个由像素差值决定滤波器系数。 双边滤波的核函数是空间域核与像素范围域核的综合结果：在图像的平坦区域，像素值变化很小，对应的像素范围域权重接近于1，此时空间域权重起主要作用，相当于进行高斯模糊；在图像的边缘区域，像素值变化很大，像素范围域权重变大，从而保持了边缘的信息。 空间域公式如下： 像素范围域（颜色域）公式如下： 他们的乘积即为双边滤波的权重： 根据权重计算最后目标点的像素值： 高斯滤波高斯滤波器是一种线性滤波器，能够有效的抑制噪声，平滑图像。其作用原理和均值滤波器类似，都是取滤波器窗口内的像素的均值作为输出。其窗口模板的系数和均值滤波器不同，均值滤波器的模板系数都是相同的为1；而高斯滤波器的模板系数，则随着距离模板中心的增大而系数减小。所以，高斯滤波器相比于均值滤波器对图像个模糊程度较小。 高斯滤波器 二维高斯函数如下： 其中e前的参数可以忽略，因为这只是个表示幅值的常数，并不影响相互之间的比例关系，并且最终都要进行归一化，所以实际只需要计算后半部分即可。该参数仅影响图像的亮度而不影响模糊。 例如，要产生一个3×3的高斯滤波器模板，以模板的中心位置为坐标原点进行取样。模板在各个位置的坐标，如下所示（x轴水平向右，y轴竖直向下） 对于窗口模板的大小为 (2k+1)×(2k+1)，模板中各个元素值的计算公式如下： 转化为代码： for(int i &#x3D; 0; i &lt; m; ++i) for(int j &#x3D; 0; j &lt; n; ++j) double g &#x3D; exp(((i - m&#x2F;2)*(i - m&#x2F;2) + (j - n&#x2F;2)*(j - n&#x2F;2)) * -1.0 &#x2F; (2 * sigma * sigma)); 再对求出来的每个g进行归一化（因为求的是加权平均，要保证窗口模板各元素和为1） kernel &#x3D; g &#x2F; sum; 关于高斯分布的标准差σ的选值，代表着数据的离散程度。如果σ较小，那么生成的模板的中心系数较大，而周围的系数较小，这样对图像的平滑效果就不是很明显；反之，σ较大，则生成的模板的各个系数相差就不是很大，比较类似均值模板，对图像的平滑效果比较明显。 高斯分布的概率分布密度图如下： 横轴表示可能得取值x，竖轴表示概率分布密度F(x)，那么不难理解这样一个曲线与x轴围成的图形面积为1。σσ（标准差）决定了这个图形的宽度，可以得出这样的结论：σσ越大，则图形越宽，尖峰越小，图形较为平缓；σσ越小，则图形越窄，越集中，中间部分也就越尖，图形变化比较剧烈。这其实很好理解，如果sigma也就是标准差越大，则表示该密度分布一定比较分散，由于面积为1，于是尖峰部分减小，宽度越宽（分布越分散）；同理，当σσ越小时，说明密度分布较为集中，于是尖峰越尖，宽度越窄！ 以上求出来的就是模板系数，滤波操作就是分别以图像的每个像素点为中心再根据模板系数求出加权平均像素，作为该点的滤波后像素。比如3x3模板，对选中像素点的外一圈共九个像素点，分别乘以对应位置的模板系数再求和，即为选中点的像素。 高通滤波（边缘检测）如何识别图像边缘？图里面有一条线,左边很亮,右边很暗,那人眼就很容易识别这条线作为边缘.也就是像素的灰度值快速变化的地方，那么如何来数学化这个问题，就是梯度。 要获得一幅图像的梯度，就需要在图像的每个像素点计算对x和对y的偏导数，也就是 **gx = f(x+1,y) - f(x,y) 和 gy = f(x,y+1) - f(x,y)**，转化为模板也就是，水平和垂直的 [-1,1] 模板。 而当我们对对角线方向的边缘感兴趣时，就产生了Roberts算子，原理就是把一维的模板斜过来。 Roberts算子中2x2的模板在概念上很简单，但在实际应用中，它对于用关于中心点对称的模板来计算边缘方向不是很有用。相对来说3x3考虑了中心点对端数据的性质，并携带了关于边缘方向的更多信息。于是就产生了 Prewitt算子。它的3x3模板考虑到了水平/垂直和斜边的信息，相比于Roberts更准确。 在Prewitt的基础上，在卷积核的中心位置处使用2代替1，能较为有效的平滑图像，抑制噪声，这就是Sobel算子。而针对不同的需求，可以设计不同的卷积核，例如需要对对角线方向有更好的响应，那么可以将2设置在卷积核的两个对角。 Roberts算子Roberts算子是一种最简单的算子，利用局部差分寻找边缘的算子。采用对角线相邻两像素之差近似梯度幅值检测边缘。检测垂直边缘的效果比斜向边缘要好，定位精度高，对噪声比较敏感，无法抑制噪声的影响。 Roberts边缘算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差。从图像处理的实际效果来看，边缘定位较准，对噪声敏感。模板如下： 对于输入图像f(x,y),使用Roberts算子后输出的目标图像为g(x,y),则 Sobel算子（一阶导数法）基于寻找梯度强度 对于f(t),其导数f’(t)反映了每一处的变化趋势.在变化最快的位置其导数最大. sobel算子的思路就是模拟求一阶导数. sobel算子是一个离散差分算子.它计算图像像素点亮度值的近似梯度。图像是二维的,即沿着宽度/高度两个方向。我们使用两个卷积核对原图像进行处理: 水平方向： 原始像素灰度值–&gt;(右边像素值-左边像素值),反映了水平方向的变化情况. 垂直方向同理： 这样就得到了两个新的矩阵,分别反映了每一点像素在水平方向上的亮度变化情况和在垂直方向上的亮度变换情况。 综合考虑这两个方向的变化，使用反映某个像素的梯度变化情况. 有时候为了简单起见,也直接用绝对值相加替代： 在opencv中也可以通过以下卷积核（Scharr）大像素的变化情况： 与滤波一样，对每个像素点的处理为：要操作像素点对应于Gx，Gy矩阵中心，对该像素点和周边9个像素点乘以相应系数求和，得到一个方向上的处理结果。完整的Sobel算子则需要对两个方向上的处理结果求和，得到完整的新像素值。 opencv的Sobel函数 1.采用了可分离的卷积核 图A是可分离的；它可以表示为两个一维卷积（B和C）；D是一个不可分割内核的例子。可分离的内核是可以被认为是两个一维的内核，首先与x内核进行卷积然后与y内核进行卷积来应用。这种分解的好处是内核卷积的计算成本大约是图像面积乘以内核区域。这意味着用n×n内核卷积区域A的图像需要时间与An2成正比，同时n×1内核与图像卷积一次，然后与1×n内核卷积占用与An + An = 2An成比例。 随着图像尺寸与卷积核尺寸的增大，用分离的卷积核依次对图像进行卷积操作，可以有效地提高运算速度。因此，在二维图像处理中，经常将一个可分离卷积核分解为一维水平核 kernalX 和一维垂直核 kernalY 的乘积。 秩为 1 的矩阵可以分解为一个列向量与一个行向量的乘积，因此秩为 1 的卷积核是可分离卷积核。 可分离卷积核 w 与图像 f 的卷积（same 卷积），等于先用 f 与 w1 卷积，再用 w2 对结果进行卷积： 2.行、列卷积核的生成 阅读源码： for( int k &#x3D; 0; k &lt; 2; k++ ) &#x2F;&#x2F; 分别生成行、列 &#123; Mat* kernel &#x3D; k &#x3D;&#x3D; 0 ? &amp;kx : &amp;ky; int order &#x3D; k &#x3D;&#x3D; 0 ? dx : dy; int ksize &#x3D; k &#x3D;&#x3D; 0 ? ksizeX : ksizeY; &#x2F;&#x2F; ksize都是相同的 CV_Assert( ksize &gt; order ); if( ksize &#x3D;&#x3D; 1 ) kerI[0] &#x3D; 1; else if( ksize &#x3D;&#x3D; 3 ) &#x2F;&#x2F; 卷积核大小设为3时使用固定值 &#123; if( order &#x3D;&#x3D; 0 ) kerI[0] &#x3D; 1, kerI[1] &#x3D; 2, kerI[2] &#x3D; 1; else if( order &#x3D;&#x3D; 1 ) kerI[0] &#x3D; -1, kerI[1] &#x3D; 0, kerI[2] &#x3D; 1; else kerI[0] &#x3D; 1, kerI[1] &#x3D; -2, kerI[2] &#x3D; 1; &#125; else &#x2F;&#x2F; 大于3时进行计算，巧妙 &#123; int oldval, newval; kerI[0] &#x3D; 1; for( i &#x3D; 0; i &lt; ksize; i++ ) kerI[i+1] &#x3D; 0; for( i &#x3D; 0; i &lt; ksize - order - 1; i++ ) &#123; oldval &#x3D; kerI[0]; for( j &#x3D; 1; j &lt;&#x3D; ksize; j++ ) &#123; newval &#x3D; kerI[j]+kerI[j-1]; kerI[j-1] &#x3D; oldval; oldval &#x3D; newval; &#125; &#125; for( i &#x3D; 0; i &lt; order; i++ ) &#123; oldval &#x3D; -kerI[0]; for( j &#x3D; 1; j &lt;&#x3D; ksize; j++ ) &#123; newval &#x3D; kerI[j-1] - kerI[j]; kerI[j-1] &#x3D; oldval; oldval &#x3D; newval; &#125; &#125; &#x2F;&#x2F; 以上计算，假设ksize&#x3D;5，order&#x3D;1，可得一维核：[-1，-2，0，2，1] &#125; &#125; 设ksize=3，dx=1，dy=0，带入运算可得： 卷积核的效果和二维的是相同的。 3.可分离卷积的计算 我们首先在5x5图像上用3x1卷积。这样的话卷积核就能横向扫描5个位置，纵向扫描3个位置，如上图所标的点所示。 现在得到的是一个3x5的矩阵，这个矩阵经过1x3卷积核的卷积操作——从横向上的 3 个位置以及纵向上的 3个位置来扫描该矩阵。 Prewitt算子Prewitt算子的原理和sobel是一模一样的，唯一的区别就是卷积核存在差异： Sobel相较于Prewitt，在中心权值上使用2来代替1，这样可以较好的抑制噪声。 Laplacian算子（二阶微分法）基于过零点检测 对Sobel算子中的一阶导数函数再次求导可得： 二阶差分公式： Laplace算子的差分形式： 分别对Laplace算子x,y两个方向的二阶导数进行差分就得到了离散函数的Laplace算子。在一个二维函数f(x,y)中，x,y两个方向的二阶差分分别为： 于是可得Laplace算子的差分形式为： 写作滤波模板的形式如下： 注意该模板的特点，在上下左右四个90度的方向上结果相同，也就是说在90度方向上无方向性。为了让该mask在45度的方向上也具有该性质，可以对该模板进行扩展定义为： 注：定义数字形式的拉普拉斯要求系数之和必为0。 之后的操作与其他的空间滤波操作相同。将模板在原图上逐行移动，然后模板中各系数与其重合的像素相乘后求和，赋给与mask中心重合的像素。 拉普拉斯对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用于边的检测，只起辅助的角色，检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。 Canny算子图像边缘信息主要集中在高频段，通常说图像锐化或检测边缘，实质就是高频滤波。 微分运算是求信号的变化率，具有加强高频分量的作用。在空域运算中来说，对图像的锐化就是计算微分。由于数字图像的离散信号，微分运算就变成计算差分或梯度。 因此canny算子求边缘点分为以下四步： 1.使用高斯滤波器平滑图像 卷积的核心意义就是获取原始图像中像模板特征的性质。 2.用一阶偏导有限差分（Sobel）计算梯度值和方向 经典Canny算法用了四个梯度算子来分别计算水平，垂直和对角线方向的梯度。但是通常都不用四个梯度算子来分别计算四个方向。常用的边缘差分算子（如Rober，Prewitt，Sobel）计算水平和垂直方向的差分Gx和Gy。这样就可以如下计算梯度模和方向： 梯度角度θ范围从弧度-π到π，然后把它近似到四个方向，分别代表水平，垂直和两个对角线方向（0°,45°,90°,135°）。 由于图像的坐标系是以左上角为原点向右和下延展，因此根据像素点计算出的角度值必然在一、四象限。那么可以分别以 ± π / 8（水平） 、π / 8 ~ 3π / 8（45°）、- π / 8 ~ - 3π / 8（-45°）、一四象限剩余部分（垂直）来分割，落在每个区域的梯度角给一个特定值，代表四个方向之一。 3.对梯度幅值进行非极大值抑制 意义就是寻找像素点局部最大值。 沿着梯度方向，比较它前面和后面的梯度值即可（对于左右边界，则比较附近的两个值）。如果是最大值就保留，否则置为0。 如上图，c点为需要判断的点，按照2中划分的四个区域，可以看到每个区域包含了八邻域中的两个点，通过判断c点的角度值所在区域，与该区域包含的那两个点进行比较即可。 若想提高精度，如上右图：c的角度值在π / 8 ~ 3π / 8（45°）区域，不比较g1和g4，而是比较dTmp1和dTmp2，由于这两个点都是浮点坐标，因此需要采用线性插值方法来计算这两个点的幅值。 通过角度θ可以计算出dTmp1在g1和g2之间的比例，设dis(dTmp1，g2) = w，则dis(g1，dTmp1) = 1 - w。所以dTmp1的幅值为：w * g2 + （1 - w）* g1。同理可得dTmp2的幅值。将c的幅值与这两个浮点坐标的幅值进行比较进行非极大值抑制。 4.用双阈值算法检测、连接边缘 一般的边缘检测算法用一个阈值来滤除噪声或颜色变化引起的小的梯度值，而保留大的梯度值。Canny算法应用双阈值，即一个高阈值和一个低阈值来区分边缘像素。如果边缘像素点梯度值大于高阈值，则被认为是强边缘点。如果边缘梯度值小于高阈值，大于低阈值，则标记为弱边缘点。小于低阈值的点则被抑制掉。 一般来说，建议高低阈值的比率为2：1或3：1 4.5.滞后边界跟踪 强边缘点可以认为是真的边缘。弱边缘点则可能是真的边缘，也可能是噪声或颜色变化引起的。为得到精确的结果，后者引起的弱边缘点应该去掉。通常认为真实边缘引起的弱边缘点和强边缘点是连通的，而又噪声引起的弱边缘点则不会。所谓的滞后边界跟踪算法检查一个弱边缘点的8连通领域像素，只要有强边缘点存在，那么这个弱边缘点被认为是真是边缘保留下来。 只需对所有被标记过的弱边缘点的八邻域进行遍历，若邻域中存在强边缘点，则保留；否则抑制掉。 方向算子方向算子利用一组模板分别计算在不同方向上的差分值，取其中最大的值作为边缘强度，而将与之对应的方向作为边缘方向。 Kirsch算子类似于Sobel算子，也利用图像中某点的梯度幅值作为像素的灰度值，Sobel算子计算出某点两个方向的梯度值，Gx、Gy；但Kirsch算子 利用8个卷积模板计算出了某点8个方向的梯度幅值和方向，并以最大的卷积值作为该点的灰度值。 对每个像素点都用 这8个模板进行进行卷积（注意，每个卷积值都应取绝对值），求出该点的最大卷积值。 Nevitia算子 形态学膨胀膨胀的操作本质上来说和滤波是一样的，采用滑动窗口（为像素点指定邻域）的模式去遍历整张图，来调整像素值。 调整方式为：选取像素点及其指定邻域中的极大值，作为该像素点的新值。 膨胀同sobel一样存在方向性，可以通过改变邻域的形状，来控制膨胀的方向。 腐蚀腐蚀与膨胀的原理相同。 调整方式为：选取像素点及其指定邻域中的极小值，作为该像素点的新值。 膨胀和腐蚀是针对图像中的高亮部分的变化来说的。 膨胀和腐蚀常用于二值图的操作。 连通域连通域一般是指图像中具有相同像素值且位置相邻的前景像素点组成的图像区域。连通区域分析是指将图像中的各个连通区域找出并标记。通常连通区域分析处理的对象是一张二值化后的图像。 从连通域的定义可以知道，一个连通区域是由具有相同像素值的相邻像素组成像素集合，因此，我们就可以通过这两个条件在图像中寻找连通区域，对于找到的每个连通区域，我们赋予其一个唯一的标识（Label），以区别其他连通区域。 最常见的有两种算法：Two-pass法和Seed-Filling种子填充法。 种子填充法本质上就是DFS，维护一个队列或者堆栈。 按照从上到下、从左到右的顺序遍历图像，对于找到的每一个为指定前景色且未被标记的像素点重复执行以下步骤： 1.标记该像素点，并将该点坐标入队。 2.开启DFS，while（队列非空）。 3.while内部，获取队首的坐标，并将其出队。搜寻该点的4邻域或8邻域（注意边界限幅），若存在为指定前景色且未被标记的像素点，标记并入队。 3.5 while中可维护变量用于统计该连通域的像素点数（面积）和x、y坐标的总和（求均值作为连通域的中心）。 代码实现 由于实际应用需求，写的是纯C的版本，没有队列向量，malloc了两个二维数组用来存取连通域信息。 unsigned char* flag &#x3D; (unsigned char*)malloc(sizeof(unsigned char) * width * height); memset(flag, 0, sizeof(unsigned char) * width * height); int** con &#x3D; (int**)malloc(sizeof(int*) * conNums); int** conInfo &#x3D; (int**)malloc(sizeof(int*) * conNums); for (int i &#x3D; 0; i &lt; conNums; i++) &#123; &#x2F;&#x2F; x、y点坐标 con[i] &#x3D; (int*)malloc(width * height * sizeof(int) * 2); &#x2F;&#x2F; 区域信息 0-Area、12-Center、310-Rect conInfo[i] &#x3D; (int*)malloc(sizeof(int) * 11); &#125; int conIdx &#x3D; -1; &#x2F;&#x2F; 标记连通域的序号 int ptr &#x3D; 0; &#x2F;&#x2F; 通过自加模拟出队 int growNum &#x3D; 0; &#x2F;&#x2F; 模拟队列是否为空 int sumx &#x3D; 0, sumy &#x3D; 0, curx &#x3D; 0, cury &#x3D; 0; for (int i &#x3D; 0; i &lt; height; i++) &#123; for (int j &#x3D; 0; j &lt; width; j++) &#123; if (srcImage[i * width + j] &#x3D;&#x3D; 255 &amp;&amp; flag[i * width + j] &#x3D;&#x3D; 0 &amp;&amp; conIdx &lt; conNums - 1) &#123; &#x2F;&#x2F; 初始化本次连通域信息 conIdx++; growNum &#x3D; 1; ptr &#x3D; 0; sumx &#x3D; 0; sumy &#x3D; 0; flag[i * width + j] &#x3D; conIdx + 1; con[conIdx][0] &#x3D; j; con[conIdx][1] &#x3D; i; &#x2F;&#x2F; 开找 while (growNum &gt; 0) &#123; curx &#x3D; con[conIdx][ptr++]; cury &#x3D; con[conIdx][ptr++]; sumx +&#x3D; curx; sumy +&#x3D; cury; growNum--; if (cury &gt; 0 &amp;&amp; srcImage[(cury - 1) * width + curx] &#x3D;&#x3D; 255 &amp;&amp; flag[(cury - 1) * width + curx] &#x3D;&#x3D; 0) &#123; flag[(cury - 1) * width + curx] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury - 1; growNum++; &#125; if (cury &lt; height - 1 &amp;&amp; srcImage[(cury + 1) * width + curx] &#x3D;&#x3D; 255 &amp;&amp; flag[(cury + 1) * width + curx] &#x3D;&#x3D; 0) &#123; flag[(cury + 1) * width + curx] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury + 1; growNum++; &#125; if (curx &gt; 0 &amp;&amp; srcImage[cury * width + curx - 1] &#x3D;&#x3D; 255 &amp;&amp; flag[cury * width + curx - 1] &#x3D;&#x3D; 0) &#123; flag[cury * width + curx - 1] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx - 1; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury; growNum++; &#125; if (curx &lt; width - 1 &amp;&amp; srcImage[cury * width + curx + 1] &#x3D;&#x3D; 255 &amp;&amp; flag[cury * width + curx + 1] &#x3D;&#x3D; 0) &#123; flag[cury * width + curx + 1] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx + 1; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury; growNum++; &#125; &#125; &#x2F;&#x2F; 计算连通域的面积、中心点和最小外接矩 conInfo[conIdx][0] &#x3D; ptr &#x2F; 2; if (conInfo[conIdx][0] &lt; minConArea) &#123; &#x2F;&#x2F; 小于指定面积的连通域舍弃 conIdx--; &#125; else &#123; conInfo[conIdx][1] &#x3D; sumx * 2 &#x2F; ptr; conInfo[conIdx][2] &#x3D; sumy * 2 &#x2F; ptr; int miny &#x3D; 9999, maxy &#x3D; 0, minx &#x3D; 9999, maxx &#x3D; 0; for (int y &#x3D; 0; y &lt; conInfo[conIdx][0]; y++) &#123; if (con[conIdx][y * 2 + 1] &lt; miny) miny &#x3D; con[conIdx][y * 2 + 1]; if (con[conIdx][y * 2 + 1] &gt; maxy) maxy &#x3D; con[conIdx][y * 2 + 1]; if (con[conIdx][y * 2] &lt; minx) minx &#x3D; con[conIdx][y * 2]; if (con[conIdx][y * 2] &gt; maxx) maxx &#x3D; con[conIdx][y * 2]; &#125; conInfo[conIdx][3] &#x3D; minx; conInfo[conIdx][4] &#x3D; maxy; conInfo[conIdx][5] &#x3D; minx; conInfo[conIdx][6] &#x3D; miny; conInfo[conIdx][7] &#x3D; maxx; conInfo[conIdx][8] &#x3D; miny; conInfo[conIdx][9] &#x3D; maxx; conInfo[conIdx][10] &#x3D; maxy; &#125; &#125; &#125; &#125; Two-pass法由于业务环境为纯c，写Two-pass较为麻烦而且效率并不比种子填充高，因此这里只是贴了网上的代码。 1.生成等价对 要找一张二维图像中的连通域，很容易想到可以一行一行先把子区域找出来，然后再拼合成一个完整的连通域，因为从每一行找连通域是一件很简单的事。这个过程中需要记录每一个子区域，为了满足定位要求，并且节省内存，我们需要记录子区域所在的行号、区域开始和结束的位置以及子区域的总数。需要注意的就是子区域开始位置和结束位置在行首和行末的情况要单独拿出来考虑。 代码实现 &#x2F;&#x2F; 查找每一行的子区域 &#x2F;&#x2F; numberOfArea：子区域总数 stArea：子区域开始位置 enArea：子区域结束位置 rowArea：子区域所在行号 void searchArea(const Mat src, int &amp;numberOfArea, vector&lt;int&gt; &amp;stArea, vector&lt;int&gt; &amp;enArea, vector&lt;int&gt; &amp;rowArea) &#123; for (int row &#x3D; 0; row &lt; src.rows; row++) &#123; &#x2F;&#x2F; 行指针 const uchar *rowData &#x3D; src.ptr&lt;uchar&gt;(row); &#x2F;&#x2F; 判断行首是否是子区域的开始点 if (rowData[0] &#x3D;&#x3D; 255)&#123; numberOfArea++; stArea.push_back(0); &#125; for (int col &#x3D; 1; col &lt; src.cols; col++) &#123; &#x2F;&#x2F; 子区域开始位置的判断：前像素为背景，当前像素是前景 if (rowData[col - 1] &#x3D;&#x3D; 0 &amp;&amp; rowData[col] &#x3D;&#x3D; 255) &#123; numberOfArea++; stArea.push_back(col); &#x2F;&#x2F; 子区域结束位置的判断：前像素是前景，当前像素是背景 &#125;else if (rowData[col - 1] &#x3D;&#x3D; 255 &amp;&amp; rowData[col] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 更新结束位置vector、行号vector enArea.push_back(col - 1); rowArea.push_back(row); &#125; &#125; &#x2F;&#x2F; 结束位置在行末 if (rowData[src.cols - 1] &#x3D;&#x3D; 255) &#123; enArea.push_back(src.cols - 1); rowArea.push_back(row); &#125; &#125; &#125; 另外一个比较棘手的问题，如何给这些子区域标号，使得同一个连通域有相同的标签值。我们给单独每一行的子区域标号区分是很容易的事， 关键是处理相邻行间的子区域关系（怎么判别两个子区域是连通的）。 主要思路：以四连通为例，在上图我们可以看出BE是属于同一个连通域，判断的依据是E的开始位置小于B的结束位置，并且E的结束地址大于B的开始地址；同理可以判断出EC属于同一个连通域，CF属于同一个连通域，因此可以推知BECF都属于同一个连通域。 迭代策略：寻找E的相连区域时，对前一行的ABCD进行迭代，找到相连的有B和C，而D的开始地址已经大于了E的结束地址，此时就可以提前break掉，避免不必要的迭代操作；接下来迭代F的时候，由于有E留下来的基础，因此对上一行的迭代可以直接从C开始。另外，当前行之前的一行如果不存在子区域的话，那么当前行的所有子区域都可以直接赋新的标签，而不需要迭代上一行。 标签策略：以上图为例，遍历第一行，A、B、C、D会分别得到标签1、2、3、4。到了第二行，检测到E与B相连，之前E的标签还是初始值0，因此给E赋上B的标签2；之后再次检测到C和E相连，由于E已经有了标签2，而C的标签为3，则保持E和C标签不变，将（2,3）作为等价对进行保存。同理，检测到F和C相连，且F标签还是初始值0，则为F标上3。如此对所有的子区域进行标号，最终可以得到一个等价对的列表。 下面的代码实现了上述的过程。子区域用一维vector保存，没办法直接定位到某一行号的子区域，因此需要用curRow来记录当前的行，用firstAreaPrev记录前一行的第一个子区域在vector中的位置，用lastAreaPrev记录前一行的最后一个子区域在vector中的位置。在换行的时候，就去更新刚刚说的3个变量，其中firstAreaPrev的更新依赖于当前行的第一个子区域位置，所以还得用firstAreaCur记录当前行的第一个子区域。 &#x2F;&#x2F; 初步标签,获取等价对 &#x2F;&#x2F; labelOfArea:子区域标签值， equalLabels：等价标签对 offset:0为四连通,1为8连通 void markArea(int numberOfArea, vector&lt;int&gt; stArea, vector&lt;int&gt; enArea, vector&lt;int&gt; rowArea, vector&lt;int&gt; &amp;labelOfArea, vector&lt;pair&lt;int, int&gt;&gt; &amp;equalLabels, int offset) &#123; int label &#x3D; 1; &#x2F;&#x2F; 当前所在行 int curRow &#x3D; 0; &#x2F;&#x2F; 当前行的第一个子区域位置索引 int firstAreaCur &#x3D; 0; &#x2F;&#x2F; 前一行的第一个子区域位置索引 int firstAreaPrev &#x3D; 0; &#x2F;&#x2F; 前一行的最后一个子区域位置索引 int lastAreaPrev &#x3D; 0; &#x2F;&#x2F; 初始化标签都为0 labelOfArea.assign(numberOfArea, 0); &#x2F;&#x2F; 遍历所有子区域并标记 for (int i &#x3D; 0; i &lt; numberOfArea; i++) &#123; &#x2F;&#x2F; 行切换时更新状态变量 if (curRow !&#x3D; rowArea[i]) &#123; curRow &#x3D; rowArea[i]; firstAreaPrev &#x3D; firstAreaCur; lastAreaPrev &#x3D; i - 1; firstAreaCur &#x3D; i; &#125; &#x2F;&#x2F; 相邻行不存在子区域 if (curRow !&#x3D; rowArea[firstAreaPrev] + 1) &#123; labelOfArea[i] &#x3D; label++; continue; &#125; &#x2F;&#x2F; 对前一行进行迭代 for (int j &#x3D; firstAreaPrev; j &lt;&#x3D; lastAreaPrev; j++) &#123; &#x2F;&#x2F; 判断是否相连 if (stArea[i] &lt;&#x3D; enArea[j] + offset &amp;&amp; enArea[i] &gt;&#x3D; stArea[j] - offset) &#123; &#x2F;&#x2F; 之前没有标记过 if (labelOfArea[i] &#x3D;&#x3D; 0) labelOfArea[i] &#x3D; labelOfArea[j]; &#x2F;&#x2F; 之前已经被标记，保存等价对 else if (labelOfArea[i] !&#x3D; labelOfArea[j]) equalLabels.push_back(make_pair(labelOfArea[i], labelOfArea[j])); &#125;else if (enArea[i] &lt; stArea[j] - offset) &#123; &#x2F;&#x2F; 为当前行下一个子区域缩小上一行的迭代范围 firstAreaPrev &#x3D; max(firstAreaPrev, j - 1); break; &#125; &#125; &#x2F;&#x2F; 与上一行不存在相连 if (labelOfArea[i] &#x3D;&#x3D; 0) &#123; labelOfArea[i] &#x3D; label++; &#125; &#125; &#125; 2.DFS Two-pass算法 建立一个Bool型等价对矩阵，用作深搜环境。具体做法是先获取最大的标签值maxLabel，然后生成一个maxLabel∗maxLabel大小的二维矩阵，初始值为false；对于例如（1，3）这样的等价对，在矩阵的（0，2）和（2，0）处赋值true——要注意索引和标签值是相差1的。就这样把所有等价对都反映到矩阵上。 深搜的目的在于建立一个标签的重映射。例如4、5、8是等价的标签，都重映射到标签2。最后重映射的效果就是标签最小为1，且依次递增，没有缺失和等价。深搜在这里就是优先地寻找一列等价的标签，例如一口气把4、5、8都找出来，然后给他们映射到标签2。程序也维护了一个队列，当标签在矩阵上值为true，而且没有被映射过，就加入到队列。 当然不一定要建立一个二维等价矩阵，一般情况，等价对数量要比maxLabel来的小，所以也可以直接对等价对列表进行深搜，但无论采用怎样的深搜，其等价对处理的性能都不可能提高很多。 代码实现 &#x2F;&#x2F; 等价对处理，标签重映射 void replaceEqualMark(vector&lt;int&gt; &amp;labelOfArea, vector&lt;pair&lt;int, int&gt;&gt; equalLabels) &#123; int maxLabel &#x3D; *max_element(labelOfArea.begin(), labelOfArea.end()); &#x2F;&#x2F; 等价标签矩阵，值为true表示这两个标签等价 vector&lt;vector&lt;bool&gt;&gt; eqTab(maxLabel, vector&lt;bool&gt;(maxLabel, false)); &#x2F;&#x2F; 将等价对信息转移到矩阵上 vector&lt;pair&lt;int, int&gt;&gt;::iterator labPair; for (labPair &#x3D; equalLabels.begin(); labPair !&#x3D; equalLabels.end(); labPair++) &#123; eqTab[labPair-&gt;first -1][labPair-&gt;second -1] &#x3D; true; eqTab[labPair-&gt;second -1][labPair-&gt;first -1] &#x3D; true; &#125; &#x2F;&#x2F; 标签映射 vector&lt;int&gt; labelMap(maxLabel + 1, 0); &#x2F;&#x2F; 等价标签队列 vector&lt;int&gt; tempList; &#x2F;&#x2F; 当前使用的标签 int curLabel &#x3D; 1; for (int i &#x3D; 1; i &lt;&#x3D; maxLabel; i++) &#123; &#x2F;&#x2F; 如果该标签已被映射，直接跳过 if (labelMap[i] !&#x3D; 0) &#123; continue; &#125; labelMap[i] &#x3D; curLabel; tempList.push_back(i); for (int j &#x3D; 0; j &lt; tempList.size(); j++) &#123; &#x2F;&#x2F; 在所有标签中寻找与当前标签等价的标签 for (int k &#x3D; 1; k &lt;&#x3D; maxLabel; k++) &#123; &#x2F;&#x2F; 等价且未访问 if (eqTab[tempList[j] - 1][k - 1] &amp;&amp; labelMap[k] &#x3D;&#x3D; 0) &#123; labelMap[k] &#x3D; curLabel; tempList.push_back(k); &#125; &#125; &#125; curLabel++; tempList.clear(); &#125; &#x2F;&#x2F; 根据映射修改标签 vector&lt;int&gt;::iterator label; for (label &#x3D; labelOfArea.begin(); label !&#x3D; labelOfArea.end(); label++) &#123; *label &#x3D; labelMap[*label]; &#125; return; &#125; 2.并查集 Two-pass算法 等价对，实质是一种关系分类，因而联想到并查集。并查集方法在这个问题上显得非常合适，首先将等价对进行综合就是合并操作，标签重映射就是查询操作（并查集可以看做一种多对一映射）。这里定义成了类。 代码实现 #include&lt;opencv2&#x2F;opencv.hpp&gt; #include&lt;iostream&gt; using namespace std; using namespace cv; class AreaMark &#123; public: AreaMark(const Mat src,int offset); int getMarkedArea(vector&lt;vector&lt;int&gt;&gt; &amp;area); void getMarkedImage(Mat &amp;dst); private: Mat src; int offset; int numberOfArea&#x3D;0; vector&lt;int&gt; labelMap; vector&lt;int&gt; labelRank; vector&lt;int&gt; stArea; vector&lt;int&gt; enArea; vector&lt;int&gt; rowArea; vector&lt;int&gt; labelOfArea; vector&lt;pair&lt;int, int&gt;&gt; equalLabels; void markArea(); void searchArea(); void setInit(int n); int findRoot(int label); void unite(int labelA, int labelB); void replaceEqualMark(); &#125;; &#x2F;&#x2F; 构造函数 &#x2F;&#x2F; imageInput:输入待标记二值图像 offsetInput:0为四连通，1为八连通 AreaMark::AreaMark(Mat imageInput,int offsetInput) &#123; src &#x3D; imageInput; offset &#x3D; offsetInput; &#125; &#x2F;&#x2F; 使用可区分的颜色标记连通域 void AreaMark::getMarkedImage(Mat &amp;dst) &#123; Mat img(src.rows, src.cols, CV_8UC3, CV_RGB(0, 0, 0)); cvtColor(img, dst, CV_RGB2HSV); int maxLabel &#x3D; *max_element(labelOfArea.begin(), labelOfArea.end()); vector&lt;uchar&gt; hue; for (int i &#x3D; 1; i&lt;&#x3D; maxLabel; i++) &#123; &#x2F;&#x2F; HSV color-mode hue.push_back(uchar(180.0 * (i - 1) &#x2F; (maxLabel + 1))); &#125; for (int i &#x3D; 0; i &lt; numberOfArea; i++) &#123; for (int j &#x3D; stArea[i]; j &lt;&#x3D; enArea[i]; j++) &#123; dst.at&lt;Vec3b&gt;(rowArea[i], j)[0] &#x3D; hue[labelOfArea[i]]; dst.at&lt;Vec3b&gt;(rowArea[i], j)[1] &#x3D; 255; dst.at&lt;Vec3b&gt;(rowArea[i], j)[2] &#x3D; 255; &#125; &#125; cvtColor(dst, dst, CV_HSV2BGR); &#125; &#x2F;&#x2F; 获取标记过的各行子区域 int AreaMark::getMarkedArea(vector&lt;vector&lt;int&gt;&gt; &amp;area) &#123; searchArea(); markArea(); replaceEqualMark(); area.push_back(rowArea); area.push_back(stArea); area.push_back(enArea); area.push_back(labelOfArea); return numberOfArea; &#125; &#x2F;&#x2F; 查找每一行的子区域 &#x2F;&#x2F; numberOfArea：子区域总数 stArea：子区域开始位置 enArea：子区域结束位置 rowArea：子区域所在行号 void AreaMark::searchArea() &#123; for (int row &#x3D; 0; row &lt; src.rows; row++) &#123; &#x2F;&#x2F; 行指针 const uchar *rowData &#x3D; src.ptr&lt;uchar&gt;(row); &#x2F;&#x2F; 判断行首是否是子区域的开始点 if (rowData[0] &#x3D;&#x3D; 255)&#123; numberOfArea++; stArea.push_back(0); &#125; for (int col &#x3D; 1; col &lt; src.cols; col++) &#123; &#x2F;&#x2F; 子区域开始位置的判断：前像素为背景，当前像素是前景 if (rowData[col - 1] &#x3D;&#x3D; 0 &amp;&amp; rowData[col] &#x3D;&#x3D; 255) &#123; numberOfArea++; stArea.push_back(col); &#x2F;&#x2F; 子区域结束位置的判断：前像素是前景，当前像素是背景 &#125;else if (rowData[col - 1] &#x3D;&#x3D; 255 &amp;&amp; rowData[col] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 更新结束位置vector、行号vector enArea.push_back(col - 1); rowArea.push_back(row); &#125; &#125; &#x2F;&#x2F; 结束位置在行末 if (rowData[src.cols - 1] &#x3D;&#x3D; 255) &#123; enArea.push_back(src.cols - 1); rowArea.push_back(row); &#125; &#125; &#125; void AreaMark::markArea() &#123; int label &#x3D; 1; &#x2F;&#x2F; 当前所在行 int curRow &#x3D; 0; &#x2F;&#x2F; 当前行的第一个子区域位置索引 int firstAreaCur &#x3D; 0; &#x2F;&#x2F; 前一行的第一个子区域位置索引 int firstAreaPrev &#x3D; 0; &#x2F;&#x2F; 前一行的最后一个子区域位置索引 int lastAreaPrev &#x3D; 0; &#x2F;&#x2F; 初始化标签都为0 labelOfArea.assign(numberOfArea, 0); &#x2F;&#x2F; 遍历所有子区域并标记 for (int i &#x3D; 0; i &lt; numberOfArea; i++) &#123; &#x2F;&#x2F; 行切换时更新状态变量 if (curRow !&#x3D; rowArea[i]) &#123; curRow &#x3D; rowArea[i]; firstAreaPrev &#x3D; firstAreaCur; lastAreaPrev &#x3D; i - 1; firstAreaCur &#x3D; i; &#125; &#x2F;&#x2F; 相邻行不存在子区域 if (curRow !&#x3D; rowArea[firstAreaPrev] + 1) &#123; labelOfArea[i] &#x3D; label++; continue; &#125; &#x2F;&#x2F; 对前一行进行迭代 for (int j &#x3D; firstAreaPrev; j &lt;&#x3D; lastAreaPrev; j++) &#123; &#x2F;&#x2F; 判断是否相连 if (stArea[i] &lt;&#x3D; enArea[j] + offset &amp;&amp; enArea[i] &gt;&#x3D; stArea[j] - offset) &#123; &#x2F;&#x2F; 之前没有标记过 if (labelOfArea[i] &#x3D;&#x3D; 0) labelOfArea[i] &#x3D; labelOfArea[j]; &#x2F;&#x2F; 之前已经被标记，保存等价对 else if (labelOfArea[i] !&#x3D; labelOfArea[j]) equalLabels.push_back(make_pair(labelOfArea[i], labelOfArea[j])); &#125;else if (enArea[i] &lt; stArea[j] - offset) &#123; &#x2F;&#x2F; 为当前行下一个子区域缩小上一行的迭代范围 firstAreaPrev &#x3D; max(firstAreaPrev, j - 1); break; &#125; &#125; &#x2F;&#x2F; 与上一行不存在相连 if (labelOfArea[i] &#x3D;&#x3D; 0) &#123; labelOfArea[i] &#x3D; label++; &#125; &#125; &#125; &#x2F;&#x2F;集合初始化 void AreaMark::setInit(int n) &#123; for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123; labelMap.push_back(i); labelRank.push_back(0); &#125; &#125; &#x2F;&#x2F;查找树根 int AreaMark::findRoot(int label) &#123; if (labelMap[label] &#x3D;&#x3D; label) &#123; return label; &#125; else &#123; &#x2F;&#x2F; path compression return labelMap[label] &#x3D; findRoot(labelMap[label]); &#125; &#125; &#x2F;&#x2F; 合并集合 void AreaMark::unite(int labelA, int labelB) &#123; labelA &#x3D; findRoot(labelA); labelB &#x3D; findRoot(labelB); if (labelA &#x3D;&#x3D; labelB) &#123; return; &#125; &#x2F;&#x2F; rank optimization:tree with high rank merge tree with low rank if (labelRank[labelA] &lt; labelRank[labelB]) &#123; labelMap[labelA] &#x3D; labelB; &#125; else &#123; labelMap[labelB] &#x3D; labelA; if (labelRank[labelA] &#x3D;&#x3D; labelRank[labelB]) &#123; labelRank[labelA]++; &#125; &#125; &#125; &#x2F;&#x2F; 等价对处理，标签重映射 void AreaMark::replaceEqualMark() &#123; int maxLabel &#x3D; *max_element(labelOfArea.begin(), labelOfArea.end()); setInit(maxLabel); &#x2F;&#x2F; 合并等价对，标签初映射 vector&lt;pair&lt;int, int&gt;&gt;::iterator labPair; for (labPair &#x3D; equalLabels.begin(); labPair !&#x3D; equalLabels.end(); labPair++) &#123; unite(labPair-&gt;first, labPair-&gt;second); &#125; &#x2F;&#x2F; 标签重映射，填补缺失标签 int newLabel&#x3D;0; vector&lt;int&gt; labelReMap(maxLabel + 1, 0); vector&lt;int&gt;::iterator old; for (old &#x3D; labelMap.begin(); old !&#x3D; labelMap.end(); old++) &#123; if (labelReMap[findRoot(*old)] &#x3D;&#x3D; 0) &#123; labelReMap[findRoot(*old)] &#x3D; newLabel++; &#125; &#125; &#x2F;&#x2F; 根据重映射结果修改标签 vector&lt;int&gt;::iterator label; for (label &#x3D; labelOfArea.begin(); label !&#x3D; labelOfArea.end(); label++) &#123; *label &#x3D; labelReMap[findRoot(*label)]; &#125; &#125; int main() &#123; Mat img &#x3D; imread(&quot;img&#x2F;qrcode.jpg&quot;, IMREAD_GRAYSCALE); threshold(img, img, 0, 255, THRESH_OTSU); AreaMark marker(img, 0); vector&lt;vector&lt;int&gt;&gt; area; int amount; &#x2F;&#x2F; 1s for 1000 times amount &#x3D; marker.getMarkedArea(area); Mat dst; marker.getMarkedImage(dst); imshow(&quot;img&quot;, img); imshow(&quot;dst&quot;, dst); waitKey(0); &#125; 霍夫变换直线检测标准霍夫变换首先该检测算法的输入图像只能是边缘二值图像。 1.一条直线在图像二维空间可由两个变量表示： · 在笛卡尔坐标系：y = kx + b，可由k、b表示。 · 在极坐标系：ρ = xcosθ + ysinθ，可由ρ、θ表示 2.对于点（x0，y0），可将经过这个点的一簇直线定义为ρ = x0cosθ + y0sinθ 2.很自然的，对于两个点，满足同一对（ρ，θ）时，这两个点处于同一直线上 3.于是，当有更多个点满足同一对（ρ，θ）时，该对表示的直线由更多的点组成.。一般可以通过设置直线上点的阈值来定义多少个点组成的（ρ，θ）能被认为是一条直线。 4.霍夫变换追踪图像中每个点对应的所有（ρ，θ）并记录数量，若超过了阈值, 那么可以认为这个交点所代表的参数对在原图像中为一条直线。 代码实现 对于图像的每个像素点，遍历 [0, PI] 共180个θ值，得到相应的ρ，并对每一组（ρ，θ）记录值+1（计分板）。 遍历计分板，找出分数大于设定阈值的（ρ，θ）对，即为检测到的直线参数，再将其还原为数学概念上的直线即可。 累计概率霍夫变换（常用）它是对标准霍夫变换的改进。在一定的范围内进行霍夫变换，计算单独线段的方向以及范围，从而减少计算量，缩短计算时间。之所以称PPHT为“概率”的，是因为并不将累加器平面内的所有可能的点累加，而只是累加其中的一部分，该想法是如果峰值如果足够高，只用一小部分时间去寻找它就够了。这样猜想的话，可以实质性地减少计算时间。 代码实现 1.随机获取边缘图像上的前景点，映射到极坐标系画曲线； 2.当极坐标系里面有交点达到最小投票数，将该点对应x-y坐标系的直线L找出来； 3.搜索边缘图像上前景点，在直线L上的点（且点与点之间距离小于maxLineGap的）连成线段，然后这些点全部删除，并且记录该线段的参数（起始点和终止点），当然线段长度要满足最小长度； 4.重复1. 2. 3.。 opencv函数 HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength &#x3D; 0, double maxLineGap &#x3D; 0) 池化池化的作用：减少特征图大小，也就是可以减少计算量和所需显存。 平均池化（mean-pooling）即对邻域内特征点只求平均 优缺点：能很好的保留背景，但容易使得图片变模糊 正向传播：邻域内取平均 反向传播：特征值根据领域大小被平均，然后传给每个索引位置 最大池化（max-pooling）即对邻域内特征点取最大 优缺点：能很好的保留纹理特征，一般现在都用最大而很少用平均 正向传播：取邻域内最大，并记住最大值的索引位置，以方便反向传播 反向传播：将特征值填充到正向传播中，值最大的索引位置，其他位置补0 随机池化（stochastic-pooling）只需对邻域中的元素按照其概率值大小随机选择，即元素值大的被选中的概率也大。而不像max-pooling那样，永远只取那个最大值元素。 在区域内，将左图的数值进行归一化处理，即 1/（1+2+3+4）=0.1；2/10=0.2；3/10=0.3；4/10=0.4 正向传播：对矩阵区域求加权平均即可，比如上面图中，池化输出值为：1 * 0.1+2 * 0.2+3 * 0.3+4 * 0.4=3。 反向传播：只需保留前向传播已经记录被选中节点的位置的值，其它值都为0,这和max-pooling的反向传播非常类似。 优点：方法简单，泛化能力更强（带有随机性） 颜色亮度与对比度基础线性变化在查询opencv的亮度与对比度变化算法时，大多是博客都采用的最基础的线性变换： ​ out = in * α + β 其中 α 为对比度的变化，β 为亮度变化。 亮度（β）：像素点的值就是0~255，0为黑表示最暗，255为白表示最亮。因此调节亮度就是简单的对像素值进行增减即可，即 β ∈ (-100，-100) 。 对比度（α）：这里就存在问题了，线性变化的对比度调节非常不明显，在视觉上依旧呈现的是亮度的变化，在进行代码编写的时候一直达不到Photoshop里面的对比度调节效果。 改进通过查阅资料不难发现，对比度的调节原理如下： 对比度反应了图片上亮区域和暗区域的层次感。而反应到图像编辑上，调整对比度就是在保证平均亮度不变的情况下，扩大或缩小亮的点和暗的点的差异。既然是要保证平均亮度不变，所以对每个点的调整比例必须作用在该值和平均亮度的差值之上，这样才能够保证计算后的平均亮度不变。 因此很容易得出对比度变化的调整公式如下： ​ out = (in - average) * α + in 其中average为图像的平均亮度，α ∈ (-1，1) 。 但是实际处理中，并没有太多的必要去计算一张图的平均亮度：一来耗时间，二来在平均亮度上的精确度并不会给图像的处理带来太多的好处。因此一般假设一张图的平均亮度为127，即一半亮度，而一张正常拍照拍出来的图平均亮度应该是在[100,150]。在视觉上基本没有任何区别。 于是可得最终的亮度对比度调节公式： ​ out = (in - average) * α + in + β 达到了和Photoshop相同的效果。 通道混合也就是调整某一个通道中的颜色成分，可以理解为调整图片某一颜色区域的颜色。 对于选中通道的每一个像素值，进行如下变换： ​ out = red * r + green * g + blue * b + constant * 255 其中，red、green、blue ∈ (-2, 2) ，**constant ∈ (-1, 1)**，r、g、b为每一个像素点的三个通道的值。 gamma变换（校正）Gamma校正是一种非常重要的非线性变换。对输入图像的灰度值进行指数变换，进而校正亮度偏差，通常应用于扩展暗调的细节。gamma校正可使得图像看起来更符合人眼的特性。 但其实Gamma校正不仅会改变亮度，还会改变彩色图像中rgb的比率。 当Gamma校正的值大于1时，图像的高光部分被压缩而暗调部分被扩展，图像整体变暗； 当Gamma校正的值小于1时，图像的高光部分被压缩而暗调部分被压缩，图像整体变亮。 gamma校正的作用： 1.人眼对外界光源的感光值与输入光强不是呈线性关系的，而是呈指数型关系的。在低照度下，人眼更容易分辨出亮度的变化，随着照度的增加，人眼不易分辨出亮度的变化。而摄像机感光与输入光强呈线性关系。 2.为能更有效的保存图像亮度信息。未经Gamma变换和经过Gamma变换保存图像信息如下所示：可以观察到，未经Gamma变换的情况下，低灰度时，有较大范围的灰度值被保存成同一个值，造成信息丢失；同时高灰度值时，很多比较接近的灰度值却被保存成不同的值，造成空间浪费。经过Gamma变换后，改善了存储的有效性和效率。 Gamma校正主要应用在图像增强、目标检测以及图像分析等领域。表达式如下： 代码实现 unsigned char newPixel &#x3D; static_cast&lt;unsigned char&gt;(pow(pixel &#x2F; 255.0, gamma) * 255); 对数变换由于对数曲线在像素值较低的区域斜率大，在像素值较高的区域斜率较小，所以图像经过对数变换后，较暗区域的对比度将有所提升，所以就可以增强图像的暗部细节。 对数变换可以将图像的低灰度值部分扩展，显示出低灰度部分更多的细节，将其高灰度值部分压缩，减少高灰度值部分的细节，从而达到强调图像低灰度部分的目的。表达式如下： 图像的归一化所谓归一化，就是把需要处理的数据限制在你需要的一定范围内。 首先归一化是为了后面数据处理的方便，其次是保证程序运行时收敛加快。归一化的具体作用是归纳统一样本的统计分布性。归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布。 而图像的归一化用的最多的就是归一化到（min，max）范围内： 代码实现 首先迭代整个图的像素点，获取max( src( x，y ) )和min像素点。 然后再次迭代整张图的像素点，将低于min的设置为min，高于max 的设置为max，在（min，max）之间的通过上式计算即可。 图像的均衡化直方图均衡化，是对图像像素值进行非线性拉伸，使得一定范围内像素值的数量的大致相同。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。如下图所示： 通过这种方法可以按照需要对图像的亮度进行调整，并且，这种方法是可逆的，也就是说知道了均衡化函数，也可以恢复原始的直方图。 为什么要选用累积分布函数? 均衡化过程中，必须要保证两个条件：①像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；②如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界。综合以上两个条件，累积分布函数是个好的选择，因为累积分布函数是单调增函数（控制大小关系），并且值域是0到1（控制越界问题），所以直方图均衡化中使用的是累积分布函数。 为什么使用累积分布函数处理后像素值会均匀分布？ 比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是： 其中，n是图像中像素点的总数，nk是当前灰度级的像素个数，L是图像中可能的灰度级总数。 于是对于像素值为k的点，只需要计算： 像素为0~k的点的数量 / 像素点总数，就可以得到直方图中的纵坐标（比例）。再乘以255，即为该点经过均衡化后的像素点。 RGB转灰度一、基础 对于彩色转灰度，有一个很著名的心理学公式： Gray = R * 0.299 + G * 0.587 + B * 0.114 二、整数算法 而实际应用时，希望避免低速的浮点运算，所以需要整数算法。 注意到系数都是3位精度的没有，我们可以将它们缩放1000倍来实现整数运算算法： Gray = (R * 299 + G * 587 + B * 114 + 500) / 1000 RGB一般是8位精度，现在缩放1000倍，所以上面的运算是32位整型的运算。注意后面那个除法是整数除法，所以需要加上500来实现四舍五入。 三、整数移位算法 上面的整数算法已经很快了，但是有一点仍制约速度，就是最后的那个除法。移位比除法快多了，所以可以将系数缩放成 2的整数幂。 习惯上使用16位精度，2的16次幂是65536，所以这样计算系数： 0.299 * 65536 = 19595.264 ≈ 19595 0.587 * 65536 + (0.264) = 38469.632 + 0.264 = 38469.896 ≈ 38469 0.114 * 65536 + (0.896) = 7471.104 + 0.896 = 7472 这所使用的舍入方式不是四舍五入。四舍五入会有较大的误差，应该将以前的计算结果的误差一起计算进去，舍入方式是去尾法，表达式是： Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16 同理，2至20位精度的系数： Gray = (R * 1 + G * 2 + B * 1) &gt;&gt; 2Gray = (R * 2 + G * 5 + B * 1) &gt;&gt; 3Gray = (R * 4 + G * 10 + B * 2) &gt;&gt; 4Gray = (R * 9 + G * 19 + B * 4) &gt;&gt; 5Gray = (R * 19 + G * 37 + B * 8) &gt;&gt; 6Gray = (R * 38 + G * 75 + B * 15) &gt;&gt; 7Gray = (R * 76 + G * 150 + B * 30) &gt;&gt; 8Gray = (R * 153 + G * 300 + B * 59) &gt;&gt; 9Gray = (R * 306 + G * 601 + B * 117) &gt;&gt; 10Gray = (R * 612 + G * 1202 + B * 234) &gt;&gt; 11Gray = (R * 1224 + G * 2405 + B * 467) &gt;&gt; 12Gray = (R * 2449 + G * 4809 + B * 934) &gt;&gt; 13Gray = (R * 4898 + G * 9618 + B * 1868) &gt;&gt; 14Gray = (R * 9797 + G * 19235 + B * 3736) &gt;&gt; 15Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16Gray = (R * 39190 + G * 76939 + B * 14943) &gt;&gt; 17Gray = (R * 78381 + G * 153878 + B * 29885) &gt;&gt; 18Gray = (R * 156762 + G * 307757 + B * 59769) &gt;&gt; 19Gray = (R * 313524 + G * 615514 + B * 119538) &gt;&gt; 20 这些精度实际上是一样的：3与4、7与8、10与11、13与14、19与20 所以16位运算下最好的计算公式是使用7位精度，比先前那个系数缩放100倍的精度高，而且速度快 Gray = (R * 38 + G * 75 + B * 15) &gt;&gt; 7 灰度转伪彩色本质就是将灰度值根据一定的比例关系转化为RGB三通道值。 人类能够观察到的光的波长范围是有限的，并且人类视觉有一个特点，只能分辨出二十几种灰度，也就是说即使采集到的灰度图像分辨率超级高，有上百个灰度级，但是很遗憾，人们只能看出二十几个，也就是说信息损失了五十倍。但人类视觉对彩色的分辨能力相当强，能够分辨出几千种色度。 以下为opencv中ColorMap提供的21种不同伪彩色： 根据源码中获得的数组对每个像素进行转换即可。 RGB模型图像处理中，最常用的颜色空间是RGB模型，常用于颜色显示和图像处理，三维坐标的模型形式。 原点到白色顶点的中轴线是灰度线，r、g、b三分量相等，强度可以由三分量的向量表示。 用RGB来理解色彩、深浅、明暗变化如下： 色彩变化： 三个坐标轴RGB最大分量顶点与黄紫青YMC色顶点的连线 深浅变化：RGB顶点和CMY顶点到原点和白色顶点的中轴线的距离 明暗变化：中轴线的点的位置，到原点，就偏暗，到白色顶点就偏亮 HSV色域这是针对用户观感的一种颜色模型，侧重于色彩表示，什么颜色、深浅如何、明暗如何。 色调H 用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°； 饱和度S 饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。 明度V 明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。 H是色彩 S是深浅， S = 0时，只有灰度 V是明暗，表示色彩的明亮程度 把RGB三维坐标的中轴线立起来，并扁化，就能形成HSV的锥形模型了。 RGB到HSV转化模型 首先要将图像的R、G、B三个通道的分量归一化到0 ~ 1之间。 我们设max为该像素点的RGB中的最大值，min为最小值，有如下公式： float max &#x3D; 0,min &#x3D; 0; max &#x3D; retmax(R,G,B); &#x2F;&#x2F; 计算三者的最大值 min &#x3D; retmin(R,G,B); v &#x3D; max; if(max &#x3D;&#x3D; 0) s &#x3D; 0; else s &#x3D; 1 - (min &#x2F; max); if(max &#x3D;&#x3D; min) h &#x3D; 0; else if(max &#x3D;&#x3D; R &amp;&amp; G &gt;&#x3D; B) h &#x3D; 60 * ((G - B) &#x2F; (max - min)); else if(max &#x3D;&#x3D; R &amp;&amp; G &lt; B) h &#x3D; 60 * ((G - B) &#x2F; (max - min)) + 360; else if(max &#x3D;&#x3D; G) h &#x3D; 60 * ((B - R) &#x2F; (max - min)) + 120; else if(max &#x3D;&#x3D; B) h &#x3D; 60 * ((R - G) &#x2F; (max - min)) + 240; HSV到RGB转化模型 float C &#x3D; 0,X &#x3D; 0,Y &#x3D; 0,Z &#x3D; 0; int i &#x3D; 0; float H &#x3D; h &#x2F; 1.0; float S &#x3D; s &#x2F; 100.0; float V &#x3D; v &#x2F; 100.0; if(S &#x3D;&#x3D; 0) R &#x3D; G &#x3D; B &#x3D; V; else &#123; H &#x3D; H &#x2F; 60; i &#x3D; (int)H; C &#x3D; H - i; X &#x3D; V * (1 - S); Y &#x3D; V * (1 - S * C); Z &#x3D; V * (1 - S * (1 - C)); switch(i)&#123; case 0 : R &#x3D; V; G &#x3D; Z; B &#x3D; X; break; case 1 : R &#x3D; Y; G &#x3D; V; B &#x3D; X; break; case 2 : R &#x3D; X; G &#x3D; V; B &#x3D; Z; break; case 3 : R &#x3D; X; G &#x3D; Y; B &#x3D; V; break; case 4 : R &#x3D; Z; G &#x3D; X; B &#x3D; V; break; case 5 : R &#x3D; V; G &#x3D; X; B &#x3D; Y; break; &#125; &#125; HSI色域与HSV色域表达的意义类似，区别在于取值的方式，基于I和V。 二者都是表示明度，V取值为R、G、B中的最大值，而I取值为R、G、B的均值。 RGB到HSI转化模型 HSI到RGB转化模型 HSL色域是工业界的另一种色彩模型标准。 HSL 和 HSV二者都把颜色描述在圆柱体内的点，这个圆柱的中心轴取值为自底部的黑色到顶部的白色而在它们中间是的灰色，绕这个轴的角度对应于“色相”，到这个轴的距离对应于“饱和度”，而沿着这个轴的距离对应于“亮度”，“色调”或“明度”。 这两种表示在目的上类似，但在方法上有区别。二者在数学上都是圆柱，但 HSV（色相，饱和度，明度）在概念上可以被认为是颜色的倒圆锥体（黑点在下顶点，白色在上底面圆心），HSL在概念上表示了一个双圆锥体和圆球体（白色在上顶点，黑色在下顶点，最大横切面的圆心是半程灰色）。注意尽管在HSL 和HSV 中“色相”指称相同的性质，它们的“饱和度”的定义是明显不同的。 在 HSL 中，饱和度分量总是从完全饱和色变化到等价的灰色（在 HSV 中，在极大值 V 的时候，饱和度从全饱和色变化到白色，这可以被认为是反直觉的）。 在 HSL 中，亮度跨越从黑色过选择的色相到白色的完整范围（在 HSV 中，V 分量只走一半行程，从黑到选择的色相）。 RGB到HSL转化模型 HSL到RGB转化模型 差影法原理上来说就是两幅图像作差对应的像素点之间作差。 常用于判断两幅角度相同的相似图像之间的差别。 可以通过对差值乘以一个倍数，实现放大差别的效果。 是否对差值使用绝对值计算，对作差的结果有一定影响。 二值化普通二值化遍历判断图像每个像素点的值，如果大于设定的阈值，则修改为255，如果小于，则修改为0。 大津法二值化图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响。它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量，背景和前景之间的类间方差越大，说明构成图像的两部分的差别越大，当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。 优点：计算简单快速，不受图像亮度和对比度的影响。适用于大部分需要求图像全局阈值的场合。 缺点：对图像噪声敏感；只能针对单一目标分割；当目标和背景大小比例悬殊、类间方差函数可能呈现双峰或者多峰，这个时候效果不好。 实现原理 同样用到了最大类间方差的概念，参考下面双阈值三值化，不再多叙述。 注： 为了快速计算，可将类间方差计算公式：σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 简化为：σ^2 = p1 * p2 * ( m1 - m2 ) ^ 2 局部自适应二值化核心就是对每个像素点，计算它指定大小邻域内的阈值，来作为这个像素点的二值化阈值。 邻域阈值的计算方法常用的有两种：均值和高斯加权和。 计算方法非常简单，在本文上述提到的均值滤波和高斯滤波的基础上，对计算出的每个像素点邻域内的均值或高斯加权和，减去一个指定的偏移量，就是该点的二值化阈值了。 双阈值三值化首先获取图像像素的直方图，即像素值为0 - 255的点分别有几个，并分别计算它们占总像素点数的比例（即一个点为该像素值的概率，Pi（i=0 - 255））。 其次设定两个阈值k1和k2，将0 - 255分为三类（0 - k1，k1 - k2，k2 - 255），计算： 一个点被分为其中一类的概率，表现为该类像素范围内概率的和。 这三类各自的像素均值，表现为： 于是有：mg = p1 * m1 + p2 * m2 + p3 * m3，且 p1+p2+p3 = 1 可得类间方差：（更多或更少类均同理） σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 + p3 * ( m3 - mg ) ^ 2 最终目的是为了获得当类间方差最大时的k1和k2 最后只需要判断每个像素点的值在这三类中的哪类，分别修改值为0，128，255即可。 因此代码实现为： for (k1 &#x3D; 1; k1 &lt; 256; k1++)&#123; for (k2 &#x3D; 1; k2 &lt; 256; k2++)&#123; for (int i &#x3D; 0; i &lt; k1; i++)&#123; p1 +&#x3D; Pi; m1 +&#x3D; i * Pi; &#125; for (int i &#x3D; k1; i &lt; k2; i++)&#123; p2 +&#x3D; Pi; m2 +&#x3D; i * Pi; &#125; for (int i &#x3D; k2; i &lt; 256; i++)&#123; p3 +&#x3D; Pi; m3 +&#x3D; i * Pi; &#125; mg &#x3D; m1 + m2 + m3; m1 &#x2F;&#x3D; p1; m2 &#x2F;&#x3D; p2; m3 &#x2F;&#x3D; p3; &#x2F;&#x2F; 类间方差 double sigma &#x3D; p1 * pow(m1 - mg, 2) + p2 * pow(m2 - mg, 2) + p3 * pow(m3 - mg, 2); if (max &lt; sigma)&#123; max &#x3D; sigma; thres1 &#x3D; k1; thres2 &#x3D; k2; &#125; &#125; &#125; 几何变换图像的缩放最近邻插值 由于缩放比例（即srcWidth / dstWidth）基本上是浮点数值，而最后得到的图像坐标（srcX）是整数。因此需要对等式右边的值进行四舍五入的操作： int srcX &#x3D; static_cast&lt;int&gt;(dstX * (srcWidth &#x2F; dstWidth) + 0.5f); &#x2F;&#x2F; 其中static_cast用于强制转换为int类型 &#x2F;&#x2F; +0.5f是为了实现四舍五入而不是舍去小数点后的值 这种方法在放大图像时容易导致图像的严重失真，根源在于当坐标是浮点数时直接四舍五入取最近的整数。 双线性插值线性插值的解释 已知数据 (x0, y0) 与 (x1, y1)，要计算 [x0, x1] 区间内某一位置 x 在直线上的y值。 双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。如下图： 假如我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。最常见的情况，f就是一个像素点的像素值。首先在 x 方向进行线性插值，得到： 然后在上述基础上（R1和R2），在 y 方向进行线性插值，得到： 展开即为最终结果： 代码实现 由于图像双线性插值只会用相邻的4个点，因此上述公式的分母都是1。opencv中的源码如下，用了一些优化手段： 用整数计算代替float（下面代码中的 * 2048就是变11位小数为整数，最后有两个连乘，因此&gt;&gt;22位） 源图像和目标图像几何中心的对齐 SrcX&#x3D;(dstX + 0.5) * (srcWidth&#x2F;dstWidth) -0.5 SrcY&#x3D;(dstY + 0.5) * (srcHeight&#x2F;dstHeight) - 0.5 源图像和目标图像的原点（0，0）均选择左上角，然后根据插值公式计算目标图像每点像素，假设你需要将一幅5x5的图像缩小成3x3，那么源图像和目标图像各个像素之间的对应关系如下。如果没有这个中心对齐，根据基本公式去算，就会得到左边这样的结果；而用了对齐，就会得到右边的结果： 双立方插值邻域像素再取样插值lanczos插值图像的旋转旋转矩阵的计算原理参考： 实现方法： 采用反向映射。即从旋转后的图像出发，找到对应的原图像的点，然后将原图像中的灰度值传递过来即可，这样旋转后的图像的每个像素肯定可以对应到原图像中的一个点。 采用不同的策略算法可以使像素更加准确，*具体参照图像缩放中的各种插值法，在旋转中是同理。 直线拟合 这里只记录最常用的一种：最小二乘拟合算法 这种方法是以距离平方和为拟合判据，运行速度也最快。但是这个算法也有个很大的问题，就是当干扰点离直线较远时，一个干扰点就可能将整条拟合直线拉偏了。简单的说就是对干扰点的鲁棒性不够。 代码实现 假设直线表达式为：y = ax + b，a表示斜率，b表示截距。 对于等精度测量所得到的N组数据（xi，yi），i＝1，2……，N，其中xi值被认为是准确的，所有的误差只联系着yi；用最小二乘法估计参数时，要求观测值yi的偏差的加权平方和为最小。对于等精度观测值的直线拟合来说，可使下式的值最小： 令上式等于D，并分别对a，b求一阶偏导数： 再求二阶偏导数： 很显然二阶偏导数均为非负数，于是令一阶偏导数等于0，解得a和b： 若要转化成方向向量： 因为方向向量长度为1且起点为原点，所以易得：x^2 + a * x^2 = 1，解得： **x = 1 / sqrt( a^2 + 1 ) ** **y = a / sqrt( a^2 + 1 ) ** 即为方向向量。","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"},{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"图像","slug":"图像","permalink":"https://www.hanhan0223.cn/tags/%E5%9B%BE%E5%83%8F/"}]},{"title":"opencv移库笔记","slug":"opencv移库笔记","date":"2021-12-23T11:28:33.000Z","updated":"2022-11-07T10:39:23.766Z","comments":true,"path":"杂记/opencv移库笔记/","link":"","permalink":"https://www.hanhan0223.cn/%E6%9D%82%E8%AE%B0/opencv%E7%A7%BB%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"环境配置VMware Workstation版本 16.0版本！ 16.0版本！ 16.0版本！15版本的有bug，会闪退。 VMware Tools实现物理机和虚拟机之间的文件和文本的直接复制粘贴 1.点击虚拟机选项中的安装，安装的是个tar.gz的压缩包 2.将虚拟机解压至任意路径下，并在该路径下进入命令行 3../vmware-install.pl即可完成安装","text":"环境配置VMware Workstation版本 16.0版本！ 16.0版本！ 16.0版本！15版本的有bug，会闪退。 VMware Tools实现物理机和虚拟机之间的文件和文本的直接复制粘贴 1.点击虚拟机选项中的安装，安装的是个tar.gz的压缩包 2.将虚拟机解压至任意路径下，并在该路径下进入命令行 3../vmware-install.pl即可完成安装 Ubuntu16.0版本，用户名和密码设简单点！建议英文！ 切换中文输入法用Ctrl+空格。 解压：tar -zxvf xxx.tar.gz 分辨率cvt 1920 1080 &#x2F;&#x2F; 返回 # 1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.00 MHz Modeline &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync &#x2F;&#x2F; 增加显示模块，并设置为开机启动，编辑”&#x2F;etc&#x2F;profile”，在末尾增加： xrandr --newmode &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync xrandr --addmode VGA1 &quot;1920x1080_60.00&quot; &#x2F;&#x2F; 立即启用 source &#x2F;etc&#x2F;profile 之后就可以在设置中的Display里修改啦。 opencv库安装与编译下载1.在GitHub上下载了opencv4.1.1的库，并在Ubuntu中解压 2.下载 ippicv_2019_lnx_intel64_general_20180723，这个压缩包无需解压 3.将opencv-4.1.1/3rdparty/ippicv/ippicv.cmake文件中倒数第十行(以http开头的)修改成”file://path“, path为下载的ippicv_2019_lnx_intel64_general_20180723在你的电脑中存放的位置（绝对路径） 安装依赖包sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 编译opencv在opencv-4.1.1路径下 mkdir build cd build cmake -D CMAKE_BUILD_TYPE&#x3D;Release -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local -D OPENCV_GENERATE_PKGCONFIG&#x3D;ON .. &#x2F;&#x2F; 这里选择安装路径为&#x2F;usr&#x2F;local下，并开启了pkg-config &#x2F;&#x2F; 因为opencv4开始就不会主动支持pkg-config了，但是编译还是需要这个。 &#x2F;&#x2F; 一定注意这两个点“..”，这是选择编译的内容为整个opencv文件夹 &#x2F;&#x2F; 编译结束后进入下一步： make -j8 &#x2F;&#x2F; 这一步比较久一点，8为选择编译时使用的内核数 sudo make install opencv_version &#x2F;&#x2F;编译结束后运行，若能查看到版本号就ok了 sudo gedit &#x2F;etc&#x2F;ld.so.conf.d&#x2F;opencv.conf &#x2F;&#x2F;设置opencv的环境变量。(文件可能为空，即原来不存在，新建立的) &#x2F;&#x2F;将如下内容添加到最后： &#x2F;usr&#x2F;local&#x2F;lib (依然要对应成你本身的路径，这个看看安装好之后，你的安装路径下的lib文件夹位置) &#x2F;&#x2F;配置库 sudo ldconfig &#x2F;&#x2F;更改环境变量： sudo gedit &#x2F;etc&#x2F;bash.bashrc &#x2F;&#x2F;在文件后添加 PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;home&#x2F;ubun&#x2F;myinstall&#x2F;lib&#x2F;pkgconfig export PKG_CONFIG_PATH opencv 编译后主要文件位于 /usr/local/bin /usr/local/include/opencv4 /usr/local/lib 导入opencv扩展包1.下载opencv_contrib-4.1.1扩展包 2.将文件夹解压至opencv-4.1.1文件夹下，同时删除其下的build文件夹（之前的编译文件） 3.下载可能缺少的.i文件（会导致编译失败） 将下载的.i文件放至**/opencv_4.1.1/opencv_contrib-4.1.1/modules/xfeatures2d/src/**目录下 4.按照上一节的步骤重新编译，其中编译命令做一点改动（增加一句） cmake -D CMAKE_BUILD_TYPE&#x3D;Release -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local -D OPENCV_EXTRA_MODULES_PATH&#x3D;&#x2F;home&#x2F;shenzihan&#x2F;opencv-4.1.1&#x2F;opencv_contrib-4.1.1&#x2F;modules&#x2F; -D OPENCV_GENERATE_PKGCONFIG&#x3D;ON .. 5.在执行make -j4时可能会报错：fatal error: features2d/test/test_detectors_regression.impl.hpp: No such file or directory 按照内容，将opencv-4.1.1/modules/下的features2d文件夹复制到build文件夹下即可。 移植opencv总体流程1.封装函数 需求的操作系统环境下，只允许int char等基本类型的数据类型，因此需要将opencv库中定义的类型（如Mat）做一个转换。函数的输入不再是Mat而是转化成unsigned char和int。 也就是需要在每个opencv函数外面套一层壳，先将unsigned char和int 转为Mat CPoint等输入opencv函数，返回值再转回unsigned char和int作为移植函数的返回值，即可。 2.生成.so动态链接库 编译写好的移植函数生成.so文件： g++ -fpic -shared -o target.so source.cpp &#96;pkg-config --cflags --libs opencv4&#96; -std&#x3D;c++11 一步到位，直接生成.so文件 3.在测试文件中调用so文件测试功能 void * LdSoHandle&#x3D;dlopen(&quot;.&#x2F;target.so&quot;, RTLD_NOW|RTLD_GLOBAL); 4.编译测试文件生成可执行文件 g++ -std&#x3D;c++11 main.cpp -o mai &#96;pkg-config --cflags --libs opencv4&#96; -ldl &#x2F;&#x2F; -ldl一定要加上 opencv图像类型参数的值 类型 int值 elemSize() CV_8UC1 0 1 CV_8UC2 8 2 CV_8UC3 16 3 CV_32FC1 5 4 CV_32FC2 13 8 CV_32FC3 21 12 CV_16FC1 7 2 CV_16FC2 15 4 CV_16FC3 23 6","categories":[{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"环境","slug":"环境","permalink":"https://www.hanhan0223.cn/tags/%E7%8E%AF%E5%A2%83/"}]},{"title":"PyQt5狗都不用:阴阳师挂机软件OnHook","slug":"PyQt5狗都不用-阴阳师挂机软件OnHook","date":"2021-08-11T15:02:25.000Z","updated":"2022-11-07T10:39:23.705Z","comments":true,"path":"应用/PyQt5狗都不用-阴阳师挂机软件OnHook/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E7%8B%97%E9%83%BD%E4%B8%8D%E7%94%A8-%E9%98%B4%E9%98%B3%E5%B8%88%E6%8C%82%E6%9C%BA%E8%BD%AF%E4%BB%B6OnHook/","excerpt":"阴阳师玩家占比最大的行为就是刷魂土了，但作为万年老咸鱼，单刷得12体，500樱饼完全挂不了多少局自动。而手动挂……既然是重复操作，就有办法用自动化脚本来代替，于是想到了最简单的模拟鼠标事件来实现。 源码（包含2.0的GUI程序和单独的挂机python脚本）：Github 百度云：OnHook 提取码：mc13 脚本很简单的思路——每一轮只需要两次移动和点击事件，识别到开始界面第一次移动并点击开始按钮，识别到结束界面第二次移动点击奖励界面退出去，然后循环。 为了怕被检测封号，需要对这样机械的行为进行一定伪装：比如一次点击事件的点击次数随机1-3次；每次点击的间隔在0.15-0.3s之间随机；每次移动的时间在0.05-0.25s随机；每次点击的像素点坐标在识别到的点击区域中随机等等。不知道有多大用，感觉是跟我个人手动挂的习惯比较相符的==","text":"阴阳师玩家占比最大的行为就是刷魂土了，但作为万年老咸鱼，单刷得12体，500樱饼完全挂不了多少局自动。而手动挂……既然是重复操作，就有办法用自动化脚本来代替，于是想到了最简单的模拟鼠标事件来实现。 源码（包含2.0的GUI程序和单独的挂机python脚本）：Github 百度云：OnHook 提取码：mc13 脚本很简单的思路——每一轮只需要两次移动和点击事件，识别到开始界面第一次移动并点击开始按钮，识别到结束界面第二次移动点击奖励界面退出去，然后循环。 为了怕被检测封号，需要对这样机械的行为进行一定伪装：比如一次点击事件的点击次数随机1-3次；每次点击的间隔在0.15-0.3s之间随机；每次移动的时间在0.05-0.25s随机；每次点击的像素点坐标在识别到的点击区域中随机等等。不知道有多大用，感觉是跟我个人手动挂的习惯比较相符的== python现成的pyautogui库： click(x, y) 函数模拟点击 move(x, y) 函数模拟移动 locateOnScreen(image_path, confidence=0.8) 函数获取指定png图片在当前屏幕状态下的左上角坐标和宽高（这里值得一提的是这个函数默认100%相同才识别，有点苛刻，需要修改参数confidence=0.8差不多。但是这个参数的使用是需要调用cv2这个库的，python的依赖属实==顺带吐槽一下，这个库能一下让后面封装的exe应用程序的大小扩大一倍，pyinstaller出来的exe实在太大了）。 整体代码结构，如果把一整个放到while里，按照顺序死循环识别图片，会导致响应的不够及时。而为每一类图片的识别开一个线程又太奢侈了，于是最终选择了协程——又称为微线程，它是实现多任务的另一种方式，只不过是比线程更小的执行单元（操作系统为了程序运行的高效性，每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作，所以线程的切换非常耗性能。但是协程的切换只是单纯地操作CPU的上下文，一秒钟切换上百万次都不会卡死）。 同样的，python有封装好的非常好用的三方库gevent： spawn(func, info) 函数将生成一个协程并绑定func函数，可带输入信息； 将所有协程加入一个list中，通过 joinall(list) 将存储所有协程的矩阵加入协程池，并开始执行所有协程，当所有协程执行完后返回； sleep(time) 将立即休眠当前线程指定时间。 最后就是组装了。将通过pyautogui库实现的识别指定位置并模拟点击行为封装成函数，在spawn中导入，输入为每一类的图片路径即可实现脚本功能。因为这个函数中写有while(True)，因此每个协程都不会主动停止，需等待外部指令中断运行。 也不知道是不是还没过完以前做上位机时的瘾，，每次写个脚本都想封装成exe配个GUI界面……而我只会qt……PyQt5的封装实在太大了，用了各种方法也没能给它压缩下去==想学一下C#了…… version 1.0 经典老界面，我这审美没救了。 P1：可以选择挂机方案，输入挂机轮数（不输入就是无限挂），主窗口显示每次鼠标行为的信息，停止后返回总挂机轮数和用时。 P2：设置挂机方案，双击编辑方案名和选择该方案所需识别的截图。 P3：截图功能，仿QQ。（这里学到了PyQt一个很重要的函数**paintEvent( )**，超级有用，是实现动态效果的好帮手，帮助实现了2.0版本中不少特效） 这软件单独一个窗口，用起来不方便，也不好看，功能还四不像，跟个缝合怪似的，做完就被我放弃了。。 我老想让一个软件的功能尽可能完善，所以每次能想到的可能会用到的都加进去，就很冗余。。 于是立马着手2.0版本👇 version2.0 嗯，主界面如上图所示，挂在客户端的左上角，面积很小，然后改了改UI，看上去还行哈哈。 设计的灵感来自于炉石的HDT插件（看胜率那个），也是悬挂在炉石界面的顶部，看上去轻便美观，一目了然。 功能介绍： 1.第二块 用于显示挂机成功的轮数，简洁明了~停止后再次开始就会重新计数。 2.第三块 是控制开始结束的按钮，主要绑定了三个事件：1.按钮图标的变化；2.挂机线程的启动/停止；3.时间统计框的弹出/落下。 很简单，每次点击判断状态然后修改图标至相应状态 即可； 这里要注意，挂机脚本的函数内是死循环！也就是说当协程被执行，GUI界面会处于假死状态，无法进行任何的UI交互。因此，使用QThread分出一个子线程用于控制挂机任务，将挂机任务的函数内容重写至QThread的run( ) 函数内即可。这里还要注意，中止时不仅需要杀死这个子线程，同时也需要杀死已加入协程池的所有协程。否则鼠标事件依旧会执行。 这个就是纯UI的设计了，使用了github上的方案pyqt5Custom.Toast类👉pyqt5Custom。 首先是一个水平布局，包含一个icon图标、文本Label和关闭按钮，设置了qss样式（黑色半透明，圆角，按钮default、press、hover等不同样式）。其次是动态升起和落下的特效，这里用到了上述的paintEvent( ) 事件。 这个函数不能被直接调用，而是被动触发的，触发条件为——当窗口需要被重绘时（包含第一次显示）（这里又关联了另一个pyqt5内置函数：update( ) 用于发送窗口绘制事件）。那么动态原理就简单了： 通过在父子类中相互调用彼此的update函数实现循环，不断触发paintEvent，在其中使用setGeometry函数不断的调整这个框的显示位置直至达到预期的显示位置。 控制窗体移动的速度变化：采用先快后慢的变化曲线，在视觉感官上会比较自然舒服。因此选用了在0~1之间呈现此曲线的 y = 1 - (1-x) ^ 4 函数。设置参数speed控制速度快慢，计算每次重绘窗体和开始移动时的时间戳之差t，用 speed * t 作为x的输入，那么随着时间的变化，y的值会逐渐接近1直至达到。最后只需要将：原坐标 +/- (y * 移动距离) 这一数据作为setGeometry的输入，就可以实现移动效果了。 3.第一块 用于打开设置选项，如上图所示。选项中包含挂机方案的选择、创建桌面快捷方式和关闭程序的按钮。 唔，弹出收回的动态效果是对上述Toast类的修改，修改了内部的布局内容和动态弹出的方向。另外在收回时的速度曲线我认为是应该跟上述的 y = 1 - (1-x) ^ 4 关于y=x对称的，即先慢后快，因此修改了曲线函数为 y = x ^ 3。 而GUI界面中所有按钮包括方案的分段按钮组的特效都是在paintEvent( ) 这个函数的基础上来实现的。这个函数真的非常非常的重要！ 设置选项里的按钮们的颜色、背景颜色和动态效果等其实我也没想到什么更好的方案，总觉得怪怪的，但又还行。。就先这样了。 PyQt5这个库我暂时是不想再用了。。因为封装的应用程序实在是太大了。。。好蠢，而且启动速度也很慢……接下来要学C#和C++了，正好也是实验室主用的编程语言~ 不过这个GUI界面我还是比较满意的哈哈哈~就酱 something今天是2022.1.9，从我加入实验室以来已经快一学期了，确实干上了C#相关的活。。。但感觉自定义UI还是Qt香就是说QAQ","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"ID卡与IC卡原理","slug":"ID卡与IC卡原理","date":"2020-08-14T15:27:28.000Z","updated":"2022-11-07T10:39:23.694Z","comments":true,"path":"原理/ID卡与IC卡原理/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/ID%E5%8D%A1%E4%B8%8EIC%E5%8D%A1%E5%8E%9F%E7%90%86/","excerpt":"ID卡（非接触卡）的读卡原理1.简单描述ID卡全称为身份识别卡（Identification Card）,是一种不可写入的感应卡,含固定的编号,主要类型有台湾SYRIS的EM格式，美国HID,TI,MOTOROLA等。 在出厂时，厂家会将ID号写死在芯片的内部，是不允许进行二次修改的。国内常见的型号有EM4100和EM4102。 有别于IC卡这种高频（13.56MHz）、可加密的存储卡，ID卡属于低频（125KHz）的只读卡。 2.读卡流程1.读卡器采用射频识别技术（RFID），持续发射特定频率的射频信号 2.当ID卡进入读卡器工作范围时，将产生感应电流，将自身芯片内的编码信息通过线圈发送出去 3.读卡器接收到从ID卡发送来的调制信号，经过解调后，得到ID卡的编码信息","text":"ID卡（非接触卡）的读卡原理1.简单描述ID卡全称为身份识别卡（Identification Card）,是一种不可写入的感应卡,含固定的编号,主要类型有台湾SYRIS的EM格式，美国HID,TI,MOTOROLA等。 在出厂时，厂家会将ID号写死在芯片的内部，是不允许进行二次修改的。国内常见的型号有EM4100和EM4102。 有别于IC卡这种高频（13.56MHz）、可加密的存储卡，ID卡属于低频（125KHz）的只读卡。 2.读卡流程1.读卡器采用射频识别技术（RFID），持续发射特定频率的射频信号 2.当ID卡进入读卡器工作范围时，将产生感应电流，将自身芯片内的编码信息通过线圈发送出去 3.读卡器接收到从ID卡发送来的调制信号，经过解调后，得到ID卡的编码信息 3.工作原理1.读卡器发送射频信号：推挽式功放电路（放大）+LC谐振电路（选频） + 2.ID卡返回编码信息：负载调制 关于负载调制： 通常使用电阻负载调制，原理图如下： 当芯片工作时，会产生由内部存储的编码信息的数据流（即0和1，也就是高低电平），数据流控制开关s的变化，从而改变右端负载的大小。当数据为1时，s接通，负载变小，品质因数会降低，谐振回路两端电压降低；数据为0时同理。线圈右端的电压变化，通过线圈电感耦合传递给读写器，最终改变读写器两端电压的振幅变化，产生包络。如下图所示： 图中a为原本信号，b为ID卡线圈的电压，c为读卡器收到的未解调的电压信号，而红框中包络即为解调后的信号。 整体过程：当ID卡靠近读卡器，谐振将能量感应到了卡内线圈上，产生电流并对电容进行充电，于是产生了使芯片工作的电源电压。芯片输出存储的数据流，通过负载调制的方式将数据发送给了读卡器。 3.读卡器解调信号获取编码：包络检波+滤波整形 上文中提到读卡器接收到的载波的包络即为我们想要的数据，这些数据的编码方式为曼彻斯特码。要获取这些数据就需要包络检波。 上图为包络检波部分电路，获取到载波的包络部分，但是还需要进行滤波整形获得平滑的直流电压（曼彻斯特码），如下图： 以上电路就是读卡器和ID卡内所需的一些电路。在最后获取到ID卡相应卡号的曼彻斯特码后，只需要对其进行解码即可获得ID卡卡号，并和后台数据对比判断能否通过验证~ 4.曼彻斯特码常见编码方式分为以下几种： 1.NRZ编码（不归零编码）：数据1和0分别用高低电平表示，当一位数据传输完后电平信号不归零。 2.BiPhase编码（双相编码）：每当一位数据传输后，电平跳变一次。 3.曼彻斯特编码：利用信号边沿来表示0和1，并且跳变发生在位帧中间，比如上升沿表示1，下降沿0。 曼彻斯特码的编码 设数据传输的波特率为f，则一个位的时长为1/f，半个位帧的时长为T = 1/2f。 设两个函数RisingEdge(T)和FallingEdge(T)，执行过程如下： RisingEdge(T)：输出低电平，等待T，输出高电平，等待T，返回； FallingEdge(T)：输出高电平，等待T，输出低电平，等待T，返回。 编码的流程如下： 曼彻斯特码的解码 1.获取数据流的波特率 2.同步数据流的时钟信号（区分位帧边沿和半位帧边沿） 3.根据编码原理进行解码即可 5.常见ID卡型号的卡号数据格式（EM4100）EM4100可存储64bits数据，可读不可写，它的数据格式如下： **1.**第一行，是9个“1”，这是EM4100固定的格式 **2.**D00D03，就是第一个ID号，P0代表的是第一行的偶校验（例：0010_1/0001_1/0110_0）当D00D03中0的个数不为偶数时，偶校验置1。P0-P9均为每行前四位的偶校验，ID号共10位 **3.**PC0~PC3为每列（P0-P9）的偶校验，（例：0000000110_0） 4.举个栗子：卡号为06001259E3，转换可得111111111 00000 01100 00000 00000 00011 00101 01010 10010 11101 00110 01000（这一串64位就是曼彻斯特码解码后得到的数据） **5.**在编写程序判断卡号时，应舍弃前63位数据，只取第一次64位码中的停止位0作为开头，以0111111111作为校验开头，判断第二次64位数据中的前63位数据是否符合。同理，判断完后本次的第64位停止位0作为开头再次判断，重复三次，确认卡号正确。 **6.**卡号06001259E3，其中的第一位0为版本号，第二位6为客户号，后面8位为ID号。 7.若卡面有标注卡号，格式一般为0001202659 (18,23011)。分别为ABA码和wiegand26码。ABA码由8位ID号转换成10进制可得，共10位，少位在前补0。wiegand26码这组数据分别为8位ID号的倒数56位和倒数后四位转换成十进制组成。 关于IC卡相比于ID卡，IC卡在目前的应用更加的广泛1、安全性 IC卡的安全性远大于ID卡，ID卡内的卡号读取无任何权限,易于仿制。IC卡内所记录数据的读取，写入均需相应的密码认证,甚至卡片内每个区均有不同的密码保护，全面保护数据安全，IC卡写数据的密码与读出数据的密码可设为不同，提供了良好分级管理方式，确保系统安全。 2、可记录性 ID卡不可写入数据,其记录内容(卡号)只可由芯片生产厂一次性写入，开发商只可读出卡号加以利用，无法根据系统的实际需要制订新的号码管理制度。IC卡不仅可由授权用户读出大量数据，而且亦可由授权用户写入大量数据(如新的卡号，用户的权限，用户资料等)，IC卡所记录内容可反复擦写。 3、存储容量 ID卡仅仅记录卡号；而IC卡(比如Philips mifare1卡)可以记录约1000个字符的内容 4、脱机与联网运行 由于ID卡卡内无内容，故其卡片持有者的权限，系统功能操作要完全依赖于计算机网络平台数据库的支持。 而IC卡本身已记录了大量用户相关内容(卡号，用户资料，权限，消费余额等大量信息)，完全可以脱离计算机平台运行,实现联网与脱机自动转换的运行方式，能够达到大范围使用，少布线的需求。 5、一卡通扩展应用 ID卡由于无记录,无分区,只能依赖网络软件来处理各子系统的信息,这就大大增加对网络的依赖；如果在ID卡系统完成后,用户欲增加功能点，则需要另外布线,这不仅增加了工程施工难度,而且增加了不必要的投资.所以说,使用ID卡来做系统,难以进行系统扩展,难以实现真正的一卡通。 而IC卡存储区自身分为16个分区，每个分区有不同的密码,具有多个子系统独立管理功能，如第一分区实现门禁，第二分区实现消费,第三分区实现员工考勤等等。充分实现一卡通的目的,并且可以做到完全模块化设计，用户即使要增加功能点，也无需再布线,只需增加硬件和软件模块，这便于IC卡系统以后的随时升级扩展,实现平稳升级,减少重复投资。 6、智能化系统的维护和运行 比如：电脑发行了一张新的用户ID卡,就必须通过ID卡系统的网络,用人工方式将所有ID卡号一个个下载到各ID卡读卡控制器中，否则ID卡被作为无效卡而不能使用;若要更改用户权限，则需在每个ID卡控制器上输入有权限的ID卡号。 又比如：在系统投入使用后经常要新增ID卡,则每新增一张卡或修改了某一张卡片的权限,就必需在该卡可用的所有控制器上输入该卡片号码，这就增加了工作量 关于手机NFC功能苹果手机仅支持apple pay，门禁、公交等功能并不支持。小米还是香嗷。 在b站看到稚晖大佬做了一个可以存储多张ic卡信息的小卡片，开源了👉L-ink_Card 以后有机会想自己实现一哈","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"}]},{"title":"关于url编码","slug":"关于url编码","date":"2020-05-20T14:20:46.000Z","updated":"2022-11-07T10:39:23.769Z","comments":true,"path":"原理/关于url编码/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Eurl%E7%BC%96%E7%A0%81/","excerpt":"为什么需要URL编码1.URL 只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。这意味着 如果URL中有汉字，就必须编码后使用。但问题在于，标准的国际组织并没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这会导致”URL编码”成为了一个混乱的领域。 2.对于get传参的网页来说，采取的是如下方式 ( ? key = value ) 问题在于，若是传的参数中包含？和=怎么办，就冲突了，所以需要编码以区分 http:&#x2F;&#x2F;www.biquge.tv&#x2F;modules&#x2F;article&#x2F;search.php?searchkey&#x3D;xxx","text":"为什么需要URL编码1.URL 只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。这意味着 如果URL中有汉字，就必须编码后使用。但问题在于，标准的国际组织并没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这会导致”URL编码”成为了一个混乱的领域。 2.对于get传参的网页来说，采取的是如下方式 ( ? key = value ) 问题在于，若是传的参数中包含？和=怎么办，就冲突了，所以需要编码以区分 http:&#x2F;&#x2F;www.biquge.tv&#x2F;modules&#x2F;article&#x2F;search.php?searchkey&#x3D;xxx 如何进行URL编码Url编码通常也被称为百分号编码（percent-encoding），编码方式非常简单。 使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。 对于ASCII字符，字母a 在ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，字母abc， url编码后得到的就是%61%62%63。 对于非ASCII字符，在无BOM编码格式中有UTF-8和GBK两种。 1.”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到”%E4%B8%AD%E6%96%87”。 2.“中文”使用GBK编码得到 %D6%D0%CE%C4。 注意一定要先进行编码再向服务器提交，这样可以保证只使用了固定的一种编码方式。 python中的URL编码与解码封装成以下库： 编码和解码的调用： 小说爬取爬小说的脚本写的时候没碰到什么别的问题，就是一个编码的问题，之前不了解，所以写了这篇文章码一下。 在用爬虫向网页提交搜索信息（小说名字）的时候： http:&#x2F;&#x2F;www.biquge.tv&#x2F;modules&#x2F;article&#x2F;search.php?searchkey&#x3D;%bd%a3%c0%b4 需要用到URL编码来提交（因为我爬的那个网站用的是get方式提交信息，并且是GBK编码）","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]},{"title":"关于RSA加密算法","slug":"关于RSA加密算法","date":"2020-05-16T14:27:37.000Z","updated":"2022-11-07T10:39:23.766Z","comments":true,"path":"原理/关于RSA加密算法/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8ERSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"RSA是目前使用最广泛的公钥密码体制之一。 RSA产生公私钥对1.随机选取两个相近但不相等的质数p和q（越大越难破解） 取p=11，q=13，n = p * q = 143，n即为密钥长度，143二进制为10001111，密钥为8位。实际应用中，一般为1024位。 2.计算n的欧拉函数z z = (p-1)(q-1) = 120 3.随机选择一个整数e，作为公钥中用来加密的数字 条件1 &lt; e &lt; z，且e与z互质。假设随机选择e = 7（实际中常选择为65537） 4.计算e对于z的模反元素d，作为密钥中用来解密的数字 模反元素指存在一个整数d，使得e * d mod z = 1。带入可得d = 103 5.将n和e封装成公钥（143，7），n和d封装成密钥（143，103）","text":"RSA是目前使用最广泛的公钥密码体制之一。 RSA产生公私钥对1.随机选取两个相近但不相等的质数p和q（越大越难破解） 取p=11，q=13，n = p * q = 143，n即为密钥长度，143二进制为10001111，密钥为8位。实际应用中，一般为1024位。 2.计算n的欧拉函数z z = (p-1)(q-1) = 120 3.随机选择一个整数e，作为公钥中用来加密的数字 条件1 &lt; e &lt; z，且e与z互质。假设随机选择e = 7（实际中常选择为65537） 4.计算e对于z的模反元素d，作为密钥中用来解密的数字 模反元素指存在一个整数d，使得e * d mod z = 1。带入可得d = 103 5.将n和e封装成公钥（143，7），n和d封装成密钥（143，103） 题外话：关于m^e mod n的手动计算方法利用 (a×b) mod m = ((a mod m) × (b mod m)) mod m 这个公式 设三个变量a，b，c，对于m^e mod n，令a = e,b = m, c = 1 然后重复以下步骤： 1.判断a是奇数，进第2步；偶数进第3步 2.a = a - 1, c = (c*b) mod n,回到第1步 3.a = a / 2, b = (b*b) mod n,回到第1步 直到a = 0, c 就是最终结果 RSA的加密和解密加密：c = m^e mod n 解密：m = c^d mod n 首先对明文进行比特串分组，且保证每个分组对应的十进制数小于n，然后对每个分组进行一次加密，所有分组的密文组成的序列就是最终密文了。 举两个栗子： 1.以数据加密为例： 甲向乙发送机密数据信息m=85，并已知乙的公钥(n,e)=(143,7)，于是可计算出：c = 123甲将c发送至乙，乙利用私钥(n,d)=(143,103)对c进行计算：m = 85则乙得到甲向其要发送的机密数据信息。甲向乙发送信息，甲所拥有的仅仅是乙的公钥。 2.以数字签名为例： 乙要向甲发送信息，并要让甲确信此信息是由乙本人所发出的，于是，乙将能代表自己身份的编码值（如：123），利用私钥(n,d)=(143,103)进行计算，并将结果发送给甲：m = 85甲接受到乙的数字签名后利用乙的公钥(n,e)=(143,7)进行计算，得出代表乙身份的编码：c = 123现甲经过验证已确信信息的发送方为乙。因为只有乙拥有私钥(n,d)，来对代表自己身份的编码123进行计算。在这里，乙向甲发送信息并进行签名，甲所拥有的也仅仅是乙的公钥来验证乙的签名。 RSA实际应用在基于序列号保护的共享软件中应用RSA。 在某一共享软件中，甲想用123为注册名进行软件注册，他现在拥有的仅仅是存在于共享软件程序中的公钥(n,e)=(143,7)。 甲现将123为注册名向乙提出注册申请，乙得知此申请并通过此申请后，便利用所拥有的私钥(n,d)对注册名123进行计算：m = 85 甲得到计算后的结果85（序列号），提供给共享软件的注册程序进行计算：c = 123 然后注册程序将判断计算结果c是否为123（注册名），以决定注册是否通过。 如果甲随意输入一组序列号利用公钥(n,e)进行计算，那他得到的结果将不是123，注册也就失败了。注意，在这里，共享软件的注册程序比较的是注册名，而不是序列号。 如果甲跟踪注册程序得到了他所随意输入的序列号所产生的注册名，将其提供给注册程序，那注册程序也能够通过注册，但他由于没有(n,d)，所以他无法用自己的注册名进行软件注册，也就防止了非法注册机的制作。 将RSA应用于此的目的仅仅是防止非法注册机的制作，在以上描述中，n=143，包括以下Demo中的n(HEX)=963251DC5A9C90D9F203A03C363BA411，以现在的计算机处理速度，能很快地将其因式分解得到相应的p，q，再结合暴露在共享软件注册程序中的e，从而计算出d，那么这个共享软件的保护就完全被破解了。解决的方法是要避免n过短，以及结合MD5等加密算法……","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]},{"title":"获取bilibili视频文件和封面","slug":"获取bilibili视频文件和封面","date":"2020-04-30T15:27:07.000Z","updated":"2022-11-07T10:39:23.779Z","comments":true,"path":"应用/获取bilibili视频文件和封面/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/%E8%8E%B7%E5%8F%96bilibili%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E5%92%8C%E5%B0%81%E9%9D%A2/","excerpt":"前两天在阿草微博粉丝群水群的时候，看到有朋友说馋想要一个往期视频的封面，但不知道咋保存~（网上有封面提取的网站） 我一想，应该可以用爬虫去实现嘛，挺有意思的，就尝试着写了一下，链接如下👇 获取b站视频封面 （现在挂在我的云服务器上，但等到过期了就寄了，GitHub Page并不支持php。话说当初学php就是因为在云服务器上建站用的WordPress，想改别人的主题但是看不懂代码才去学的） 三项功能： 输入视频的网址、BV号获取AV号（AV号明面上已经被b站禁了，但后台实际还在）； 输入视频的网址、BV号、AV号获取视频封面； 输入up主的UID获取该up主所有视频的封面，并打包成zip文件下载。","text":"前两天在阿草微博粉丝群水群的时候，看到有朋友说馋想要一个往期视频的封面，但不知道咋保存~（网上有封面提取的网站） 我一想，应该可以用爬虫去实现嘛，挺有意思的，就尝试着写了一下，链接如下👇 获取b站视频封面 （现在挂在我的云服务器上，但等到过期了就寄了，GitHub Page并不支持php。话说当初学php就是因为在云服务器上建站用的WordPress，想改别人的主题但是看不懂代码才去学的） 三项功能： 输入视频的网址、BV号获取AV号（AV号明面上已经被b站禁了，但后台实际还在）； 输入视频的网址、BV号、AV号获取视频封面； 输入up主的UID获取该up主所有视频的封面，并打包成zip文件下载。 获取封面1.爬取图片的脚本如何找到b站视频的相关信息和封面图片的源网址呢？ 关于封面图最开始学爬虫的朋友们应该都爬过豆瓣top250这个经典案例。 在body里找到img属性，里面的src就是图片的原链接了。但是要注意到一点，这里图片源文件的后缀：webp。这是一种有损压缩格式图片，优势在于网络传输快，但爬取视频封面是为了什么！是为了高清图啊！所以不能这么爬。 在个人主页中，可以通过选取工具定位到img标签，发现src里的也是webp格式图片 打开链接图片很糊而且像素低。那么问题来了，哪里有高清的呢！答案就在视频界面里。 不在body中！因为视频界面并没有显示封面图片！而是在head中！找到属性（itemprop）为image的，发现content中的链接，后缀为jpg格式，这就找对了，打开发现确实是高清图 链接位置找到了，剩下的就简单了~就不多说了。 关于AV号之前b站因为av号名称违规（？）改为了BV号，但是av号并没有完全删除，在b站中搜索视频av号同样能获取视频，这说明av号这项数据依旧保存着，那如何找出该数据呢？在b站的数据接口。 打开解析器network选项，可以看到该视频数据接口的url。archive（档案）后面的内容aid同理可以替换成bvid 可以看到该网址返回的是一串json数据，里面包含了av、bv、投币、收藏、点赞、分享、评论、观看数、这些数据，在这里便可以获取到AV号了，在就脚本中解析该json数据然后提取就可以显示在网页中了。 而个人空间同样拥有数据接口保存了该页所有视频的标题、简介、bv等信息，也可以获取下来，不再赘述。 2.py脚本与php的数据交互py文件如何向php文件传值？ ajax如何获取php文件的传值？php中如何调用py脚本？ 传值其实很简单，，就是打印函数，python 的print和php 的echo。 调用py脚本，用exec函数： $c &#x3D; exec(&quot;&#x2F;usr&#x2F;bin&#x2F;python GetBilibiliUpCover.py &#123;$func&#125; &#123;$uid&#125; &#123;$bv&#125;&quot;); exec用于执行一个外部程序，主体为执行命令，可以附带参数传递，输出数组和状态返回。因为程序要在服务器里运行，所以输入的就是ubuntu的命令行了，ubuntu怎么运行python脚本就怎么来。 后面的三个是输入参数。在python中通过如下方式获取： sys.argv[1] argv是一个数组，第一位是模块的名称，这里不去管他，从1开始是按序输入的参数，这里输入了三个，就分别用1、2、3来获取就行。 3.前后端数据交互本半吊子表示根本没系统学过前端知识，所以做这一部分的时候异常痛苦，，界面也丑的一言难尽== 用的ajax，但一开始死都进不去succes步，总进error。。 $.ajax(&#123; type : &quot;GET&quot;, url : &quot;getting.php&quot;, data : &#123; &#39;func&#39;:$(&quot;#f1&quot;).val(), &#39;bv&#39;:$(&quot;#av_info&quot;).val() &#125;, dataType : &quot;text&quot;, success : function(msg) &#123; $(&quot;#result&quot;).empty(); document.getElementById(&quot;dynamic_av&quot;).style.display &#x3D; &quot;&quot;; var data &#x3D; &#39;&#39;; if (msg !&#x3D; &#39;&#39;)&#123; data &#x3D; eval(&quot;(&quot;+msg+&quot;)&quot;); &#125; $(&quot;#result_av&quot;).html(&quot;AV号: &quot; + data.av); &#125;, error: function (msg, textStatus) &#123; console.log(msg); &#125; &#125;); 后来发现一开始数据类型用的json，网上说必须要非常标准的json数据才能接收到，我也不明白为什么我在py文件里封装的json数据就不行。。。 后来就改成text，文本用eval转化一下提取出来就解决了。 获取视频文件首先进F12，看一下： 可以看到视频源文件这边并不是mp4的源文件，而是开头带了blob：的链接，是无法访问的（暂时不了解这方面的技术，所以找了个取巧的办法） 点击开发者工具的左上角，切换为手机模拟状态，可以看到： 手机端的src不再是blob了，而是变成了这样一个url，打开即可下载mp4源文件了~舒服！","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.hanhan0223.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"第一次笔记本拆机体验","slug":"第一次笔记本拆机体验","date":"2020-04-13T14:38:42.000Z","updated":"2022-11-07T10:39:23.776Z","comments":true,"path":"杂记/第一次笔记本拆机体验/","link":"","permalink":"https://www.hanhan0223.cn/%E6%9D%82%E8%AE%B0/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8B%86%E6%9C%BA%E4%BD%93%E9%AA%8C/","excerpt":"小的时候总觉得电脑是个很神奇很牛掰的东西，虽然后来对电脑的构成还有运行原理等有了一个大致的了解，但依旧玄乎中带一点敬仰（奇怪的用词）。前段时间给母亲大人配了一台台式，自己亲自买了各种组件，组装起来后才发现其实真没什么难度。。基本是熟练度和经验的关系了。不过这倒是让我对电脑组成和运行有了更深刻的认识~ 恰巧我的笔记本最近也毛病重重（贼卡），于是在我的一位同学祝大师（sdl，wsl）的帮助下，对电脑运行的CPU占用率、硬盘测速、甜甜圈视频输出、内存延时、模具散热、坏道检测等多项数据进行了测试。发现了唯一的问题在于机械盘坏道有点多（跑了1%就有几十柱坏道，神奇，讲道理坏成这样应该经常会卡死，而我只是运行慢一些。。） 然后开始拆机~清灰，然后取出机械硬盘在台式机进行一些测试。","text":"小的时候总觉得电脑是个很神奇很牛掰的东西，虽然后来对电脑的构成还有运行原理等有了一个大致的了解，但依旧玄乎中带一点敬仰（奇怪的用词）。前段时间给母亲大人配了一台台式，自己亲自买了各种组件，组装起来后才发现其实真没什么难度。。基本是熟练度和经验的关系了。不过这倒是让我对电脑组成和运行有了更深刻的认识~ 恰巧我的笔记本最近也毛病重重（贼卡），于是在我的一位同学祝大师（sdl，wsl）的帮助下，对电脑运行的CPU占用率、硬盘测速、甜甜圈视频输出、内存延时、模具散热、坏道检测等多项数据进行了测试。发现了唯一的问题在于机械盘坏道有点多（跑了1%就有几十柱坏道，神奇，讲道理坏成这样应该经常会卡死，而我只是运行慢一些。。） 然后开始拆机~清灰，然后取出机械硬盘在台式机进行一些测试。 拆机简录 首先把四周的螺丝拧开~然后掰开后盖。因为后盖四周带有卡扣固定，所以在掀开的过程中需要拿螺丝刀一点一点的撬开。注意到上图中左右两个网格状的梯形，里面有两坨圆形的灰色，这都是灰，因为这两个网格正对电脑的散热风扇，久而久之在散热过程中就积灰了。 最后掀开，如下： 上图中左右上角是风扇，可以看到积灰很多。风扇上面是散热管，它与风扇之间的缝隙同样是积灰非常严重的地方，需要清理。 中间蓝色是主板，主板上面那块绿色就是内存条，我的是一根8g的（反正也要换硬件，顺便再加个8g内存条？） 右边风扇下面的绿色是固态硬盘（当时配的128g，这次打算换成256g，我c盘就剩12G了，括个容），用作电脑的系统盘存储。 左边风扇下面那块蓝青色板子就是机械硬盘了（配的1T，叠瓦的据说坏的快，在犹豫换1T的机械还是固态，，价格差了五六百，但固态体验要好很多） 机械盘右上角那一小块贴了白色标签的就是无线网卡 右下方那一大块是电池了，图里已经拆了~ 拆下之后对积灰的缝隙，风扇的缝隙进行了清理，顿时感觉舒爽了很多hhhh 问题测试取下机械硬盘，接到我家台式机上，在里面下了个300英雄打了一把人机，发现流畅的一批，，惊了 又接回来进入ubuntu系统，跑了一下pycharm，，还是很流畅 大概是系统问题，，，遇事不决重装系统~ 后续 京东物流是真的快！当晚9点多下单，第二天上午就到了！1TB的SSD硬盘，SATA接口（换机械的），打折799. 然后是数据转移！ 把原来的机械盘和新的固态盘都接到我家台式机上，先格式化好新盘，转gpt分区。我用了DiskGenius的磁盘克隆功能，一键复制分区和数据（大概三个小时左右，我1T基本用满了），然后就搞定啦。 剩下的机械盘格式化了塞家里电脑凑合用着，舒服！ 把固态塞进笔记本，开机，测试了一下软件启动速度，真香！","categories":[{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"},{"name":"硬件","slug":"硬件","permalink":"https://www.hanhan0223.cn/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"PyQt5再尝试:Windows桌面便笺","slug":"PyQt5再尝试-Windows桌面便笺","date":"2020-04-08T14:50:34.000Z","updated":"2022-11-07T10:39:23.702Z","comments":true,"path":"应用/PyQt5再尝试-Windows桌面便笺/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E5%86%8D%E5%B0%9D%E8%AF%95-Windows%E6%A1%8C%E9%9D%A2%E4%BE%BF%E7%AC%BA/","excerpt":"考研党给自己制定了每日计划去执行，但是市面上的桌面便笺软件都不是很合我胃口，于是花了一个礼拜多点，完成了这款完全按照我自己心意来的桌面便笺，用起来相当舒心、顺手嘿嘿。 国际惯例贴上源代码、以及软件下载链接~ GitHub：memo-master 百度网盘：memo 提取码：61uy Version：1.0 【2020.4.8】","text":"考研党给自己制定了每日计划去执行，但是市面上的桌面便笺软件都不是很合我胃口，于是花了一个礼拜多点，完成了这款完全按照我自己心意来的桌面便笺，用起来相当舒心、顺手嘿嘿。 国际惯例贴上源代码、以及软件下载链接~ GitHub：memo-master 百度网盘：memo 提取码：61uy Version：1.0 【2020.4.8】 先上图~ 主图标选择了我非常喜欢的滑稽表情~ 灯泡是用来展开、隐藏下边菜单栏的开关~ 菜单栏分别是新建一个便笺、设置（字体样式，便笺样式等）以及关于（软件的简单使用tips） 右边就是建的一个个便笺了~ 功能简介： 双击可以修改内容（目前无法使用删除键，修改方式为鼠标全选后直接输入文本，待debug） 右边按钮为当日完成情况，初始化为X，点击表示完成√ 删除：拖动单条便笺到主图标滑稽上，松开鼠标即可删除 按~键（ESC下面）即可最小化至托盘 拖动主图标即可拖动整个便笺软件移动 对便笺样式以及内容的修改信息均会保存，在下次启动时直接调用~ 主图标以及各种按钮的图标均可找自己喜欢的图片修改（要求：png图片、背景透明（怎么弄透明百度有教程，可网站上在线生成也可ps自己弄）、将处理好的图片与想改的图标做替换（文件名要相同）） 因为在x64系统下封装，仅适用于x64系统，linux和Windows x32目前不支持~ 关于里面的介绍是之前写的，忘改了，，下版再说吧，懒得重新改 对于下版的一些想法： 1.优化UI、以及界面控制，修复一些按键bug 2.添加时间数据，记录计划的创建、删除时间以及每天完成情况；每日0：00更新所有便笺状态为X 3.添加数据分析功能，生成统计文件。哦甚至一键生成统计图表（？这个好像有点麻烦，，得慢慢来） 4.添加一键换图标功能（仅需上传png图片） 5.想和网站做点联动，但不知道做啥==下版见 就酱~ Version：1.1 【2020.4.24】1.1版本搞定！ 1.优化了设置和关于界面的UI 2.添加了主图标右键可以打开菜单栏操作功能 3.新增部分设置选项（置顶功能设置、勾选重启以创建桌面快捷方式、边缘自动隐藏功能） 4.完善了每个便笺个体的信息保存，软件在下一天启动时所有便笺状态归于未完成 5.删除了任务栏图标，只保留托盘图标了 6.更新了数据统计功能，从整体和个体角度分析完成情况 7.新增简单的一键换肤功能（不提倡，建议ps手动修图手动在img文件夹下替换） 8.关于与个人网站的联动，会做一个内测版本，将我每日的学习进度展示在我的个人网站上~暂时不打算封装起来 这个小项目就告一段落了~~ 接下来的安排基本以考研为主了，以算法题为主要练习对象，偶尔有需求再写点脚本什么的~ Version：1.2 【2020.6.6】1.新增了倒计时功能，置于电脑屏幕正上方，右键为设置（内容和结束时间）、隐藏。隐藏后可在菜单栏打开。 2.新增了版本检测以及自动更新功能（有一点小bug没解决，点更新会跳cmd框并且更新时鼠标操作其他地方进度条的显示会卡死，但是不影响更新的）。更新后再次点击图标重启（重启才会删除旧版本，我没封装成正式软件，也没解决父子进程独立的问题，用的更新方法比较简单~） 3.修复了个别显示以及数据统计的小bug~ 唔，越来越感觉这软件粗制滥造了hhhh，等我有空研究一下软件构造方面的知识之后再重构一遍~ Version：2.0【2022.1.9】没想到，这小玩意儿最后居然被我拿来当毕设了。。就挺水的== 当时为了凑毕设字数就重构了一遍代码（UI与逻辑分离之类的），但是时间比较紧，也没重构完。。所以也就没更新 现在把博客从云服务器迁到github上，才想起来这回事儿。。有空搞搞？（十有八九是没下文了）","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"}]},{"title":"PyQt5初尝试:Unicode转换器","slug":"PyQt5初尝试-Unicode转换器","date":"2020-03-07T14:46:57.000Z","updated":"2022-11-07T10:39:23.705Z","comments":true,"path":"应用/PyQt5初尝试-Unicode转换器/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E5%88%9D%E5%B0%9D%E8%AF%95-Unicode%E8%BD%AC%E6%8D%A2%E5%99%A8/","excerpt":"Unicode转换器Version 1.1.0 【2020.3.7】最近玩阴阳师的时候接触到一位大哥写的御魂hub网站，里面通过对json文件的解析来实现了大量御魂配置的计算，省去了手动配置的无限痛苦！！！超级好用！！！ ❤❤❤ 另外有个软件可以从阴阳师桌面版中提取出账号中所有的御魂信息并集合成一个json文件，恰巧最近几天尝试了简单的python爬虫，在爬取动态信息时同样涉及到了json~~这让我对json产生了兴趣。于是今天下午尝试着解析Unicode为字符串，集成在小软件里。","text":"Unicode转换器Version 1.1.0 【2020.3.7】最近玩阴阳师的时候接触到一位大哥写的御魂hub网站，里面通过对json文件的解析来实现了大量御魂配置的计算，省去了手动配置的无限痛苦！！！超级好用！！！ ❤❤❤ 另外有个软件可以从阴阳师桌面版中提取出账号中所有的御魂信息并集合成一个json文件，恰巧最近几天尝试了简单的python爬虫，在爬取动态信息时同样涉及到了json~~这让我对json产生了兴趣。于是今天下午尝试着解析Unicode为字符串，集成在小软件里。 python也只是刚入门，所以目前只实现了这一点点小功能。效果图如下👇 源代码我上传到GitHub了非常简单的两个小文件 戳这里去star吧👇https://github.com/shen962806862/Unicode-Chinese 另外我也生成了单独的exe文件，可以直接使用 👇https://pan.baidu.com/s/1G1BLW82elUwAee7DSpzQqA 提取码：9qfw 接下来会有2.0版本，打算尝试实现txt文件与json文件的相互转换√ Version 2.0.0 【2020.3.8】弄了一晚上！更新更新！船新版本！ 新增功能： 1.实现了Json文件与txt文件的相互转换，可以快速阅读json文件中的信息了 2.当你添加一个文件后，打开添加文件夹选项，可以自动锁定到输入文件的地址了 2.5.转换生成的文件名与输入文件相同 3.优化了UI界面，实现了窗口自适应 4.优化了数据窗口，滚动条可以自动滑至文本末了 源码和软件链接依旧同上，里面存了所有更新版本的内容~ 大致搞定了第一个python制作小软件了接下来的话打算抽空做一个桌面便笺了敬请期待","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]}],"categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"},{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"},{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"},{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://www.hanhan0223.cn/tags/javascript/"},{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.hanhan0223.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://www.hanhan0223.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"图像","slug":"图像","permalink":"https://www.hanhan0223.cn/tags/%E5%9B%BE%E5%83%8F/"},{"name":"环境","slug":"环境","permalink":"https://www.hanhan0223.cn/tags/%E7%8E%AF%E5%A2%83/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.hanhan0223.cn/tags/python%E7%88%AC%E8%99%AB/"},{"name":"硬件","slug":"硬件","permalink":"https://www.hanhan0223.cn/tags/%E7%A1%AC%E4%BB%B6/"}]}