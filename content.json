{"meta":{"title":"小涵的米奇妙妙屋","subtitle":"","description":"","author":"Szh","url":"https://www.hanhan0223.cn","root":"/"},"pages":[{"title":"分类","date":"2022-01-08T09:17:16.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"categories/index.html","permalink":"https://www.hanhan0223.cn/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-01-07T11:49:11.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"about/index.html","permalink":"https://www.hanhan0223.cn/about/index.html","excerpt":"","text":"​ 杭电计算机研一在读。 ​ 摸鱼时间搭个静态网站，学习一下前端相关的东西（主要是云服务器要到期了，没折扣续不起了==）。 ​ To be continued …"},{"title":"标签","date":"2022-01-08T09:15:58.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"tags/index.html","permalink":"https://www.hanhan0223.cn/tags/index.html","excerpt":"","text":""},{"title":"我焯!原!","date":"2022-08-23T15:54:17.000Z","updated":"2022-11-07T10:39:23.803Z","comments":true,"path":"scripts/genshin/index.html","permalink":"https://www.hanhan0223.cn/scripts/genshin/index.html","excerpt":"","text":"查询原神面板"}],"posts":[{"title":"WebServer项目笔记","slug":"WebServer项目笔记","date":"2023-07-11T15:04:11.000Z","updated":"2023-08-21T15:05:58.762Z","comments":true,"path":"应用/WebServer项目笔记/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/WebServer%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/","excerpt":"WebServer项目理论知识互斥锁在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。例如，同一个文件，可能一个线程会对其进行写操作，而另一个线程需要对这个文件进行读操作。如果写线程还没有写结束，而此时读线程开始了，或者读线程还没有读结束而写线程开始了，那么最终的结果显然会是混乱的。 在多线程中使用互斥锁（mutex）保护共享资源。互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态，即上锁（lock）和解锁（unlock）。 特点 原子性：把一个互斥量锁定为一个原子操作，这意味着如果一个线程锁定了一个互斥量，没有其他线程在同一时间可以成功锁定这个互斥量； 唯一性：如果一个线程锁定了一个互斥量，在它解除锁定之前，没有其他线程可以锁定这个互斥量； 非繁忙等待：如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。 创建与初始化","text":"WebServer项目理论知识互斥锁在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。例如，同一个文件，可能一个线程会对其进行写操作，而另一个线程需要对这个文件进行读操作。如果写线程还没有写结束，而此时读线程开始了，或者读线程还没有读结束而写线程开始了，那么最终的结果显然会是混乱的。 在多线程中使用互斥锁（mutex）保护共享资源。互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态，即上锁（lock）和解锁（unlock）。 特点 原子性：把一个互斥量锁定为一个原子操作，这意味着如果一个线程锁定了一个互斥量，没有其他线程在同一时间可以成功锁定这个互斥量； 唯一性：如果一个线程锁定了一个互斥量，在它解除锁定之前，没有其他线程可以锁定这个互斥量； 非繁忙等待：如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。 创建与初始化创建 在使用互斥锁之前，需要先创建一个互斥锁的对象。 互斥锁的类型是 pthread_mutex_t ，这是一个联合体，存储了互斥锁的相关信息，所以定义一个变量就是创建了一个互斥锁。 #include &lt;pthread.h&gt; pthread_mutex_t _mutex; 初始化 有两种方式，第一种是调用函数。 pthread_mutex_init(&amp;_mutex，NULL); &#x2F;&#x2F; 第二个参数为 NULL，则互斥锁的属性会设置为默认属性 第二种是使用宏定义初始化赋值，因为这个互斥锁变量本质就是个联合体。 # define PTHREAD_MUTEX_INITIALIZER \\ &#123; &#123; 0，0，0，0，0，0，&#123; 0，0 &#125; &#125; &#125; &#x2F;&#x2F; 在 pthread.h 中，对该宏的定义 pthread_mutex_t _mutex &#x3D; PTHREAD_MUTEX_INITIALIZER; 上锁阻塞调用 pthread_mutex_lock(&amp;mtx); 如果这个锁此时正在被其它线程占用， 那么 pthread_mutex_lock() 调用会进入锁的排队队列中，并进入阻塞状态， 直到拿到锁之后才会返回。若该锁此时已被当前线程占用，则会发生死锁。 非阻塞调用 若不想阻塞，只想尝试获取一下，锁被占用就不用，没被占用就用， 可以使用 pthread_mutex_trylock() 函数。 这个函数和 pthread_mutex_lock() 用法一样，只不过当请求的锁正在被占用的时候， 不会进入阻塞状态，而是立刻返回，并返回一个错误代码 EBUSY。若该锁此时已被当前线程占用，同样会发生死锁。 if(0 !&#x3D; pthread_mutex_trylock(&amp;_mutex)) &#123; &#x2F;&#x2F;The mutex could not be acquired because it was already locked. &#125; 超时调用 如果不想不断的调用 pthread_mutex_trylock() 来测试互斥锁是否可用， 而是想阻塞调用，但是增加一个超时时间，可以使用 pthread_mutex_timedlock() 来实现： struct timespec &#123; __time_t tv_sec; &#x2F;* Seconds。 *&#x2F; long int tv_nsec; &#x2F;* Nanoseconds。 *&#x2F; &#125;; struct timespec abs_timeout; abs_timeout.tv_sec &#x3D; time(NULL) + 1; abs_timeout.tv_nsec &#x3D; 0; if(0 !&#x3D; pthread_mutex_timedlock(&amp;_mutex，&amp;abs_timeout)) &#123; &#x2F;&#x2F;The mutex could not be locked before the specified timeout expired. &#125; 阻塞等待线程锁，但只等待1秒钟，1秒钟后若还未拿到锁， 就返回一个错误代码 ETIMEDOUT。 注意的是，这个函数里面调用的时间是绝对时间，所以这里用 time() 函数返回的时间增加了 1 秒。 解锁pthread_mutex_unlock(&amp;_mutex); 销毁pthread_mutex_destroy(&amp;_mutex) 被销毁的线程锁可以被再次初始化使用。 对一个处于已初始化但未锁定状态的线程锁进行销毁是安全的。尽量避免对一个处于锁定状态的线程锁进行销毁操作。 std::mutex本质就是对 pthread.h 中的 pthread_mutex_t 的封装。 class mutex &#123; pthread_mutex_t _M_mutex; public: mutex() &#123; _M_mutex &#x3D; PTHREAD_MUTEX_INITIALIZER; &#125; ~mutex() &#123; pthread_mutex_destroy(&amp;_M_mutex); &#125; void lock() &#123; pthread_mutex_lock(&amp;_M_mutex); &#125; bool try_lock() &#123; return pthread_mutex_trylock(&amp;_M_mutex) &#x3D;&#x3D; 0; &#125; void unlock() &#123; pthread_mutex_unlock(&amp;_M_mutex); &#125; &#125; 信号量函数除了初始化之外，其余的函数使用基本类同上述互斥锁： 初始化：int sem_init (sem_t *sem，int pshared，unsigned int value) sem为指向信号量结构的一个指针；pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；value给出了信号量的初始值。 销毁： int sem_destroy(sem_t *sem) 信号增量：int sem_post( sem_t *sem ) 用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。 信号等待：同互斥锁，含有阻塞、非阻塞、定时阻塞三个版本 int sem_wait( sem_t *sem ); int sem_trywait( sem_t *sem ); int sem_timedwait(sem_t *sem，const struct timespec *abs_timeout); 以上函数调用成功均会返回0。 封装class SemS &#123; public: SemS() &#123; sem_init(&amp;_sem，0，0); &#125; SemS(int val) &#123; sem_init(&amp;_sem，0，val); &#125; ~SemS() &#123; sem_destroy(&amp;_sem); &#125; bool wait() &#123; sem_wait(&amp;_sem) &#x3D;&#x3D; 0; &#125; bool post() &#123; sem_post(&amp;_sem) &#x3D;&#x3D; 0; &#125; private: sem_t _sem; &#125;; 条件变量 条件变量是线程可用的另一种同步机制 条件变量给多个线程提供了一个会合的场所 条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生 使用场景 条件变量要与互斥量一起使用，条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量 其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件 函数condition的函数使用也与互斥锁的使用基本类似。 等待条件变量 int pthread_cond_wait(pthread_cond_t* restrict cond,pthread_mutex_t* restrict mutex); int pthread_cond_timedwait(pthread_cond_t* cond,pthread_mutex_t* restrict mutex,const struct timespec* restrict tsptr); 参数mutex互斥量提前锁定（使用mutex的lock函数），然后该互斥量对条件进行保护，等待参数cond条件变量变为真。在等待条件变量变为真的过程中，此函数一直处于阻塞状态。但是处于阻塞状态的时候，mutex互斥量被解锁（因为其他线程需要使用到这个锁来使条件变量变为真） 当pthread_cond_wait函数返回时，互斥量再次被锁住 发送信号 int pthread_cond_signal(pthread_cond_t* cond); int pthread_cond_broadcast(pthread_cond_t* cond); 这两个函数用于通知线程条件变量已经满足条件（变为真）。调用这两个函数时，是在给线程或者条件发信号。 常用方法lock(&amp;mutex); while(value&lt;&#x3D;0) &#x2F;&#x2F; 需要value &gt; 0 所以 value &lt;&#x3D; 0 就条件不满足 pthread_cond_wait(&amp;cond，&amp;mutex); unlock(&amp;mutex); 这里在等待时用的while，是为了防止虚假唤醒。signal原本意图是唤醒一个等待的线程，但是在多核处理器下，可能会激活多个等待的线程，导致继续执行后资源不足。因此用while在wait返回后再做一次判断。 lock(&amp;mutex); if(value&#x3D;&#x3D;0) value++; if(value&gt;0) pthread_cond_signal(&amp;cond); unlock(&amp;mutex); 注意事项1传入前为何要锁，传入后为何要释放，返回时又为何再次锁？ 1.传入前锁mutex是为了保证线程从条件判断到进入pthread_cond_wait前，条件不被改变。 若没有传入前的锁，会出现如下情况： 线程A判断条件不满足（进入while循环）之后，调用pthread_cond_wait之前，A因为休眠或多线程下多个线程执行顺序和快慢的因素，令线程B更改了条件，使得条件满足。 但此时线程A还没有调用pthread_cond_wait，但是线程B的通知信号pthread_cond_signal已经来了，这就造成了信号丢失问题。 等到线程A进入pthread_cond_wait后虽然条件满足，但却错过了通知信号的唤醒，就会一直阻塞下去。 2.传入后解锁是为了条件能够被改变 传入后的解锁，是因为另一个线程需要先加锁更改条件后才调用pthread_cond_signal。（更改条件与等待条件满足，都是针对条件这一个资源的竞争，所以调用pthread_cond_wait和调用pthread_cond_signal的两个线程需要同一把锁）。 如果不对mutex解锁，那么在调用pthread_cond_wait后，其他线程就不能更改条件，就会一直阻塞。 3.返回前再次锁 保证线程从pthread_cond_wait返回后 到 再次条件判断前不被改变。 保证在pthread_cond_signal之后与解锁mutex之间可能需要的其他语句能够执行 对于1，理由与第一点差不多。如果不锁，那么线程A调用pthread_cond_wait后，条件满足，线程A被唤醒返回。线程B在此时更改了条件，使得条件不满足。但线程A不知道条件又被更改，以为条件满足，就可能出错。 对于2，只要线程B在pthread_cond_signal之后与解锁mutex之间有其他语句需要执行。由于mutex在这时已经被这个线程锁，还没有解锁，所以在pthread_cond_wait返回前的锁mutex的行为就会阻塞，直到线程B剩余的语句执行完并解锁，线程A才会返回。 注意事项2pthread_cond_signal的两种写法 1.写在加锁和解锁中间 lock(&amp;mutex); &#x2F;&#x2F;一些操作 pthread_cond_signal(&amp;cond); &#x2F;&#x2F;一些操作 unlock(&amp;mutex); 优点：安全 缺点：在某些线程的实现中，会造成等待线程从内核中唤醒（由于cond_signal)回到用户空间，因为返回前需要加锁，但是发现锁没有被释放，又回到内核空间所以一来一回会有性能的问题。 但是在LinuxThreads或者NPTL里面，就不会有这个问题，因为在Linux线程中，有两个队列，分别是cond_wait队列和mutex_lock队列， cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗。所以Linux中这样用没问题。 2.写在解锁后 优点：没有上述性能损耗 缺点：如果unlock之后signal之前，发生进程交换，另一个进程（不是等待条件的进程）拿到这把梦寐以求的锁后加锁操作，那么等最终切换到等待条件的线程时锁被别人拿去还没归还，只能继续等待。不安全。 生产者-消费者问题生产者-消费者问题描述： 生产者在生成数据后，放在一个缓冲区中； 消费者从缓冲区取出数据处理； 任何时刻，只能有一个生产者或消费者可以访问缓冲区； 我们对问题分析可以得出： 任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，需要互斥； 缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者需要同步。 那么我们需要三个信号量，分别是： 互斥信号量 mutex：用于互斥访问缓冲区，初始化值为 1； 资源信号量 fullBuffers：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）； 资源信号量 emptyBuffers：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）； 具体的实现代码： 常见同步问题见 [常见同步问题]((26 封私信 / 80 条消息) 如何理解互斥锁和信号量，以及他们在系统编程中是如何配合使用的？ - 知乎 (zhihu.com)) 「哲学家进餐问题」对于互斥访问有限的竞争问题（如 I/O 设备）一类的建模过程十分有用。 「读者-写者」，它为数据库访问建立了一个模型。 Socketsocket()该函数建立一个协议族为domain、协议类型为type、协议编号为protocol的套接字文件描述符。 #include&lt;sys&#x2F;socket.h&gt; int socket(int domain，int type，int protocol); domain 最常用的参数为 AF_INET / PF_INET 均表示IPv4 Internet协议。其中 AF = Address Family，PF = Protocol Family。在windows系统中两者完全一致，在Linux系统中，也基本一致（对于BSD,是AF,对于POSIX是PF） 所以在实际使用时，根据命名释义，在初始化时选择 PF_INET，后面调用设置地址的函数时选用 AF_INET。 type 常用的有两种： SOCK_STREAM：TCP连接，提供序列化的、可靠的、双向连接的字节流。支持带外数据传输。 SOCK_DGRAM：支持UDP连接（无连接状态的消息） protocol 用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0；但是有些协议有多种特定的类型，就需要设置这个参数来选择特定的类型。TCP设置为0。 返回值 成功，会返回一个标识这个套接字的文件描述符；失败的时候返回-1。 sockaddr_insockaddr在头文件#include &lt;sys/socket.h&gt;中定义，sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了，如下： struct sockaddr &#123; sa_family_t sin_family; &#x2F;&#x2F;地址族 char sa_data[14]; &#x2F;&#x2F;14字节，包含套接字中的目标地址和端口信息 &#125;; sockaddr_in在头文件#include&lt;netinet/in.h&gt;或#include &lt;arpa/inet.h&gt;中定义，该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中，如下： sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。 在给地址和端口赋值时注意要把值转为NBO（网络字节序），这样在发送网络数据时才能接收到正确值。 struct sockaddr_in address; bzero(&amp;address，sizeof(address)); address.sin_family &#x3D; AF_INET; address.sin_addr.s_addr &#x3D; htonl(INADDR_ANY); address.sin_port &#x3D; htons(port); setsockopt()setsockopt函数功能及参数详解 int reuse_addr_ctl &#x3D; 1; setsockopt(listenfd，SOL_SOCKET，SO_REUSEADDR，&amp;reuse_addr_ctl，sizeof(reuse_addr_ctl)); 在本项目中，由于大规模并发的TCP连接，就需要控制socket的地址复用。 SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址。一般不用于TCP服务器。 允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT （端口释放后可能出现），可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息，指明”地址已经使用中”。 端口复用最常用的用途应该是防止服务器重启时之前绑定的端口还未释放或者程序突然退出而系统没有释放端口。这种情况下如果设定了端口复用，则新启动的服务器进程可以直接绑定端口。如果没有设定端口复用，绑定会失败。 bind()服务端用于把用于通信的地址和端口绑定到 socket上。 bind(listenfd，(sockaddr*)&amp;address，sizeof(address)); listen()侦听功能将套接字置于侦听传入连接的状态。int listen (int __fd，int __n); 第二个参数为相应socket可以排队的最大连接个数。(例：有100个用户链接请求，但是系统一次只能处理20个，剩下的80个不能不理，所以系统创建队列记录这些暂时不能处理、一会儿处理的连接请求，依先后顺序处理) socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。 accept()TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后向TCP服务器发送一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，此时连接建立成功。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。 int accept(int sockfd，struct sockaddr *addr，socklen_t *addrlen); 第一个参数为服务器的socket描述字； 第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址； 第三个参数为客户端协议地址的长度。 如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与客户的TCP连接。若出现错误，返回值小于0。 一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。 socketpair()#include &lt;sys&#x2F;socket.h&gt; int socketpair(int d，int type，int protocol，int sv[2])； 用于创建一对无名的、相互连接的套接字（匿名管道）。 如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中。 domain：表示协议族，在Linux下只能为PF_LOCAL或PF_UNIX（ #define PF_UNIX PF_LOCAL）（自从Linux 2.6.27后也支持SOCK_NONBLOCK和SOCK_CLOEXEC）。 type：表示协议，可以是SOCK_STREAM或者SOCK_DGRAM。SOCK_STREAM是基于TCP的，而SOCK_DGRAM是基于UDP的 protocol：表示类型，只能为0 **sv[2]**：套节字柄对，该两个句柄作用相同，均能进行读写双向操作 基本用法： 这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读； 如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功； 读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程。如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写。因为文件描述副sv[0]和sv[1]是进程共享的，所以读的进程要关闭写描述符，反之，写的进程关闭读描述符。 注意： 该函数只能用于UNIX域（LINUX）下。 只能用于有亲缘关系的进程（或线程）间通信。 所创建的套节字对作用是一样的，均能够可读可写（而管道PIPE只能进行单向读或写）。 在读的时候，管道内必须有内容，否则将会阻塞；简而言之，该函数是阻塞的。 recv()函数原型：int recv(int __fd, void *__buf, size_t __n, int __flags); 功能：不论是客户还是服务器应用程序都用该函数从TCP连接的另一端接收数据。 参数：1.接收端套接字；2.数组，存放从缓冲区取到的数据；3.数组2的长度；4.一般置为0。 同步Socket的recv函数的执行流程： 当应用程序调用recv函数时，recv先等待 fd 的发送缓冲中的数据被协议传送完毕。如果协议在传送 fd 的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；如果 fd 的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字 fd 的接收缓冲区，如果 fd 接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕； 当协议把数据接收完毕，recv函数就把 fd 的接收缓冲中的数据copy到buf中（注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把 fd 的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的）。 recv函数返回其实际copy的字节数；如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回 0。 send()函数原型：int send(int __fd, const void *__buf, size_t __n, int __flags); 功能：不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。 参数：同 recv() 函数。 同步Socket的send函数的执行流程： 当调用该函数时，send先比较待发送数据的长度len和套接字 fd 的发送缓冲的长度（因为待发送数据是要copy到套接字 fd 的发送缓冲区的，注意并不是send把 fd 的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到 fd 的发送缓冲区的剩余空间里）： 如果len大于 fd 的发送缓冲区的长度，该函数返回SOCKET_ERROR； 如果len小于或者等于 fd 的发送缓冲区的长度，那么send先检查协议是否正在发送 fd 的发送缓冲中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送 fd 的发送缓冲中的数据或者 fd 的发送缓冲中没有数据，那么 send就比较** fd 的发送缓冲区的剩余空间和**len： 如果len大于剩余空间大小send就一直等待协议把 fd 的发送缓冲中的数据发送完； 如果len小于剩余空间大小send就仅仅把buf中的数据copy到剩余空间里。 如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误或在等待协议传送数据时网络断开，那么send就返回SOCKET_ERROR。 send函数把buf中的数据成功copy到 fd 的发送缓冲区后就返回了，但此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误，那么下一个Socket函数就会返回SOCKET_ERROR。(每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回 SOCKET_ERROR）。 EpollI/O复用I/O是指网络中的I/O（即输入输出），多路是指多个TCP连接，复用是指一个或少量线程被重复使用。连起来解就是，用少量的线程来处理网络上大量的TCP连接中的I/O。常见的I/O复用有以下三种：select、poll、epoll。 select#include &lt;sys&#x2F;select.h&gt; #include &lt;sys&#x2F;time.h&gt; int select(int maxfdpl,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout); 函数第一个参数是被监听的描述符的最大值+1，select底层的数据结构是位数组，因此必须知道被监听的最大描述符才可以确定描述符的范围，否则就需要将整个数组遍历一遍。 函数第二、三、四个参数是被监听的事件，分别是读、写、异常事件。 函数的最后一个参数是监听的时间（NULL、0、正值） selct缺点： 从函数参数列表可见，select只能监听读、写、异常这三个事件 selct监听的描述符是有最大值限制的，在Linux内核中是1024 select的实现是每次将待检测的描述符放在位数组中，全部传给内核进行监听，内核监听之后会返回一个就绪描述符个数，并且修改了监听的事件值，以表示该事件就绪。内核再将修改后的数组传给用户空间。用户空间只能通过遍历所有描述符来处理就绪的描述符，之后再将描述符传给内核继续监听……很明显，这样在监听的描述符少的情况下并不影响效率，但是监听的描述符数量特别大的情况下，每次又只有少数描述符上有事件就绪，大量的换入换出会使得效率十分低下。 pollstruct pollfd&#123; int fd; short events; short revents; &#125;; int poll(struct pollfd fdarray[]，unsigned long nfds，int timeout); 第一个参数是个结构体数组，结构体中声明了被监听描述符和相应的事件，每个被监听的描述符对应一个结构体，数组表示可以监听多个描述符。 第二个参数是被监听描述符的个数。 第三个参数同select，只监听时间。 poll缺点： 从函数参数来看，poll解决了select前两个问题，监听的描述符数量没有严格限制，监听的事件不止读、写、异常，但是第三个缺点依然存在，存在大量的换入换出。 函数分析#include &lt;sys&#x2F;epoll.h&gt; int epoll_create(int size); 创建一个epoll实例。返回值为epoll实例的文件描述符，参数size标识该实例监听的最大数目。 当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 size参数只是告诉内核这个 epoll对象会处理的事件大致数目，而不是能够处理的事件的最大个数。在 Linux最新的一些内核版本的实现中，这个 size参数没有任何意义。 内核事件表：包括文件描述符的分配、文件实体的分配等。文件描述符中有一个域很重要：private_data域，这是epoll的核心，其中有内核时间表、就绪描述符队列等信息。 int epoll_ctl(int epfd，int op，int fd，struct epoll_event *event); epfd：为epoll_create创建的句柄 op：即操作，包含以下三个宏—— EPOLL_CTL_ADD (注册新的fd到epfd) EPOLL_CTL_MOD (修改已经注册的fd的监听事件) EPOLL_CTL_DEL (从epfd删除一个fd) fd：需要监听的fd event：内核需要监听什么类型的事件，结构体如下—— typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64; &#125; epoll_data_t; struct epoll_event &#123; uint32_t events; &#x2F;* Epoll events *&#x2F; epoll_data_t data; &#x2F;* User data variable *&#x2F; &#125; __EPOLL_PACKED; events描述事件类型，其中epoll事件类型主要有以下几种： EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭） EPOLLOUT：表示对应的文件描述符可以写 EPOLLPRI：表示对应的文件描述符有紧急的数据可读 EPOLLERR：表示对应的文件描述符发生错误 EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的 EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 EPOLLRDHUP：表示读关闭，对端关闭，不是所有的内核版本都支持； ······ 该函数主要是对内核事件表的操作，涉及插入（添加监听描述符）、删除（删除被监听的描述符）、修改（修改被监听的描述符）。主要有以下步骤： 遍历内核事件表，看该描述符是否在内核事件表中。 判断所要做的操作：插入、删除或是修改 根据操作做相应处理 int epoll_wait(int epfd，struct epoll_event *events，int maxevents，int timeout); events：分配好内存的 epoll_event结构体数组，epoll将会把发生的事件复制到 events数组中（events不可以是空指针，内核只负责把数据复制到这个 events数组中，不会去帮助我们在用户态中分配内存。内核这种做法效率很高）。 maxevents：本次可返回的最大事件数目，通常 maxevents参数与预分配的events数组的大小是相等的。 timeout：超时时间；为0，则表示 epoll_wait在 rdllist链表中为空，立刻返回，不会等待。为-1，则表示一直在等待，直至有事件发生。 return：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1； 内核事件表的底层数据结构是红黑树，就绪描述符的底层数据结构是链表。 epoll_wait的功能就是不断查看就绪队列中有没有描述符，如果没有就一直检查、直到超时。如果有就绪描述符，就将就绪描述符通知给用户。 ET和LTET模式是高效模式，就绪描述符只通知用户一次，如果用户没做处理内核将不再进行通知； LT模式比较稳定，如果用户没有处理就绪的描述符，内核会不断通知。 当为ET模式时，上边我们提到就绪描述符是用链表组织的，因此只需将就绪部分断链发给用户，而在LT模式下，用户没有处理就绪描述符时，内核会再次将未处理的就绪描述符加入到就绪队列中重复提醒用户空间。 由于内核对用户态的不信任,内核态和用户态的传输数据总是拷贝的。 区别在于： 当一个新的事件到来时，ET模式下当然可以从 epoll_wait调用中获取到这个事件，可是如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字没有新的事件再次到来时，在 ET模式下是无法再次从 epoll_wait调用中获取这个事件的；而 LT模式则相反，只要一个事件对应的套接字缓冲区还有数据，就总能从 epoll_wait中获取这个事件。因此，在 LT模式下开发基于 epoll的应用要简单一些，不太容易出错，而在 ET模式下事件发生时，如果没有彻底地将缓冲区数据处理完，则会导致缓冲区中的用户请求得不到响应。默认情况下，Nginx是通过 ET模式使用 epoll的。 阻塞与非阻塞#include &lt;fcntl.h&gt; int fcntl(int fd，int cmd，long arg); fcntl()针对文件描述符提供控制。参数fd是被参数cmd操作的描述符。 F_SETFL 设置arg标志参数，可选的几个标志是：O_APPEND、O_NONBLOCK、O_SYNC、O_ASYNC。 F_GETFL 取得fd的文件状态标志,同上述(arg被忽略) cmd常用例：用命令F_GETFL和F_SETFL设置文件标志，比如阻塞与非阻塞。 flags &#x3D; fcntl(fd，F_GETFL); flags |&#x3D; O_NONBLOCK; fcntl(fd，F_SETFL，flags); Linux信号信号就是由用户、系统或进程发送给目标进程的信息，以通知目标进程中某个状态的改变或是异常。 sigaction 结构体struct sigaction &#123; void (*sa_handler)(int); void (*sa_sigaction)(int，siginfo_t *，void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); &#125;; 1.sa_handler：指定信号关联函数 输入为一个函数指针（函数名），即用户指定的信号处理函数。除此之外，还可以赋值为常数SIG_IGN表示忽略信号，赋值为常数SIG_DFL表示执行系统默认动作(采用缺省的处理方式)。 typedef void (*__sighandler_t) (int); 赋值为一个函数指针表示用自定义函数捕捉信号，或者说向内核注册了一个信号处理函数，该函数返回值为void，带一个int参数，通过参数可以得知当前信号的编号，这样就可以用同一个函数处理多种信号。 2.sa_sigaction指定信号关联函数 由_sa_sigaction是指定的信号处理函数带有三个参数，是为实时信号而设的（当然同样支持非实时信号），它指定一个3参数信号处理函数。第一个参数为信号值，第二个参数是指向siginfo_t结构的指针，结构中包含信号携带的数据值，第三个参数没有使用（posix没有规范使用该参数的标准）。 sa_handler主要用于不可靠信号（实时信号当然也可以，只是不能带信息），sa_sigaction用于实时信号可以带信息(siginfo_t)，两者不能同时出现（如果设置了SA_SIGINFO标志位，则会使用sa_sigaction处理函数，否则使用sa_handler处理函数。）。 3.sa_mask存放需要手动屏蔽的信号 指定在信号处理程序执行过程中，哪些信号应当被阻塞。缺省情况下当前信号本身被阻塞，防止信号的嵌套发送，除非指定SA_NODEFER或者SA_NOMASK标志位，处理程序执行完后，被阻塞的信号开始执行。 4.sa_flags指定一组修改信号行为的标志 5.sa_restorer：已过时，POSIX不支持它，不应再被使用。 sigfillset()int sigfillset (sigset_t *set); 初始化一个满的信号集，集合当中有所有的信号，所有的信号都被添加到这个集合中了。用于初始化上述结构体中的 sa_mask。 sigaction()检查或修改指定信号的设置(或同时执行) int sigaction(int signum,const struct sigaction *act,const struct sigaction *old); signum：为信号的值，可以为除sigkill及sigstop外的任何一 个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误） act：要设置的对信号的新处理方式(传入) oldact：原来对信号的处理方式(传出) 如果act指针非空，则要改变指定信号的处理方式，如果oldact指针非空 则系统将此前指定信号的处理方式引入 oldact。 返回值:函数成功返回0，失败返回-1。 alarm()unsigned int alarm(unsigned int seconds); 设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。 返回0或剩余的秒数，无失败。 取消定时器alarm(0)，返回旧闹钟余下秒数。 alarm使用的是自然定时法，与进程状态无关，就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。 SIGPIPE信号当服务器close一个连接时，若client端接着发数据，根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。 对一个对端已经关闭的socket调用两次write，第二次将会生成SIGPIPE信号，该信号的缺省处理方法为结束进程。为了避免进程退出，需要重载这个信号的处理方法。 结合TCP的”四次握手”关闭：TCP是全双工的信道，可以看作两条单工信道，TCP连接两端的两个端点各负责一条。当对端调用close时，虽然本意是关闭整个两条信道，但本端只是收到FIN包。按照TCP协议的语义，表示对端只是关闭了其所负责的那一条单工信道，仍然可以继续接收数据。也就是说，因为TCP协议的限制，一个端点无法获知对端的socket是调用了close还是shutdown。 因此第一次对其调用write方法时，如果发送缓冲没问题，会返回正确写入(发送)。但发送的报文会导致对端发送RST报文，因为对端的socket已经调用了close，完全关闭，既不发送，也不接收数据。所以，第二次调用write方法(假设在收到RST之后)，会生成SIGPIPE信号，导致进程退出。 为了避免进程退出，可以捕获SIGPIPE信号，或者忽略它，给它设置SIG_IGN信号处理函数。这样，第二次调用write方法时，会返回-1，同时errno置为SIGPIPE。程序便能知道对端已经关闭。 SIGALRM信号在进行阻塞式系统调用时，为避免进程陷入无限期的等待，可以为这些阻塞式系统调用设置定时器。Linux提供了上述的alarm系统调用和SIGALRM信号实现这个功能。 如果客户端长时间没有与服务器进行交互，需要服务器在一定时间之后主动关闭socket连接。在这种场景下，就可以在服务器收到客户端的socket的连接时，设置一个定时信号，然后在定时信号到来时，关闭掉socket连接。 SIGTERM信号SIGINT、SIGKILL、SIGTERM，三者都是结束/终止进程运行，但略微有区别。 SIGINT 产生方式：键盘Ctrl+C 产生结果：只对当前前台进程，和他的所在的进程组的每个进程都发送SIGINT信号，之后这些进程会执行信号处理程序再终止。 SIGKILL 产生方式：和任何控制字符无关,用kill函数发送。 本质：相当于shell&gt; kill -9 pid。 产生结果：当前进程收到该信号（该信号无法被捕获），也就是说进程无法执行信号处理程序，会直接发送默认行为——直接退出。这也是为何kill -9 pid一定能杀死程序的原因。故这也造成了进程被结束前无法清理或者关闭已分配的资源，这样是不好的。 SIGTERM 产生方式：和任何控制字符无关，用kill函数发送。 本质：相当于shell&gt; kill不加-9时 pid。 产生结果：当前进程会收到信号，而其子进程不会收到。如果当前进程被kill(即收到SIGTERM)，则其子进程的父进程将为init，即pid为1的进程。 与SIGKILL的不同：SIGTERM可以被阻塞、忽略、捕获，即可以进行信号处理程序，那么这样就可以让进程很好的终止，允许清理和关闭文件。 MySQLmysql_init()MYSQL* mysql_init(MYSQL *mysql) 返回值: 返回MYSQL结构体对象。如果无足够内存以分配新的对象，返回nullptr。 说明： 如果输入是 nullptr，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。 如果分配了新的对象，应当在程序中调用mysql_close() 来关闭连接，以释放对象。 mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。 MYSQL* mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag); 返回值：如果连接成功，返回MYSQL*连接句柄（与第一个输入相同）。如果连接失败，返回 nullptr。 参数： host：MYSQL服务器的地址；如果为空或字符串”localhost”，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP/IP连接到服务器。 user：登录用户名；如果为空，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。 db：要连接的数据库，如果db为空，连接会将默认的数据库设为该值。 unix_socket：unix连接方式。如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道。注意，“host”参数决定了连接的类型。 client_flag：Mysql运行为ODBC数据库的标记，一般取0。 mysql_close()关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。 void mysql_close(MYSQL *mysql); mysql_query()执行query语句，查询数据库表中的内容。 int mysql_query(MYSQL *mysql, const char *query); 正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或“\\g”。 如果允许多语句执行，字符串可包含多条由分号隔开的语句。（“多查询执行的C API处理”） 不能用于包含二进制数据的查询。 mysql_store_result()将 mysql_query 查询的全部结果读取到客户端，分配1个MYSQL_RES结构，并将结果置于该结构中。 MYSQL_RES *mysql_store_result(MYSQL *mysql); 使用说明： 对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等），必须调用mysql_store_result() 或 mysql_use_result() 。 如果希望了解查询是否应返回结果集，可使用 mysql_field_count() 进行检查。 如果查询未返回结果集，将返回Null指针（例如，如果查询是INSERT语句）。 如果读取结果集失败，会返回Null指针。通过检查 mysql_error() 是否返回非空字符串，mysql_errno() 是否返回非0值，或 mysql_field_count() 是否返回0，可以检查是否出现了错误。 如果未返回行，将返回空的结果集。（空结果集设置不同于作为返回值的空指针）。 一旦获得了不是Null指针的结果，可调用 mysql_num_rows() 来获取结果集中的行数。 可以调用 mysql_fetch_row() 来获取结果集中的行，或调用 mysql_row_seek() 和mysql_row_tell() 来获取或设置结果集中的当前行位置。 一旦完成了对结果集的操作，必须调用 mysql_free_result()。 mysql_fetch_row()从结果集中获取下一行，若没有下一行，返回空指针。 typedef char** MYSQL_ROW; MYSQL_ROW mysql_fetch_row(MYSQL_RES* result); 行内值的数目由mysql_num_fields(result)给出。如果行中保存了调用mysql_fetch_row()返回的值，将按照row[0]到row[mysql_num_fields(result)-1]，访问这些值的指针。 可以通过调用mysql_fetch_lengths()来获得行中字段值的长度。对于空字段以及包含NULL的字段，长度为0。通过检查字段值的指针，能够区分它们。如果指针为NULL，字段为NULL，否则字段为空。 HTTP请求报文 响应报文 请求方法 状态码 Reactor模式详情参考 Proactor模式&amp;Reactor模式详解 - 知乎 (zhihu.com) 环境配置配置MySQL安装sudo apt update sudo apt install mysql-server 安装完成后，MySQL 服务将会自动启动。 查看 MySQL 服务器运行状态： sudo systemctl status mysql ● mysql.service - MySQL Community Server Loaded：loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;mysql.service; enabled; vendor preset：enabled) Active：active (running) since Tue 2023-07-11 06:28:50 PDT; 3min 22s ago Main PID：4805 (mysqld) Status：&quot;Server is operational&quot; Tasks：37 (limit：6984) Memory：364.6M CGroup：&#x2F;system.slice&#x2F;mysql.service └─4805 &#x2F;usr&#x2F;sbin&#x2F;mysqld Jul 11 06:28:49 ubuntu systemd[1]：Starting MySQL Community Server... Jul 11 06:28:50 ubuntu systemd[1]：Started MySQL Community Server. 设置密码将密码插件修改为 mysql_native_password use mysql; UPDATE user SET plugin&#x3D;&#39;mysql_native_password&#39; WHERE user&#x3D;&#39;root&#39;; FLUSH PRIVILEGES; 修改密码： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; quit; 密码修改完成后，重启mysql服务： sudo &#x2F;etc&#x2F;init.d&#x2F;mysql restart 项目实现代码架构├── CGImysql # CGI校验程序，用于用户数据与数据库数据的对比 │ ├── sql_connection_pool.cpp │ └── sql_connection_pool.h ├── http # http协议的连接、销毁等实现 │ ├── http_conn.cpp │ └── http_conn.h ├── lock # 封装互斥锁、信号量操作 │ └── locker.h ├── log # 日志系统实现 │ ├── block_queue.h │ ├── log.cpp │ └── log.h ├── test_presure # 压力测试webbench │ └── ··· ├── threadpool # 线程池实现 │ └── threadpool.h └── timer # 定时器实现 | └── lst_timer.h ├── root # 静态网页数据、图片、视频等 │ └── ··· ├── main.c # 主函数入口 ├── makefile ├── server # 生成的可执行文件 ├── 2023_07_11_ServerLog # 日志记录 项目框架 实现功能 使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型 使用状态机解析HTTP请求报文，支持解析GET和POST请求 访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件 实现同步/异步日志系统，记录服务器运行状态 经Webbench压力测试可以实现上万的并发连接数据交换 线程池概念线程池是一种并发编程技术，它能有效地管理并发的线程、减少资源占用和提高程序的性能。 线程池在系统启动时即创建大量空闲的线程。程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态,在这里说是空闲状态其实是被条件变量阻塞了，等待执行下一个任务。 优势1.提高性能与资源利用率 线程池主要解决两个问题：线程创建与销毁的开销以及线程竞争造成的性能瓶颈。通过预先创建一组线程并复用它们，线程池有效地降低了线程创建和销毁的时间和资源消耗。同时，通过管理线程并发数量，线程池有助于减少线程之间的竞争，增加资源利用率，并提高程序运行的性能。 2.线程创建开销解决 多线程环境下，每当需要执行一个任务时，创建与销毁线程都需要额外的系统资源。线程池通过预先创建一定数量的线程，可以减少这种资源消耗。 3.线程竞争问题解决 过多的线程可能导致线程竞争，影响系统性能。线程池通过维护一个可控制的并发数量，有助于减轻线程之间的竞争。例如，当CPU密集型任务和I/O密集型任务共存时，可以通过调整线程池资源，实现更高效的负载平衡。 1.线程池初始化线程创建维护一个指定大小 _thread_num 的线程id的数组 _threads，存储所有创建的线程。 循环调用 pthread_create 和 pthread_detach 库函数，创建线程。 int pthread_create(pthread_t *thread，const pthread_attr_t *attr, void *(*start_routine) (void *)，void *arg); thread：传递存储线程（pthread_t变量）的地址 attr：手动设置新建线程的属性，如线程的调用策略、线程所能使用的栈内存的大小等。默认为NULL start_routine：以函数指针的方式指明新建线程需要执行的函数，该函数的参数最多有 1 个（可以省略不写），形参和返回值的类型都必须为 void* 类型。如果该函数有返回值，则线程执行完函数后，函数的返回值可以由 pthread_join() 函数接收。 arg：指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可。 返回值：成功返回0。失败返回非0值，常见有： EINVAL == 22：传递给 pthread_create() 函数的 attr 参数无效。 EAGAIN == 11：系统资源不足，无法提供创建线程所需的资源。 定义一个静态函数作为第三个参数传入，用于运行工作线程（从任务队列中取任务并执行）。为了使得函数能正常访问其他非静态成员变量，将this指针（本实例）作为第四个参数传入，实现在静态函数中调用实例的方法（具体的工作线程运行实现）。 int pthread_detach (pthread_t __th) &#x2F;&#x2F; 返回值：0 - 成功；非0 - 失败 pthread有两种状态：joinable状态和unjoinable状态。 joinable状态：当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符。只有当你调用了pthread_join之后这些资源才会被释放。默认为此状态。 unjoinable状态：这些资源在线程函数退出时或pthread_exit时自动会被释放。 unjoinable属性可以在pthread_create前指定，或在线程创建后在线程中pthread_detach。 配置参数std::vector&lt;pthread_t&gt; _threads; &#x2F;&#x2F; 存储线程的数组，大小为 _thread_num int _thread_num; &#x2F;&#x2F; 线程池中的线程数 std::atomic&lt;bool&gt; _run; &#x2F;&#x2F; 原子布尔变量，标记线程终止运行 int _max_requests; &#x2F;&#x2F; 请求队列中允许的最大请求数 std::list&lt;T*&gt; _taskqueue; &#x2F;&#x2F; 请求任务队列 MutexS _queue_mutex; &#x2F;&#x2F; 保护请求队列的互斥锁 SemS _queue_sem; &#x2F;&#x2F; 通知线程的信号量 任务队列初始化 维护一个任务队列 list&lt;T*&gt; 管理待执行任务； 维护一个互斥锁（自实现），保护请求队列； 维护一个条件变量（自实现），告诉线程池是否有任务需要处理。 2.任务调度任务队列管理 线程池需要提供添加任务的接口，将接收到的任务加入任务队列。在添加任务的过程中，需使用互斥量锁住任务队列以实现同步访问。任务添加成功后，通知等待中的线程有新任务可以执行。 template &lt;typename T&gt; bool ThreadPool&lt;T&gt;::append(T *req) &#123; _queue_mutex.lock(); if (_taskqueue.size() &gt;&#x3D; _max_requests) &#123; _queue_mutex.unlock(); return false; &#125; _taskqueue.push_back(req); _queue_mutex.unlock(); _queue_sem.post(); return true; &#125; 线程取任务执行线程执行体应按照预设策略从任务队列中获取任务并执行。获取任务时，需要在条件变量上等待，直到有新任务或线程池被终止。任务获取成功后，线程从队列中移除任务并执行。执行完成后，线程可以被再次复用。 template &lt;typename T&gt; void ThreadPool&lt;T&gt;::work() &#123; while (true) &#123; _queue_sem.wait(); _queue_mutex.lock(); if (_taskqueue.empty()) &#123; _queue_mutex.unlock(); continue; &#125; T* request &#x3D; _taskqueue.front(); _taskqueue.pop_front(); _queue_mutex.unlock(); if (!request) continue; &#x2F;&#x2F; handle &#125; &#125; 任务状态跟踪为了确保任务的执行正确性和完整性，可以使用一定机制来跟踪任务的状态。例如： 任务开始时，记录任务运行的开始时间。 任务执行期间，跟踪任务的进度，如百分比、耗时等。 任务结束时，记录任务的结束状态，如正常完成、出错等。 通过跟踪任务状态，可以调整线程池的执行策略，以适应不同类型的任务需求。同时及时发现并处理任务执行中的异常，提高线程池的稳定性和可靠性。 3.线程池的终止标记线程池终止状态在线程池类中，添加一个原子布尔类型的成员变量 _run，当线程池需要终止时，将其设置为 false。在线程取任务的过程中，会检查 _run 变量，根据其值决定继续执行或退出。(替换2.2中while的判断条件) 等待线程执行完成在线程池析构函数中，需要等待所有线程执行完成。将_run标记设置为false，线程函数执行完一遍后即跳出循环，因为之前已被detach，因此会由系统自动释放资源。 4.动态调整线程数增加线程数bool ThreadPool&lt;T&gt;::append_thread(int new_num) &#123; if(!_dynamic_ctl) return false; _threads.resize(_thread_num + new_num); for(int i &#x3D; 0; i &lt; new_num; ++i) &#123; if(pthread_create(&amp;_threads[_thread_num + i]，NULL，transfer，(void*)this)) &#123; return false; &#125; if(pthread_detach(_threads[_thread_num + i])) &#123; return false; &#125; &#125; _thread_num +&#x3D; new_num; return true; &#125; 减少线程数 TODO不太好搞，可以通过设置一个信号量判断还需要删除几个线程。在删除函数中，循环对该信号量post，并添加一个空任务到任务队列中。在工作线程中，取出空的任务时，使用trywait 判断是否需要删除该线程，若删除则直接break掉while循环，退出函数后该线程自动释放。 问题也就在这里，当线程释放后，其id依旧保留在线程数组中，那么何时去更新这个数组才能保证那些线程都退出释放了呢？又如何判断哪个线程id是被释放了需要删除呢（pthread库中找不到pthread_kill函数了，且该函数也不稳定）？ 这是因为线程被detach了的缘故，如果是 joinable 模式，用join释放可能比较容易一些？ 5.自定义任务调度策略 TODO设置任务优先级，使用优先队列实现。但是这样无法实现线程池的泛型了？ 6.监控线程池状态int get_thread_num() const &#123; return _thread_num; &#125; int get_task_num() const &#123; return _taskqueue.size(); &#125; int get_completed_task_num() const &#123; return _completed_tasknum.load(); &#125; double get_run_time() const &#123; std::chrono::duration&lt;double&gt; diff &#x3D; std::chrono::steady_clock::now() - start_time; return diff.count(); &#125; 定时器如果一个客户端与服务器长时间连接，并且不进行数据的交互，这个连接就没有存在的意义还占据了服务器的资源。在这种情况下，服务器就需要一种手段检测无意义的连接，并对这些连接进行处理。除了处理非活跃的连接之外，服务器还有一些定时事件，比如关闭文件描述符等。为实现这些功能，服务器就需要为各事件分配一个定时器。 该项目使用SIGALRM信号来实现定时器，首先每一个定时事件都处于一个升序链表上，通过alarm()函数周期性触发SIGALRM信号，而后信号回调函数利用管道通知主循环，主循环接收到信号之后对升序链表上的定时器进行处理：若一定时间内无数据交换则关闭连接。 数据库连接池每一次数据访问请求都必须经过下面几个步骤：建立数据库连接，打开数据库，对数据库中的数据进行操作，关闭数据库连接。而建立数据库连接和打开数据库是一件很消耗资源并且费时的工作，如果在系统中很频繁的发生这种数据库连接，必然会影响到系统的性能，甚至会导致系统的崩溃。 在系统初始化阶段，建立一定数量的数据库连接对象(Connection)，并将其存储在连接池中定义的容器中。 当有数据库访问请求时，就从连接池中的这个容器中拿出一个连接。 当容器中的连接已用完，且还未达到系统定义的最大连接数时，可以再创建一个新的连接。（不一定实现） 当当前使用的连接数达到最大连接数时，就要等待其他访问请求将连接放回容器后才能使用。 当使用完连接的时候，必须将连接放回容器中。 这样不同的数据库访问请求就可以共享这些连接，通过重复使用这些已经建立的数据库连接，可以解决频繁建立连接的缺点，从而提高了系统的性能。数据库连接池跟线程池的思想基本是一致的。 单例模式因为池子只需要一个，所以采用单例模式。 单例模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的唯一的对象。该对象外界可以获取到，但是不能创建和拷贝。 通俗的讲：单例模式就是说每一个类只有单一的一个对象，并且这个对象由该对象自己创建。如果让外部调用构造函数或者拷贝构造函数等，很难保证外部只创建了一个实例对象。 单例模式的最佳方式： C++11规定了local static在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。在C++11标准下，《Effective C++》提出了一种更优雅的单例模式实现，使用函数内的 local static 对象。这样，只有当第一次访问getInstance()方法时才创建实例。。C++0x之后该实现是线程安全的，C++0x之前仍需加锁。 class Singleton &#123; private: Singleton() &#123; &#125;; ~Singleton() &#123; &#125;; public: static Singleton&amp; getInstance() &#123; static Singleton instance; return instance; &#125; &#125;; 在该项目中不仅实现了数据库连接池，还将数据库连接的获取与释放通过RAII机制封装，避免手动释放。 HTTP处理流程HTTP的处理流程分为以下三个步骤： 连接处理：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，等待工作线程从任务队列中取出一个任务进行处理。 解析请求报文：工作线程取出任务后，调用进程处理函数，通过主、从状态机对请求报文进行解析。 生成响应报文：解析完之后，明确用户想要进行的操作（跳转到对应的界面、添加用户名、验证用户等等）并将相应的数据写入响应报文。 返回响应报文给客户端：将响应报文发回给客户端。 Reactor模式-TODO本项目采用 多 Reactor 多线程的方案。Proactor模式&amp;Reactor模式详解 - 知乎 (zhihu.com) 1.连接处理 主线程是基于事件驱动的loop，通过 epoll 监控连接建立、断开和读取、发送事件。 主线程阻塞于epoll_wait，当有事件发生后，分为以下几种状态： 接受到连接建立事件，主线程通过 accept 获取连接，并将该TCP连接加入内核事件表，初始化该连接的http类对象，设置该连接的定时器并加入定时器管理链表中； 接受到连接断开事件，主线程通过定时器回调函数关闭该连接，并从内核事件表中删除。 接收到读取、发送事件，将该连接的http类对象加入线程池的任务队列中，等待空闲线程处理。 多 Reactor 多线程的方案虽然看起来复杂的，但实现时比单 Reactor 多线程的方案要简单的多，原因如下： 主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。 主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。 2.解析报文请求最新版Web服务器项目详解 - 05 http连接处理（中） (qq.com) 3.生成响应报文最新版Web服务器项目详解 - 06 http连接处理（下） (qq.com) 4.返回响应报文最新版Web服务器项目详解 - 06 http连接处理（下） (qq.com) 登录和注册页面跳转逻辑如下： 首先需要从数据库中获取所有的用户名和密码（用户密码加密传输参考用户登录实践），这些用户名和密码以某种数据结构（如哈希表）保存。当浏览器请求到达时，根据其请求访问，返回对应的界面html或是错误提示。 整个过程其实是一个有限状态机。 有限状态机状态机可归纳为4个要素，即现态、条件、动作、次态。“现态”和“条件”是因，“动作”和“次态”是果。 现态：是指当前所处的状态。 条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。 动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。 次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”。 EpollDebugMySQL关于用户密码问题1：root无需密码，或任何密码都可以登录 原因： select user,host,plugin from mysql.user; 查看用户插件信息，显示root插件为auth_socket，这种插件无需密码，所以设置任何密码都无效。 解决： 更改插件为mysql_native_password 或者caching_sha2_password use mysql; UPDATE user SET plugin&#x3D;&#39;mysql_native_password&#39; WHERE user&#x3D;&#39;root&#39;; FLUSH PRIVILEGES; 问题2：修改密码时报错 ERROR 1819 (HY000)：Your password does not satisfy the current policy requirements 原因：由于默认安装了validate_password插件，密码不符合当前策略要求 解决： 设置类似123456的简单密码时，要将密码策略设置为0（LOW），默认为1（MEDIUM），并修改长度（默认为8），最低为4。 首先查看当前设置内容： # method1 推荐 SHOW VARIABLES LIKE &#39;validate_password%&#39;; # method2 SELECT @@validate_password.policy; +--------------------------------------+-------+ | Variable_name | Value | +--------------------------------------+-------+ | validate_password.check_user_name | ON | | validate_password.dictionary_file | | | validate_password.length | 4 | | validate_password.mixed_case_count | 1 | | validate_password.number_count | 1 | | validate_password.policy | LOW | | validate_password.special_char_count | 1 | +--------------------------------------+-------+ 7 rows in set (0.00 sec) 注：5.7版本的mysql，变量为 validate_password_policy。 修改对应的值： # mysql8.0 set global validate_password.policy&#x3D;0; set global validate_password.length&#x3D;1; # 最低好像是4，不能 编译关于mysql.h问题：fatal error：mysql/mysql.h：No such file or directory 原因：没有安装 mysql的相关链接库 解决：sudo apt-get install libmysqlclient-dev 关于g++问题：make：g++：Command not found 原因：没有安装 g++ 编译器 解决：sudo apt-get install build-essential 拓展： build-essential 是 Ubuntu 软件源默认包含的一个软件包组，它包含了 GNU 编辑器集合，GNU 调试器，和其他编译软件所必需的开发库和工具，也包括 gcc ，g++ 和 make。","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"},{"name":"服务器","slug":"服务器","permalink":"https://www.hanhan0223.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"LeetCode--2023Q3","slug":"LeetCode--2023Q3","date":"2023-07-01T02:01:40.000Z","updated":"2023-09-02T09:45:28.902Z","comments":true,"path":"原理/LeetCode--2023Q3/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode--2023Q3/","excerpt":"打卡7月LeetCode2023.7.1198.打家劫舍题干 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 解法 基本思路：动态规划","text":"打卡7月LeetCode2023.7.1198.打家劫舍题干 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 解法 基本思路：动态规划 dp含义：偷到第 i 家为止能得到的最大金额。 递推公式：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) 。在第 i 家，如果选择偷，就是不考虑 i-1，那就是在 i-2的基础上拿 i 的；如果不偷，就考虑是 i-1 的金额。 初始化：很明显考虑到 i-2，需要初始化0，1。其中1需要取0、1中的较大值。 Code class Solution &#123; public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 0) return 0; if(nums.size() &#x3D;&#x3D; 1) return nums[0]; int one &#x3D; nums[0], two &#x3D; max(nums[0], nums[1]), cur &#x3D; two; for(int i &#x3D; 2; i &lt; nums.size(); ++i) &#123; cur &#x3D; max(one + nums[i], two); one &#x3D; two; two &#x3D; cur; &#125; return cur; &#125; &#125;; 相关题目213.打家劫舍 Ⅱ题干 在198的基础上，房屋连成了环，其余不变。 解法 基本思路：动态规划 这题主要是思路的转换，即怎么处理首尾相邻的情况。 首尾不能同时存在，那么去掉其中一个，剩余的就是198的逻辑了：即在 [0, size) 和 [1, size - 1) 区间内各自计算一遍最大金额，然后取两者中的最大值即可。 Code class Solution &#123; public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 1) return nums[0]; auto maxCoins &#x3D; [&amp;](int l, int r) &#123; if(l + 1 &#x3D;&#x3D; r) return nums[l]; int one &#x3D; nums[l], two &#x3D; max(nums[l], nums[l+1]), cur &#x3D; two; for(int i &#x3D; l+2; i &lt; r; ++i) &#123; cur &#x3D; max(one + nums[i], two); one &#x3D; two; two &#x3D; cur; &#125; return cur; &#125;; return max(maxCoins(0, nums.size() - 1), maxCoins(1, nums.size())); &#125; &#125;; 337.打家劫舍 Ⅲ题干 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。 解法 基本思路：动态规划、树形DP 这题的思路和前两题完全不同，算是二叉树遍历和动态规划的结合（树形DP）。首先很容易想到，在遍历的时候，必须至少隔一层才能偷一次，那么从叶节点开始遍历是相对更好的选择，可以将状态递推至根节点输出。因此遍历顺序选择后序遍历。 那么如何来设计dp数组呢，这里dp数组实际需要保存两个值（当前节点偷、不偷的最高金额），相当于两个dp了。于是原本的 dp[i] 需要修改为一组。在代码随想录中使用 vector来存储，相对消耗时空更多，这里选择用 pair来存储两个值，结构体相对更省时空。 为了得到每一层偷与不偷的递归状态，不能用同一个全局变量来存储，设置为递归返回值是较为方便的处理。 接下来确定递推公式，作为递归中的单层处理逻辑使用，置于左右子树递归的后面： 偷：那么应该是两个子节点不偷时的最大金额加上当前节点值，即 cur-&gt;val + no_robL + no_robR 不偷：那么应该是两个子节点返回的一对中更大的值的和，即 **max(robL, no_robL) + max(robR, no_robR)为什么不是直接取子节点偷的和，是因为可能存在当前子节点偷了之后不一定就比没偷的金额更多（例：[4,1,null,2,null,3]**） 最后遍历到空节点如何处理？也就是确定了终止条件：空节点什么都偷不到当然是返回 {0, 0} 。 最后遍历到根节点得到整棵树偷与不偷的状态，取最大值。 Code class Solution &#123; public: int rob(TreeNode* root) &#123; auto track &#x3D; [ &amp;, circle &#x3D; [](auto&amp;&amp; self, TreeNode* cur) -&gt; pair&lt;int, int&gt; &#123; if(cur &#x3D;&#x3D; nullptr) return &#123;0, 0&#125;; auto [robL, no_robL] &#x3D; self(self, cur-&gt;left); auto [robR, no_robR] &#x3D; self(self, cur-&gt;right); return &#123;cur-&gt;val + no_robL + no_robR, max(robL, no_robL) + max(robR, no_robR)&#125;; &#125; ]() &#123; return circle(circle, root); &#125;; auto [rob, no_rob] &#x3D; track(); return max(rob, no_rob); &#125; &#125;; 714.买卖股票的最佳时机含手续费题干 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 解法 基本思路：动态规划、树形DP 这题的dp同样得分成两部分：第 i 天持有（dp[i] [0]）或不持有（dp[i] [1]）股票时所得最大现金。 递推公式： dp[i] [0] = max(dp[i-1] [0], dp[i-1] [1] - prices[i]) ：前一天持有的现金和前一天不持有当天买入的最大值。 dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i] - fee) ：前一天不持有的现金和前一天持有当天卖出的最大值。 这里可以发现两个值都仅由上一天的状态推出，那就可以用常量替代二维数组节省空间，存在交叉使用的问题可以设置一个temp保存先被修改的那个变量之前的状态即可。最后输出的一定是不持有，因为卖出会得到更多钱。 Code class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int have &#x3D; -prices[0], no &#x3D; 0; for(int i &#x3D; 1; i &lt; prices.size(); ++i) &#123; int temp &#x3D; have; have &#x3D; max(have, no - prices[i]); no &#x3D; max(no, temp + prices[i] - fee); &#125; return no; &#125; &#125;; 2023.7.2121.买卖股票的最佳时机题干 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 解法 基本思路：动态规划 因为只会买入和卖出一次，那么状态就比较好判断。dp：第 i 天持有（dp[i] [0]）或不持有（dp[i] [1]）股票时所得最大现金。可以用常量节省空间。 递推公式： dp[i] [0] = max(dp[i-1] [0], - prices[i]) dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i]) Code class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int have &#x3D; -prices[0], no &#x3D; 0; for(int i &#x3D; 1; i &lt; prices.size(); ++i) &#123; no &#x3D; max(no, prices[i] + have); have &#x3D; max(have, -prices[i]); &#125; return no; &#125; &#125;; 相关题目122.买卖股票的最佳时机 Ⅱ题干 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 最大 利润 。 解法 基本思路：动态规划 因为会多次买入卖出，相对于上题121，买入的判断应为上一天就买入和上一天为买入-当天价格作比较。 递推公式： dp[i] [0] = max(dp[i-1] [0], dp[i-1] [1] - prices[i]) dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i]) Code class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int have &#x3D; -prices[0], no &#x3D; 0; for(int i &#x3D; 1; i &lt; prices.size(); ++i) &#123; int temp &#x3D; have; have &#x3D; max(have, no - prices[i]); no &#x3D; max(no, prices[i] + temp); &#125; return no; &#125; &#125;; 123.买卖股票的最佳时机 Ⅲ题干 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 解法 基本思路：动态规划 因为只买入两次，每一天的状态就不是两种而是四种：第一次持有、不持有和第二次的持有、不持有。 递推公式：要搞清楚每个状态和前一天的哪个状态相关。 dp[i] [0] = max(dp[i-1] [0], -prices[i]) dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i]) dp[i] [2] = max(dp[i-1] [2], dp[i-1] [1] - prices[i]) dp[i] [3] = max(dp[i-1] [3], dp[i-1] [2] + prices[i]) Code class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int have1 &#x3D; -prices[0], have2 &#x3D; -prices[0]; int no1 &#x3D; 0, no2 &#x3D; 0; for(int i &#x3D; 1; i &lt; prices.size(); ++i) &#123; int temp &#x3D; have1; have1 &#x3D; max(have1, -prices[i]); no2 &#x3D; max(no2, have2 + prices[i]); have2 &#x3D; max(have2, no1 - prices[i]); no1 &#x3D; max(no1, temp + prices[i]); &#125; return no2; &#125; &#125;; 188.买卖股票的最佳时机 Ⅳ题干 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格，和一个整型 k 。计算你所能获取的最大利润。最多可以买 k 次，卖 k 次。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 解法 基本思路：动态规划 在上题123的基础上进一步拓展，由两次改为不定次，那就通过循环解决，递推中，每次都是取前一天的当前状态值与前一天的上一状态值（+ / -）prices[i] 中的最大值。 Code class Solution &#123; public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(k * 2, 0); for(int i &#x3D; 0; i &lt; k; ++i) dp[i * 2] &#x3D; -prices[0]; for(int i &#x3D; 0; i &lt; prices.size(); ++i) &#123; for(int j &#x3D; k * 2 - 1; j &gt; 0; --j) dp[j] &#x3D; max(dp[j], dp[j - 1] + prices[i] * (j % 2 ? 1 : -1)); dp[0] &#x3D; max(dp[0], -prices[i]); &#125; return dp[k * 2 - 1]; &#125; &#125;; 309.买卖股票最佳时机含冷冻期题干 给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 解法 基本思路：动态规划 代码随想录中的方法是增加状态，即达到买入股票状态、达到保持卖出股票状态、达到今天就卖出股票状态、达到冷冻期状态四种状态。 但个人认为不需要考虑过于复杂，实际上冷冻期一天，在递推中也就是买入时的计算由 i - 1 变成了 i - 2。类似于122题的递推： dp[i] [0] = max(dp[i-1] [0], dp[i-2] [1] - prices[i]) dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i]) Code class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int have &#x3D; -prices[0], no &#x3D; 0, no2 &#x3D; 0; for(int i &#x3D; 1; i &lt; prices.size(); ++i) &#123; int temp &#x3D; have; have &#x3D; max(have, no2 - prices[i]); no2 &#x3D; no; no &#x3D; max(no, prices[i] + temp); &#125; return no; &#125; &#125;; 300.最长递增子序列题干 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 解法1 基本思路：动态规划 dp[i] 表示 [0, i] 区间内的子串的最长递增子序列长度。 在思考递推公式前需要先想清楚如何遍历？在数组遍历中，如果上升数组在 i 中断了（比前一个小），后序的最长子序列应该从何处累加才是正确的？因此需要二层循环，对于每一个 [0, i] 区间，都需要遍历一次，找到 dp[i] 真正的最大值。由此可以确定递推公式： dp[i] = max(dp[i], dp[j] + 1) ( 在 nums[i] &gt; nums[j] 的条件下 ) Code class Solution &#123; public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 1) return nums.size(); vector&lt;int&gt; dp(nums.size(), 1); int res &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; for(int j &#x3D; 0; j &lt; i; ++j) if(nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1); if(dp[i] &gt; res) res &#x3D; dp[i]; &#125; return res; &#125; &#125;; 解法2 基本思路：贪心 + 二分查找 解法1中的动态规划方法显然是需要双层遍历的，时间复杂度一看就是 O(n^2) ，不符合进阶的 O(n*logn) 要求。看到这个复杂度很明显是在一层循环中嵌套一个 O(logn) 的算法，涉及到递增，那么二分查找是一个好选择。那么如何只用单层遍历呢，要求最大值，可以考虑用贪心：局部最大到全局最大。 看到的一个生动的解释：杀手也不会再冷了 对于一个原序列nums[i],视为nums.size()块大小不同的砖头。要求： 1.将较小的砖头放在下方，它上面的每一块砖头都比它大 2.砌起来的砖塔尽可能的高 创建一个数组tower[]，且先令 tower[0] = nums[0]，即第一块砖，并用参数pos标记塔顶位置。 遍历nums中每一块砖： 1).若当前遍历到的砖nums[i]，比塔顶的砖大，则将其加至塔顶，即tower[pos] = nums[i]; 2).若遍历到的砖nums[i]不大于塔顶的砖，则将与下层进行对比，找到tower[]中最靠下的大于该砖nums[i]的砖，并替换之。 这么做的目的有以下几个原因： 1.由于上述的1)，已建成的塔是严格有序的（下小上大）。 2.为了使塔尽可能的高，则每一块砖应当尽可能小（贪心），因为越小的砖，它头上能容纳的砖的范围更大 3.需要注意的是，我们此处的tower[]并不一定是我们所找到的最高的塔，也即并不一定是我们最终需要的最长单调递增子序列。只有当从某一层开始，往上的每一层都发生了这种替换，最后才是我们需要的最长子序列。 举个栗子： 对于一个nums为{100,90,1,20,30,40,80,2,3,4,5,6} 按照以上思路 tower[]为 {100} {90}(100-&gt;90,替换) {1}(90-&gt;1,替换) {1,20}(添加20) {1,20,30}(添加30) {1,20,30,40}(添加40) {1,20,30,40,80}(添加80) {1,2,30,40,80}(20-&gt;2,替换) {1,2,3,40,80}(30-&gt;3,替换) {1,2,3,4,80}(40-&gt;4,替换) {1,2,3,4,5}(80-&gt;5,替换) {1,2,3,4,5,6}(添加6) 。 可以看到，该示例中比较高的塔有甲：{1,20,30,40,80}和乙：{1,2,3,4,5,6}两条。由于甲在nums[]中先出现，因此它修了5层，然后遇到了乙塔中的2这块砖。因此2找到塔中最靠下的大于2的砖20进行替换。但是这并不意味着我们的塔就变成了{1，2，30，40，80}，实际上2和20在此处是并列关系，并且它代表着一种可能性，即从2继续砌高的可能性。（这里是重点：如果乙塔的实际长度（假设4，即把原数组中的5、6去掉）小于甲，那么序列是{1，2，30，40，80}，但数组中的值已经被替换为了{1，2，3，4，80}，数组并不表示真实序列，仅表示在这个位置后，能加入递增序列的最小要求，这就是贪心的地方）后面的事实也证明确实是在2的基础上继续砌高（3，4，5，6都只能加在2的上面，而不能加在80的上面）因此，当1，2，3，4，5，6这个乙序列比甲序列长的时候，长度就会更新，并且继续在乙塔上延伸，而乙塔高度不足甲塔高度时，塔的高度不会更新。 进一步缩减空间复杂度：直接在原数组上操作。 Code class Solution &#123; public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; auto end &#x3D; nums.begin(); for(int n : nums) &#123; auto iter &#x3D; lower_bound(nums.begin(), end, n); *iter &#x3D; n; if(iter &#x3D;&#x3D; end) end++; &#125; return end - nums.begin(); &#125; &#125;; 2023.7.3674.最长连续递增序列解法 基本思路：动态规划 相比于上题300，这题要求连续子序列就简单多了，只需在遇到递减时将状态重置为1即可。 Code class Solution &#123; public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int res &#x3D; 1, dp &#x3D; 1; for(int i &#x3D; 1; i &lt; nums.size(); ++i) &#123; if(nums[i] &gt; nums[i - 1]) ++dp; else dp &#x3D; 1; res &#x3D; max(res, dp); &#125; return res; &#125; &#125;; 718.最长重复子数组题干 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 解法 基本思路：动态规划 记住动态规划的本质就是填表，全遍历。这里 dp[i] 表示 nums1 [0, i - 1] 和 nums2 [0, j - 1]范围内的最长公共子数组，是为了方便遍历，类似于一个向左边和上边的padding操作。若是表示 [0, i] ，会发现遍历时dp第一行第一列中若出现相同数字，要初始化为1。 Code class Solution &#123; public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;vector&lt;int&gt; &gt; dp(nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1, 0)); int res &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; nums1.size(); ++i) &#123; for(int j &#x3D; 1; j &lt;&#x3D; nums2.size(); ++j) &#123; if(nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1] + 1; res &#x3D; max(res, dp[i][j]); &#125; &#125; return res; &#125; &#125;; 空间优化class Solution &#123; public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; dp(nums2.size() + 1, 0); int res &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; nums1.size(); ++i) &#123; for(int j &#x3D; nums2.size(); j &gt; 0; --j) &#123; if(nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]) dp[j] &#x3D; dp[j - 1] + 1; else dp[j] &#x3D; 0; res &#x3D; max(res, dp[j]); &#125; &#125; return res; &#125; &#125;; 1143.最长公共子序列（LCS）题干 给定字符串 text1 和 text2，返回两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 解法 基本思路：动态规划 这题主要难点在推导出递推公式。有两种情况： 1.text1[i - 1] == text2[j - 1] : 此时有 dp[i] [j] = dp[i - 1] [j - 1] + 1，很好理解：代表必然使用 **text1[i - 1] 和text2[j - 1] **时LCS的长度。 2.**text1[i - 1] != text2[j - 1] : **此时 **dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1])**，因为不相等，因此必然不会同时用到这两个字符，但存在用到其中一个字符的情况，依次取两者中的最大值。 Code class Solution &#123; public: int longestCommonSubsequence(string text1, string text2) &#123; vector&lt;vector&lt;int&gt; &gt; dp(text1.size() + 1, vector&lt;int&gt;(text2.size() + 1, 0)); for(int i &#x3D; 1; i &lt;&#x3D; text1.size(); ++i) &#123; for(int j &#x3D; 1; j &lt;&#x3D; text2.size(); ++j) &#123; if(text1[i - 1] &#x3D;&#x3D; text2[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1] + 1; else dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[text1.size()][text2.size()]; &#125; &#125;; 空间优化一定要注意遍历顺序！！ 在上一题718中，dp[i] [j] 只与 左上角 dp[i-1] [j-1] 有关，体现在一维数组中就是只与它前一个值有关，因此可以反序遍历，解决覆盖问题。 但本题中，dp[i] [j] 同时与 dp[i-1] [j-1] 、dp[i] [j-1] 、dp[i-1] [j] 有关，尤其是 dp[i] [j-1] ，若反序遍历，则dp[i] [j-1] 的状态是无法更新到 dp[i] [j] 的。因此必须正序遍历，用常量存储前一个值修改前的内容来避免覆盖问题。 class Solution &#123; public: int longestCommonSubsequence(string text1, string text2) &#123; vector&lt;int&gt; dp(text2.size() + 1, 0); for(int i &#x3D; 1; i &lt;&#x3D; text1.size(); ++i) &#123; int pre &#x3D; 0; for(int j &#x3D; 1; j &lt;&#x3D; text2.size(); ++j) &#123; int temp &#x3D; dp[j]; if(text1[i - 1] &#x3D;&#x3D; text2[j - 1]) dp[j] &#x3D; pre + 1; else dp[j] &#x3D; max(dp[j], dp[j - 1]); pre &#x3D; temp; &#125; &#125; return dp[text2.size()]; &#125; &#125;; 相关题目1035.不相交的线按照题意理解一下，要在线不相交的情况下数量最多，那么线尽可能靠近垂直，并且不同线之间的相对顺序是固定的，也就是说本质就是求最长公共子序列。那么代码就和上题1143一模一样了。 53.最大子数组和题干 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。 解法 基本思路：动态规划 以前用贪心解过，只保留和为正数的子数组，取最大。 动态规划其实也是类似的思路：有两种状态，1是之前和为非负数，那么直接加上当前值；2是之前和是负数，那么从当前数重新开始计算和。过程中记录最大和即可。 Code class Solution &#123; public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre &#x3D; 0, res &#x3D; INT_MIN; for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; pre &#x3D; max(nums[i], pre + nums[i]); res &#x3D; max(res, pre); &#125; return res; &#125; &#125;; 392.判断子序列题干 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 解法 基本思路：动态规划 类似1143题的思路，将待确认子串作为外循环，在母串中：每找到一对匹配的字符，就取左上角（i-1，j-1）+1；没找到就延续前一格（i，j-1）记录的值（因为没找到新的匹配，所以长度暂时不变）。 最终目的实际依旧是求最长公共子序列，之后判断公共子序列长度是否和待确认子串相同即可。 TODO：为什么无法压缩成一维数组。。 Code class Solution &#123; public: bool isSubsequence(string s, string t) &#123; vector&lt;vector&lt;int&gt; &gt; dp(s.size() + 1, vector&lt;int&gt;(t.size() + 1, 0)); for(int i &#x3D; 1; i &lt;&#x3D; s.size(); ++i) &#123; for(int j &#x3D; 1; j &lt;&#x3D; t.size(); ++j) &#123; if(s[i - 1] &#x3D;&#x3D; t[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1] + 1; else dp[i][j] &#x3D; dp[i][j - 1]; &#125; &#125; return dp[s.size()][t.size()] &#x3D;&#x3D; s.size(); &#125; &#125;; 2023.7.6115.不同的子序列题干 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。答案符合 32 位带符号整数范围。 解法 基本思路：动态规划 对于两个字符串匹配，一个非常通用的状态定义如下： 定义 dp[i] [j] 为考虑 s 中 [0，i] 个字符，t 中 [0，j] 个字符的匹配个数。那么显然对于某个 dp[i] [j] 而言，从「最后一步」的匹配进行分析，包含两类决策： s[i] 不参与匹配，需要让 s 中 [0，i-1] 个字符去匹配 t 中的 [0，j] 字符。此时匹配值为 dp[i-1] [j] s[i] 参与匹配，这时只需让 s 中 [0，i-1] 个字符去匹配 t 中的 [0，j-1] 字符即可，同时满足 s[i] = t[j]。此时匹配值为 dp[i-1] [j-1] 显然，当出现 s[i] = t[j]时，dp值为以上两者之和，若不相等，则仅满足 s[i] 不参与匹配的情况。 Code class Solution &#123; public: int numDistinct(string s, string t) &#123; vector&lt;uint64_t&gt; dp(t.size() + 1, 0); dp[0] &#x3D; 1; for(char c : s) &#123; uint64_t pre &#x3D; 1; for(int j &#x3D; 1; j &lt;&#x3D; t.size(); ++j) &#123; uint64_t temp &#x3D; dp[j]; if(c &#x3D;&#x3D; t[j - 1]) dp[j] +&#x3D; pre; pre &#x3D; temp; &#125; &#125; return dp[t.size()]; &#125; &#125;; 583.两个字符串的删除操作题干 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。每步 可以删除任意一个字符串中的一个字符。 解法1 基本思路：动态规划 对于两个字符串匹配，一个非常通用的状态定义如下： dp[i] [j] 为使 s 中 [0，i] ，t 中 [0，j] 个字符相同所需的最少操作步数。那么对于 dp[i] [j] ，包含两类决策： s[i] = t[j]，此时不需要新增操作 dp[i] [j] = dp[i-1] [j-1] s[i] ≠ t[j]，此时有两种情况：删除 s[i - 1] 或删除 t[j - 1] 。于是可得 dp[i] [j] = min(dp[i-1] [j] + 1, dp[i] [j - 1] + 1) 。实际还有第三种情况即同时删除 s[i - 1] 和 t[j - 1] ，但是该情况（ dp[i] [j] = dp[i-1] [j-1] + 2）和删除 s[i-1]是一样的（TODO：why？） 这里需要注意的是dp数组的初始化：dp[0] [j] = j ，dp[i] [0] = i 。当 t 为空时，s显然需要删除全部的字符才能相同，因此必然有 dp[i] [0] = i 。反之同理。 下面代码为压缩空间后的一维数组解法，要注意外循环中 dp[0] = i 相当于对二维数组中第一列的初始化，而pre保存的是左上角的值（i-1，j-1），因此初始化时应为上一层的 dp[0]，那也就是 i - 1。 Code class Solution &#123; public: int minDistance(string word1, string word2) &#123; vector&lt;int&gt; dp(word2.size() + 1); for(int i &#x3D; 0; i &lt; dp.size(); ++i) dp[i] &#x3D; i; for(int i &#x3D; 1; i &lt;&#x3D; word1.size(); ++i) &#123; int pre &#x3D; i - 1; dp[0] &#x3D; i; for(int j &#x3D; 1; j &lt;&#x3D; word2.size(); ++j) &#123; int temp &#x3D; dp[j]; if(word1[i - 1] &#x3D;&#x3D; word2[j - 1]) dp[j] &#x3D; pre; else dp[j] &#x3D; min(dp[j] + 1, dp[j - 1] + 1); pre &#x3D; temp; &#125; &#125; return dp[word2.size()]; &#125; &#125;; 解法2 将问题转化为LCS问题，最少删除多少次后两个字符串相等，相当于求公共子串与俩字符串的长度差值的和。 return word1.size() + word2.size() - dp[word2.size()] * 2; 2023.7.772.编辑距离题干 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。 解法 基本思路：动态规划 动态规划题还是要冷静思考，找到递推关系。 显然如果两个字符相同，那么就不需要任何操作，dp[i] [j] = dp[i-1] [j-1] 如果不同，则有三种操作方法： 替换，最容易想到——增加了一步操作 dp[i-1] [j-1] + 1 删除，假设删除 word1的第 i 个字符，那么问题就变成了 dp[i-1] [j] 的最小操作数，加上删除 i 这一步。也就是 dp[i-1] [j] + 1；删除 word2，也是同理：dp[i] [j-1] + 1 插入和删除实际是同理：word1删除一个字符，相当于在word2加入一个和word1[i]相同的字符。 Code class Solution &#123; public: int minDistance(string word1, string word2) &#123; vector&lt;int&gt; dp(word2.size() + 1, 0); for(int i &#x3D; 0; i &lt; dp.size(); ++i) dp[i] &#x3D; i; for(int j &#x3D; 1; j &lt;&#x3D; word1.size(); ++j) &#123; int pre &#x3D; j - 1; dp[0] &#x3D; j; for(int i &#x3D; 1; i &lt;&#x3D; word2.size(); ++i) &#123; int temp &#x3D; dp[i]; if(word1[j - 1] &#x3D;&#x3D; word2[i - 1]) dp[i] &#x3D; pre; else dp[i] &#x3D; min(&#123;dp[i], dp[i - 1], pre&#125;) + 1; pre &#x3D; temp; &#125; &#125; return dp[word2.size()]; &#125; &#125;; 647.回文子串题干 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 解法1 基本思路：动态规划、双指针 这题没法直接按题意定义dp数组，因为无法找到递推关系。要考虑到回文子串的特点：回文串（len &gt; 2）去掉左右两边的字符后依旧是一个回文串。这就是递推关系：字符串是不是回文串是由去掉两边后的字符串来决定的。 因此dp定义：dp[i] [j] 表示 s 在 [i, j] 范围内的子串是否为回文串，类型为bool，通过变量统计true的数量。 递推关系：当遍历到的两个字符不同时，显然为false；当相同时，会出现两种情况： 如果子串长度为1或2，字符相同则必然是回文串 如果长度大于2，则根据递推，由 dp[i+1] [j-1] 来决定 根据上述第二种情况，在遍历时要优先遍历到（i，j）的左下角，那么先下后上，从左至右的顺序就确定了。同时因为是 [i, j] 范围内，那么 j 的遍历必然是从 i 开始的。 这个动规数组的设计中其实也包含着双指针的思想。 Code class Solution &#123; public: int countSubstrings(string s) &#123; vector&lt;vector&lt;bool&gt; &gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); int res &#x3D; 0; for(int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; --i) &#123; for(int j &#x3D; i; j &lt; s.size(); ++j) &#123; if(s[i] &#x3D;&#x3D; s[j] &amp;&amp; (j - i &lt;&#x3D; 1 || dp[i + 1][j - 1])) &#123; ++res; dp[i][j] &#x3D; true; &#125; &#125; &#125; return res; &#125; &#125;; 解法2 基本思路：双指针 上述dp的递推中实际已经体现了双指针实现回文串的核心思想：回文串的基础是长度为1或2的子串。 通过遍历整个字符串，以每个字符、该字符与后一位字符为基础计算可以形成的回文子串数。 class Solution &#123; public: int countSubstrings(string s) &#123; auto countSub &#x3D; [&amp;s](int i, int j) &#123; int res &#x3D; 0; while(i &gt;&#x3D; 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i--] &#x3D;&#x3D; s[j++]) ++res; return res; &#125;; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; s.size(); ++i) &#123; res +&#x3D; countSub(i, i); res +&#x3D; countSub(i, i+1); &#125; return res; &#125; &#125;; 2023.7.8516.最长回文子序列题干 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 解法 基本思路：动态规划 子序列相对于子串的处理要更简单。思路类似于 647.回文子串，不过求的是最大长度，因此递推公式： 相等，在（i+1，j-1）的基础上+2 不等，即无法同时添加两个字符，那么选择添加其中一个，取最大值。 Code class Solution &#123; public: int longestPalindromeSubseq(string s) &#123; vector&lt;vector&lt;int&gt; &gt; dp(s.length(), vector&lt;int&gt;(s.length(), 0)); for(int i &#x3D; 0; i &lt; s.length(); ++i) dp[i][i] &#x3D; 1; for(int i &#x3D; s.length() - 2; i &gt;&#x3D; 0; --i) &#123; for(int j &#x3D; i+1; j &lt; s.length(); ++j) &#123; if(s[i] &#x3D;&#x3D; s[j]) dp[i][j] &#x3D; dp[i+1][j-1] + 2; else dp[i][j] &#x3D; max(dp[i][j-1], dp[i+1][j]); &#125; &#125; return dp[0][s.length()-1]; &#125; &#125;; 空间优化 class Solution &#123; public: int longestPalindromeSubseq(string s) &#123; vector&lt;int&gt; dp(s.length(), 0); for(int i &#x3D; s.length() - 1; i &gt;&#x3D; 0; --i) &#123; dp[i] &#x3D; 1; int pre &#x3D; 0; for(int j &#x3D; i+1; j &lt; s.length(); ++j) &#123; int tmp &#x3D; dp[j]; if(s[i] &#x3D;&#x3D; s[j]) dp[j] &#x3D; pre + 2; else dp[j] &#x3D; max(dp[j-1], dp[j]); pre &#x3D; tmp; &#125; &#125; return dp[s.length()-1]; &#125; &#125;; 2023.7.10739.每日温度题干 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 解法 基本思路：单调栈 因为是找右边第一个比自己大的元素，因此应手动维护栈为递减（栈底——&gt;栈顶）。即每当遍历到一个元素时，将栈中比这个元素小的元素全部出栈，并记录结果即可。 Code class Solution &#123; public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; vector&lt;int&gt; res(temperatures.size()); stack&lt;int&gt; st; for(int i &#x3D; 0; i &lt; temperatures.size(); ++i) &#123; while(!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()]) &#123; res[st.top()] &#x3D; i - st.top(); st.pop(); &#125; st.push(i); &#125; return res; &#125; &#125;; 496.下一个更大元素题干 nums1 中 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素，若不存在返回**-1**。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。 解法 基本思路：单调栈 思路同上，相当于找到 nums2中每个元素的下一个更大元素的值，记录为键值对，之后遍历 nums1，取出这些元素对应的值，加入vector中。本质是一种空间换时间的解法。 第二种是正常解法。 Code class Solution &#123; public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; hash; stack&lt;int&gt; st; for(int i &#x3D; nums2.size() - 1; i &gt;&#x3D; 0; --i) &#123; while(!st.empty() &amp;&amp; nums2[i] &gt; st.top()) st.pop(); hash[nums2[i]] &#x3D; st.empty() ? -1 : st.top(); st.push(nums2[i]); &#125; for(int&amp; n : nums1) res.emplace_back(hash[n]); return res; &#125; &#125;; class Solution &#123; public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res(nums1.size(), -1); for(int i &#x3D; 0; i &lt; nums1.size(); ++i) &#123; vector&lt;int&gt;::iterator iter &#x3D; find(nums2.begin(), nums2.end(), nums1[i]); while(iter !&#x3D; nums2.end() &amp;&amp; nums1[i] &gt;&#x3D; *iter) ++iter; if(iter !&#x3D; nums2.end()) res[i] &#x3D; *iter; &#125; return res; &#125; &#125;; 相关题目503.下一个更大元素 Ⅱ题干 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。如果不存在，则输出 -1 。 解法 基本思路：单调栈 思路还是一样的，区别就是最后一个元素不是直接返回-1，而是需要再遍历一遍数组。 Code class Solution &#123; public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int n &#x3D; nums.size(); vector&lt;int&gt; res(n, -1); stack&lt;int&gt; st; for(int i &#x3D; 0; i &lt; n * 2; ++i) &#123; while(!st.empty() &amp;&amp; nums[i % n] &gt; nums[st.top()]) &#123; res[st.top()] &#x3D; nums[i % n]; st.pop(); &#125; st.push(i % n); &#125; return res; &#125; &#125;; 42.接雨水题干 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解法 基本思路：单调栈 凹槽才能接雨水，因此当遍历到的元素比栈顶元素更大时说明找到了一个凹槽，因此应维护单调栈为递减。 第二步需要思考的是应该按行计算容量还是按列？如图中第二个凹槽，实际为两行三列，而单调递减栈在碰到更大的元素时就会处理，不确定是否是右侧最高的，因此按列计算无法找到列高，需按行计算。 按行计算需要得到两个数据：行高和列宽。 行高：以栈顶元素为底，取其左右两边（栈顶下一个元素和当前遍历元素）的较小值为顶，计算插值，得到未计算部分中最底下一层的行高。 列宽：左右两边的下标差值 - 1。 因为维护的是单调递减栈，说明凹槽左侧有多个不同高度的柱子，当前遍历高度要依次与栈中元素比较，每出栈一个小元素 x，就代表计算了这块凹槽中的一层（高度为栈顶元素高度 - x）；直到遍历的元素加入栈后，说明该元素左侧以该元素为最高高度的部分容量已经计算完成了。此时就形成了这个大元素遍历之前的情况：栈中只有递减排列的元素。重复这一过程直至遍历结束，就能找到所有的凹槽。 Code class Solution &#123; public: int trap(vector&lt;int&gt;&amp; height) &#123; int res &#x3D; 0; stack&lt;int&gt; st; st.push(0); for(int i &#x3D; 1; i &lt; height.size(); ++i) &#123; while(!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123; int mid &#x3D; st.top(); st.pop(); if(!st.empty()) &#123; int h &#x3D; min(height[i], height[st.top()]) - height[mid]; int w &#x3D; i - st.top() - 1; res +&#x3D; h * w; &#125; &#125; st.push(i); &#125; return res; &#125; &#125;; 相关题目84.柱状图中最大的矩形题干 给定 n 个非负整数，表示柱状图中柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 输入：heights &#x3D; [2,1,5,6,2,3] 输出：10 解法1 基本思路：单调栈 这题的思路和上题 42.接雨水相似，区别在于找的是两边第一个小于该元素的位置，因此维护为递增栈。 需要注意边界问题，对于左右两侧的柱子，其外层均应设置为高度为0的柱子，才能保证计算面积时没有遗漏。 找到小于元素的值，是为了找到面积计算的左右边界，因此应取每次的栈顶元素值为面积的高，宽度为当前元素与栈顶元素位置的差值。遍历是为了找到右边界，而左边界就是栈底元素。 Code class Solution &#123; public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res &#x3D; 0; heights.emplace(heights.begin(), 0); heights.emplace_back(0); stack&lt;int&gt; st; st.push(0); for(int i &#x3D; 1; i &lt; heights.size(); ++i) &#123; while(heights[i] &lt; heights[st.top()]) &#123; int h &#x3D; heights[st.top()]; st.pop(); int w &#x3D; i - st.top() - 1; res &#x3D; max(res, h * w); &#125; st.push(i); &#125; return res; &#125; &#125;; 解法2 基本思路：双指针 这题和上题都可以用双指针的思路解决，相对于单调栈，需要用两个数组分别存储左右边界的信息，因此属于是空间换时间。 Code class Solution &#123; public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int n &#x3D; heights.size(); vector&lt;int&gt; l(n, -1); vector&lt;int&gt; r(n, n); for(int i &#x3D; 1; i &lt; n; ++i) &#123; int idx &#x3D; i - 1; while(idx &gt;&#x3D; 0 &amp;&amp; heights[idx] &gt;&#x3D; heights[i]) idx &#x3D; l[idx]; l[i] &#x3D; idx; &#125; for(int i &#x3D; n - 2; i &gt;&#x3D; 0; --i) &#123; int idx &#x3D; i + 1; while(idx &lt; n &amp;&amp; heights[idx] &gt;&#x3D; heights[i]) idx &#x3D; r[idx]; r[i] &#x3D; idx; &#125; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; n; ++i) res &#x3D; max(res, heights[i] * (r[i] - l[i] - 1)); return res; &#125; &#125;; 2023.7.111911.最大子序列交替和题干 一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。 比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。 给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。 解法 基本思路：动态规划 这种求最大的题很容易想到动态规划。类似于 [122.买卖股票的最佳时机 Ⅱ](#122.买卖股票的最佳时机 Ⅱ) 那么分析递推情况： 在构造子序列时，每个元素 nums[i]都面临两个选择： 不选择这个元素构造子序列，那么最大交替和和前一状态是相同的。 选择这个元素。 此时又有两种情况： 这个元素作为偶数下标加入子序列，即此时子序列的长度为奇数。 这个元素作为奇数下标加入子序列，即此时子序列的长度为偶数。 可以发现，当一个元素作为偶数下标加入子序列后长度变为奇数，说明加入前长度为偶数，并在这一状态下加上该元素。反之，则是从长度为奇数的上一状态减去该元素。两者的状态是相关的。 因此需要设定两个dp数组：even表示长度为偶数的子序列的最大交替和，odd表示长度为奇数的。递推公式： even[i] = max(even[i-1], odd[i-1] - nums[i]) odd[i] = max(odd[i-1], even[i-1] + nums[i]) Code class Solution &#123; public: long long maxAlternatingSum(vector&lt;int&gt;&amp; nums) &#123; long long even &#x3D; 0, odd &#x3D; 0; for(int&amp; n : nums) &#123; long long tmp &#x3D; odd; odd &#x3D; max(odd, even + n); even &#x3D; max(even, tmp - n); &#125; return odd; &#125; &#125;; 解法2 基本思路：贪心 求最大交替和，偶数下标 + ，奇数下标 - 。那么很明显最大交替和的子序列长度一定为奇数。那我们先排除原数组中的第一个元素，在后续元素中挑选组成子序列的成员，那么就是 -、+、-、+的顺序。 当两个数是递增状态时，添加这两个数是有益于增加交替和的，为局部最优；当两个数为递减时，和小于0，需要舍去。由此局部可以推至全局最优，贪心贪的是两个数的和都为正数。 那对于数组中第一个元素如何处理？可以在数组最开始假定有一个0，不会影响和的结果，这样即可从头遍历数组，每次取两个元素间大于0的差值计算累加和，求得最终结果。 Code class Solution &#123; public: long long maxAlternatingSum(vector&lt;int&gt;&amp; nums) &#123; int pre &#x3D; 0; long long res &#x3D; 0; for(int&amp; n : nums) &#123; res +&#x3D; max(n - pre, 0); pre &#x3D; n; &#125; return res; &#125; &#125;; 1365.有多少小于当前数字的数字题干 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 输入：nums &#x3D; [8,1,2,2,3] 输出：[4,0,1,1,3] 解法 基本思路：排序、哈希 首先是统计更小数字的数目，对数组排序后，下标的值就是正确答案。 其次要以按原数组的顺序返回数目，因此需要快速查找到值，选择哈希表存储答案。注意对于相同的数字，应按照排序后数组中的第一个数字的下标为答案，因此在使用哈希表记录时，可以从后向前遍历，这样相同数字的答案最后就会被第一个值覆盖。 Code class Solution &#123; public: vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; add &#x3D; nums; sort(add.begin(), add.end()); int hash[101] &#x3D; &#123;0&#125;; for(int i &#x3D; add.size() - 1; i &gt;&#x3D; 0; --i) hash[add[i]] &#x3D; i; for(int&amp; n : nums) n &#x3D; hash[n]; return nums; &#125; &#125;; 941.有效的山脉数组题干 给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组： arr.length &gt;= 3 在 0 &lt; i &lt; arr.length - 1 条件下，存在 i 使得： arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1] 输入：arr &#x3D; [4,3,2,1] 输出：false 解法 基本思路：双指针 最朴素的方式就是记录第一个下降点，将标志位置位，之后若再有上升点则返回false。 双指针的方法更好理解一些，从两头向中间遍历，都应是从大到小的顺序，如果有不符时就停止移动。最后双指针重合且不在两端（两端，存在整个数组都是顺序的情况）则说明是山脉。 Code class Solution &#123; public: bool validMountainArray(vector&lt;int&gt;&amp; arr) &#123; if(arr.size() &lt; 3) return false; int n &#x3D; arr.size() - 1; int l &#x3D; 0, r &#x3D; n; while(l &lt; n &amp;&amp; arr[l] &lt; arr[l+1]) ++l; while(l &gt; 0 &amp;&amp; arr[r] &lt; arr[r-1]) --r; return l &#x3D;&#x3D; r &amp;&amp; l !&#x3D; 0 &amp;&amp; r !&#x3D; n; &#125; &#125;; 1207.有效的山脉数组题干 整数数组 arr，统计数组中每个数的出现次数。如果出现次数都是独一无二的，返回 true；否则返回 false。 输入：arr &#x3D; [1,2,2,1,1,3] 输出：true 解法 基本思路：哈希 两个哈希，一个 统计数量，一个统计是否出现过 Code class Solution &#123; public: bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123; unordered_map&lt;int, int&gt; hash; bool exist[1001] &#x3D; &#123;false&#125;; for(int&amp; n : arr) hash[n]++; for(auto&amp; p : hash) &#123; if(exist[p.second]) return false; exist[p.second] &#x3D; true; &#125; return true; &#125; &#125;; 2023.7.122544.交替数字和解法 基本思路：模拟 数学计算，从低往高每次取一位数字乘以符号位累加，最后结果 * -sign。符号位假设末位是正，若最高位也是正，则最后sign为-1，乘以-sign相对于不动；反之则是 * -1。 Code class Solution &#123; public: int alternateDigitSum(int n) &#123; int res &#x3D; 0, sign &#x3D; 1; while(n &gt; 0) &#123; res +&#x3D; n % 10 * sign; sign &#x3D; -sign; n &#x2F;&#x3D; 10; &#125; return -sign * res; &#125; &#125;; 283.移动零解法 基本思路：双指针 一个用于遍历，一个指向下一个非零数字的位置。 Code class Solution &#123; public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; for(int i &#x3D; 0, idx &#x3D; 0; i &lt; nums.size(); ++i) if(nums[i]) swap(nums[i], nums[idx++]); &#125; &#125;; 189.轮转数组题干 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 解法 基本思路：字符串反转 整体反转，然后再局部分别反转，就能实现轮转的效果。 Code class Solution &#123; public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k &#x3D; k % nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); &#125; &#125;; 724.寻找数组的中心下标解法 基本思路：前缀和 代码随想录里的写法有问题，顺序反了，应该先判断再累加。因为遍历的当前元素是不应该在左侧累加和中的。 Code class Solution &#123; public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int sum &#x3D; 0; for(int&amp; n : nums) sum +&#x3D; n; int l &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; if(sum &#x3D;&#x3D; 2 * l + nums[i]) return i; l +&#x3D; nums[i]; &#125; return -1; &#125; &#125;; 34.在排序数组中查找元素的第一个和最后一个位置解法 基本思路：二分查找 有序数组查找、O(logn) ，第一反应就是二分查找。这里的注意点在于二分查找找到的第一个元素可能是任意位置的，不一定是边界。因此在找到时不能直接return，而是继续压缩边界。如果想找左边界，就压缩右边界，每次找到都更新下标值，直至双指针交错，就能得到边界值了。 Code class Solution &#123; public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &#x3D;&#x3D; 0) return &#123;-1, -1&#125;; auto binarySearch &#x3D; [&amp;](bool left) -&gt; int &#123; int low &#x3D; 0, high &#x3D; nums.size() - 1, res &#x3D; -1; while(low &lt;&#x3D; high) &#123; int mid &#x3D; (low + high) &#x2F; 2; if(nums[mid] &lt; target) low &#x3D; mid + 1; else if(nums[mid] &gt; target) high &#x3D; mid - 1; else &#123; res &#x3D; mid; if(left) high &#x3D; mid - 1; else low &#x3D; mid + 1; &#125; &#125; return res; &#125;; return &#123;binarySearch(true), binarySearch(false)&#125;; &#125; &#125;; 922.按奇偶排序数组 Ⅱ解法 基本思路：双指针 双指针一个指向偶数位，一个指向奇数位。当在偶数位遇到奇数时，就向后遍历奇数位，找到第一个奇数位上的偶数位，两者交换即可。 Code class Solution &#123; public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; nums) &#123; for(int i &#x3D; 0, odd &#x3D; 1; i &lt; nums.size(); i +&#x3D; 2) &#123; if(nums[i] % 2) &#123; while(nums[odd] % 2) odd +&#x3D; 2; swap(nums[i], nums[odd]); &#125; &#125; return nums; &#125; &#125;; 35.搜索插入位置解法 基本思路：二分查找 在二分查找的基础上，理解插入的位置。在闭区间的前提下，应为左指针的位置或右指针位置 + 1。 Code class Solution &#123; public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt;&#x3D; r) &#123; int mid &#x3D; (l + r) &#x2F; 2; if(nums[mid] &lt; target) l &#x3D; mid + 1; else if(nums[mid] &gt; target) r &#x3D; mid - 1; else return mid; &#125; return l; &#125; &#125;; 2023.7.13931.下降路径最小和解法 基本思路：动态规划 一看就是动规。dp[i] [j] 表示到坐标为（i，j-1）位置的下降路径最小和。这里 [j] 长度为 n + 2 是因为便于计算。 递推就是上一行左上角正上方和右上角的dp值的最小值加上当前值。空间优化后如下： Code class Solution &#123; public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n &#x3D; matrix.size(); vector&lt;int&gt; dp(n+2); for(int i &#x3D; 1; i &lt;&#x3D; n; ++i) dp[i] &#x3D; matrix[0][i-1]; dp[0] &#x3D; dp[n+1] &#x3D; INT_MAX; for(int i &#x3D; 1; i &lt; n; ++i) &#123; int pre &#x3D; INT_MAX; for(int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123; int tmp &#x3D; dp[j]; dp[j] &#x3D; min(&#123;pre, dp[j], dp[j+1]&#125;) + matrix[i][j-1]; pre &#x3D; tmp; &#125; &#125; return *min_element(dp.begin(), dp.end()); &#125; &#125;; 2023.7.15234.回文链表解法 基本思路：翻转链表 基础想法就是遍历链表将值都取出来存入数组，然后用双指针判断数组是否是回文即可。 空间优化：O(1) 空间复杂度就需要直接在链表上判断回文，但是单链表是无法向前遍历的。可以思考，如果将链表的后半段翻转过来，那是不是就是两段链表都从头开始遍历了。 因此先通过快慢指针，找到链表的中间节点，之后将链表分割为两部分，翻转后半部分，最后判断相同。 Code class Solution &#123; public: bool isPalindrome(ListNode* head) &#123; if(head-&gt;next &#x3D;&#x3D; nullptr) return true; ListNode* pre; ListNode* fast &#x3D; head; ListNode* slow &#x3D; head; while(fast &amp;&amp; fast-&gt;next) &#123; pre &#x3D; slow; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; &#125; pre-&gt;next &#x3D; nullptr; pre &#x3D; head; auto revNodes &#x3D; [](ListNode* root) &#123; ListNode* tmp; ListNode* cur &#x3D; root; ListNode* pre &#x3D; nullptr; while(cur) &#123; tmp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; pre; pre &#x3D; cur; cur &#x3D; tmp; &#125; return pre; &#125;; fast &#x3D; revNodes(slow); while(pre) &#123; if(pre-&gt;val !&#x3D; fast-&gt;val) return false; pre &#x3D; pre-&gt;next; fast &#x3D; fast-&gt;next; &#125; return true; &#125; &#125;; 相关题目143.重排链表解法 基本思路：翻转链表 思路和上题234.回文链表类似，同样是取到后半段的翻转链表，然后遍历插入前半段。 细节注意：上题中求回文 ，因此对于奇数长度的链表中点是放在后半段的，但本题是需要放在前半段的，因此要调一下头指针的位置。 Code &#x2F;&#x2F; ...... if(fast) &#123; &#x2F;&#x2F; 细节 slow &#x3D; slow-&gt;next; pre &#x3D; pre-&gt;next; &#125; pre-&gt;next &#x3D; nullptr; pre &#x3D; head; fast &#x3D; revNodes(slow); while(fast) &#123; ListNode* tmp &#x3D; pre-&gt;next; pre-&gt;next &#x3D; fast; fast &#x3D; fast-&gt;next; pre-&gt;next-&gt;next &#x3D; tmp; pre &#x3D; pre-&gt;next-&gt;next; &#125; 141.环形链表解法 基本思路：双指针 快慢指针，若无环，快指针直接到终点，返回false。若有环，则快慢指针一直在环内遍历，快指针必然会套慢指针一圈，此时两个指针相等，说明存在环。 Code class Solution &#123; public: bool hasCycle(ListNode *head) &#123; ListNode* slow &#x3D; head; ListNode* fast &#x3D; head; while(fast &amp;&amp; fast-&gt;next) &#123; fast &#x3D; fast-&gt;next-&gt;next; slow &#x3D; slow-&gt;next; if(fast &#x3D;&#x3D; slow) return true; &#125; return false; &#125; &#125;; 2023.7.16205.同构字符串解法 基本思路：哈希表 记录从 s 到 t 和 从 t 到 s 的字符映射。因为同构是互为对方的唯一映射，因此需要两个方向，也就是两个哈希。 Code class Solution &#123; public: bool isIsomorphic(string s, string t) &#123; unordered_map&lt;char, char&gt; hash1, hash2; for(int i &#x3D; 0; i &lt; s.length(); ++i) &#123; if(hash1.count(s[i]) &#x3D;&#x3D; 0) hash1[s[i]] &#x3D; t[i]; if(hash2.count(t[i]) &#x3D;&#x3D; 0) hash2[t[i]] &#x3D; s[i]; if(hash1[s[i]] !&#x3D; t[i] || hash2[t[i]] !&#x3D; s[i]) return false; &#125; return true; &#125; &#125;; 1002.查找共用字符解法 基本思路：哈希表 很容易想到哈希，难点在于统计字符在每个字符串中出现的次数：取所有字符串中该字符出现数量的最小值。 使用一个全局哈希表，维护每个字符在各个字符串中出现的最小数量，初始化为第一个字符串。 使用一个临时哈希表，遍历保存剩余的每个字符串所有字符的出现数量，并每次都和全局哈希的值中取最小值来更新全局哈希。最后得到的哈希表记录的就是公共字符出现的数量了。卡哥nb。 Code class Solution &#123; public: vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; words) &#123; int hash[26] &#x3D; &#123;0&#125;; for(char&amp; c : words[0]) ++hash[c - &#39;a&#39;]; for(int i &#x3D; 1; i &lt; words.size(); ++i) &#123; int otherHash[26] &#x3D; &#123;0&#125;; for(char&amp; c : words[i]) ++otherHash[c - &#39;a&#39;]; for(int i &#x3D; 0; i &lt; 26; ++i) hash[i] &#x3D; min(hash[i], otherHash[i]); &#125; vector&lt;string&gt; res; for(int i &#x3D; 0; i &lt; 26; ++i) while(hash[i]--) res.push_back(string(1, i + &#39;a&#39;)); return res; &#125; &#125;; 2023.7.17415.字符串相加解法 基本思路：双指针 分别指向两个字符串的末尾，同步向前遍历，计算字符和的末位和进位。 Code class Solution &#123; public: string addStrings(string num1, string num2) &#123; int i &#x3D; num1.length() - 1, j &#x3D; num2.length() - 1; int carry &#x3D; 0; string res &#x3D; &quot;&quot;; for(; i &gt;&#x3D; 0 || j &gt;&#x3D; 0 || carry; --i, --j) &#123; int n1 &#x3D; i &gt;&#x3D; 0 ? num1[i] - &#39;0&#39; : 0; int n2 &#x3D; j &gt;&#x3D; 0 ? num2[j] - &#39;0&#39; : 0; carry +&#x3D; n1 + n2; res.push_back(carry % 10 + &#39;0&#39;); carry &#x3D; carry &#x2F; 10; &#125; reverse(res.begin(), res.end()); return res; &#125; &#125;; 925.字符串相加解法 基本思路：双指针、模拟 双指针遍历时，若两个字符不同，存在两种情况：1.第一个就不同，直接return；2.后面不同时，若typed和前一个字符相同，则指针 j 右移，若 j 移完了还不同，直接return。 结束循环后判断哪个字符串没有匹配完，若是name，直接return；若是typed，判断剩余字符是否都相同。 Code class Solution &#123; public: bool isLongPressedName(string name, string typed) &#123; int i &#x3D; 0, j &#x3D; 0; for(; i &lt; name.size() &amp;&amp; j &lt; typed.size(); ++i, ++j) &#123; if(name[i] !&#x3D; typed[j]) &#123; if(j &#x3D;&#x3D; 0) return false; while(j &lt; typed.size() &amp;&amp; typed[j] &#x3D;&#x3D; typed[j - 1]) ++j; if(name[i] !&#x3D; typed[j]) return false; &#125; &#125; if(i &lt; name.size()) return false; while(j &lt; typed.size() &amp;&amp; typed[j] &#x3D;&#x3D; typed[j - 1]) ++j; return j &gt;&#x3D; typed.size(); &#125; &#125;; 844.比较含退格的字符串解法 基本思路：双指针 最简单不动脑的就是用栈来模拟删除了。如果不用，就得用一个变量维护退格的数量，记录在退格过程中再次遇到的退格符。 Code class Solution &#123; public: bool backspaceCompare(string s, string t) &#123; int i &#x3D; s.length()-1, j &#x3D; t.length()-1; for(; i &gt;&#x3D; 0 || j &gt;&#x3D; 0; --i, --j) &#123; int back &#x3D; 0; while(i &gt;&#x3D; 0) &#123; if(s[i] &#x3D;&#x3D; &#39;#&#39;) ++back; else if(!back--) break; --i; &#125; back &#x3D; 0; while(j &gt;&#x3D; 0) &#123; if(t[j] &#x3D;&#x3D; &#39;#&#39;) ++back; else if(!back--) break; --j; &#125; if(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; t[j]) return false; &#125; return i &#x3D;&#x3D; j; &#125; &#125;; 129.求根节点到叶节点数字之和解法 基本思路：回溯 可以发现本题只需要找到根节点到所有叶节点的路径即可，不需要处理中间节点，因此无所谓前中后序。 确定终止条件：到达叶节点，累加该路径生成的数字。 确定单层逻辑：如果子节点存在，添加一位数字，进入下一层递归，然后回溯。 Code class Solution &#123; public: int sumNumbers(TreeNode* root) &#123; int sum &#x3D; 0; string path &#x3D; &quot;&quot;; path +&#x3D; root-&gt;val + &#39;0&#39;; auto backTrack &#x3D; [&amp;, circle &#x3D; [&amp;](auto&amp;&amp; self, TreeNode* cur) -&gt; void &#123; if(!cur-&gt;left &amp;&amp; ! cur-&gt;right) &#123; sum +&#x3D; stoi(path); return; &#125; if(cur-&gt;left) &#123; path +&#x3D; cur-&gt;left-&gt;val + &#39;0&#39;; self(self, cur-&gt;left); path.pop_back(); &#125; if(cur-&gt;right) &#123; path +&#x3D; cur-&gt;right-&gt;val + &#39;0&#39;; self(self, cur-&gt;right); path.pop_back(); &#125; &#125; ]() &#123; circle(circle, root); &#125;; backTrack(); return sum; &#125; &#125;; 2023.7.181851.包含每个查询的最小区间题干 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 的表达是 righti - lefti + 1 。 再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti &lt;= queries[j] &lt;= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。 输入：intervals &#x3D; [[2,3],[2,5],[1,8],[20,25]], queries &#x3D; [2,19,5,22] 输出：[2,-1,4,6] 解法 基本思路：排序、离线查询、小根堆（优先队列） 简单的暴力双层循环取最小长度，会超时，因此需要优化遍历方式。 如果把queries也排序并记录下标，好处在于内层循环不需要从intervals 头开始遍历了，而是可以从上一个下标idx处开始遍历，这是优化，但是存在问题，即两个查询值符合的区间有重叠的情况下，很难去处理 idx。 由此引入了小根堆，维护区间的长度由小到大存储。放宽存储条件，凡是查询值 ≥ 区间左边界的区间长度和区间右边界均可加入小根堆。之后将小根堆顶 区间右边界 &lt; 查询值 的元素剔除，那么之后的堆顶元素就是答案。 进入下一个查询值时，因为必然大于上一个，那么之前加入小根堆的元素必然也是符合存储条件的，而上一轮被剔除的元素也是符合剔除条件的，此时两个查询值符合的区间有重叠的情况已经存入小根堆中了，因此就可以接着使用 idx++ 向后遍历了。 Code class Solution &#123; public: vector&lt;int&gt; minInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; queries) &#123; sort(intervals.begin(), intervals.end()); using pii &#x3D; pair&lt;int, int&gt;; vector&lt;pii&gt; query; for(int i &#x3D; 0; i &lt; queries.size(); ++i) query.emplace_back(queries[i], i); sort(query.begin(), query.end()); priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; que; int idx &#x3D; 0; for(auto&amp; [n, i] : query) &#123; while(idx &lt; intervals.size() &amp;&amp; intervals[idx][0] &lt;&#x3D; n) &#123; que.emplace(intervals[idx][1] - intervals[idx][0] + 1, intervals[idx][1]); ++idx; &#125; while(!que.empty() &amp;&amp; que.top().second &lt; n) que.pop(); queries[i] &#x3D; que.empty() ? -1 : que.top().first; &#125; return queries; &#125; &#125;; 1382.将二叉搜索树变平衡题干 给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。 解法 基本思路：BST、平衡 先用中序遍历将BST转化为有序数组，再将有序数组构造为平衡BST。 Code class Solution &#123; public: TreeNode* balanceBST(TreeNode* root) &#123; vector&lt;int&gt; nums; auto tree2SortedArray &#x3D; [&amp;nums, circle &#x3D; [&amp;](auto&amp;&amp; self, TreeNode* cur) -&gt; void &#123; if(cur &#x3D;&#x3D; nullptr) return; self(self, cur-&gt;left); nums.emplace_back(cur-&gt;val); self(self, cur-&gt;right); return; &#125; ](TreeNode* root) &#123; circle(circle, root); &#125;; auto SortedArray2BBST &#x3D; [&amp;nums, circle &#x3D; [&amp;](auto&amp;&amp; self, int l, int r) -&gt; TreeNode* &#123; if(l &gt; r) return nullptr; int mid &#x3D; (l + r) &#x2F; 2; TreeNode* node &#x3D; new TreeNode(nums[mid]); node-&gt;left &#x3D; self(self, l, mid - 1); node-&gt;right &#x3D; self(self, mid + 1, r); return node; &#125; ]() &#123; return circle(circle, 0, nums.size() - 1); &#125;; tree2SortedArray(root); return SortedArray2BBST(); &#125; &#125;; 2023.7.19874.模拟行走机器人解法 基本思路：哈希、模拟、自定义类 很明显题意需要判断走过的每一步是否存在障碍物，可以通过 unordered_set 用哈希快速判断。整体就是模拟转向和前进两种情况。 由于数组坐标的形式判断哈希略显麻烦，刚好昨天看了运算符重载相关，就自定义了一个 Point 类，重载了 ==、+、-三个运算符。要注意的是，unordered_set 使用的是 std::hash 来计算哈希的key，但是没有针对自定义类的计算方式的，因此在初始化哈希表时要自定义哈希函数。 Code class Solution &#123; public: class Point &#123; public: int x; int y; Point(int x, int y) &#123; this-&gt;x &#x3D; x; this-&gt;y &#x3D; y; &#125; int empow() &#123; return x * x + y * y; &#125; bool operator&#x3D;&#x3D;(const Point&amp; p) const &#123; return x &#x3D;&#x3D; p.x &amp;&amp; y &#x3D;&#x3D; p.y; &#125; Point operator+(const Point&amp; p) const &#123; Point tmp(x, y); tmp.x &#x3D; x + p.x; tmp.y &#x3D; y + p.y; return tmp; &#125; Point operator-(const Point&amp; p) const &#123; Point tmp(x, y); tmp.x &#x3D; x - p.x; tmp.y &#x3D; y - p.y; return tmp; &#125; &#125;; struct myhash &#123; size_t operator() (const Point&amp; p) const &#123; return hash&lt;int&gt;()(p.x) ^ hash&lt;int&gt;()(p.y); &#125; &#125;; int robotSim(vector&lt;int&gt;&amp; commands, vector&lt;vector&lt;int&gt;&gt;&amp; obstacles) &#123; vector&lt;Point&gt; dirs &#x3D; &#123;Point(0,1), Point(1,0), Point(0,-1), Point(-1,0)&#125;; unordered_set&lt;Point, myhash&gt; barrier; for(auto&amp; vec : obstacles) barrier.emplace(Point(vec[0], vec[1])); Point p(0, 0); int dir &#x3D; 0; int res &#x3D; 0; for(int c : commands) &#123; if(c &lt; 0) dir &#x3D; (dir + (c &#x3D;&#x3D; -2 ? 3 : 1)) % 4; else &#123; while(c--) &#123; p &#x3D; p + dirs[dir]; if(barrier.count(p)) &#123; p &#x3D; p - dirs[dir]; break; &#125; &#125; res &#x3D; max(res, p.empow()); &#125; &#125; return res; &#125; &#125;; 52.N皇后 Ⅱ解法 基本思路：贪心 和51.N皇后思路一样，只是保存方案改为了计数。本质依旧是，外层遍历行，内层遍历列，依次尝试一行中的每一列放置皇后的效果，迭代出所有结果。 Code class Solution &#123; public: int totalNQueens(int n) &#123; int res &#x3D; 0; vector&lt;string&gt; path(n, string(n, &#39;.&#39;)); auto isValid &#x3D; [&amp;path, n](int row, int col) -&gt; bool &#123; for(int i &#x3D; 0; i &lt; row; ++i) if(path[i][col] &#x3D;&#x3D; &#39;Q&#39;) return false; for(int i &#x3D; row-1, j &#x3D; col-1; i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0; --i, --j) if(path[i][j] &#x3D;&#x3D; &#39;Q&#39;) return false; for(int i &#x3D; row-1, j &#x3D; col+1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; --i, ++j) if(path[i][j] &#x3D;&#x3D; &#39;Q&#39;) return false; return true; &#125;; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int row) -&gt; void &#123; if(row &#x3D;&#x3D; n) &#123; ++res; return; &#125; for(int i &#x3D; 0; i &lt; n; ++i) &#123; if(isValid(row, i)) &#123; path[row][i] &#x3D; &#39;Q&#39;; self(self, row + 1); path[row][i] &#x3D; &#39;.&#39;; &#125; &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTrack(); return res; &#125; &#125;; 2023.7.20918.环形子数组的最大和解法 基本思路：前缀和、动态规划 本题是在53.最大子数组和的基础上增加了一种情况，因为存在环形数组，子数组可能是两端各一部分中间断开的情况，这种情况是不易计算的，可以进行转化：求这种子数组的最大和，相当于求其余部分数组的最小和。 这种方法需要处理一种特殊情况：例如{-3，-2，-3}，其余部分的最小和即为整个数组，那么子数组变为了长度为0和为0，而第一种情况下的最大和为-2，应该输出的正确值是第一种情况的-2。 Code class Solution &#123; public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123; int pre &#x3D; 0, res &#x3D; INT_MIN; int pre2 &#x3D; 0, res2 &#x3D; INT_MAX; int sum &#x3D; accumulate(nums.begin(), nums.end(), 0); for(int&amp; n : nums) &#123; pre &#x3D; max(n, pre + n); res &#x3D; max(res, pre); pre2 &#x3D; min(n, pre2 + n); res2 &#x3D; min(res2, pre2); &#125; return sum &#x3D;&#x3D; res2 ? res : max(res, sum - res2); &#125; &#125;; 649.Dota2 参议院解法 基本思路：队列 简单粗暴的出队和重新排队，直到一个队列为空。 Code class Solution &#123; public: string predictPartyVictory(string senate) &#123; int n &#x3D; senate.size(); queue&lt;int&gt; qd, qr; for(int i &#x3D; 0; i &lt; n; ++i) &#123; if(senate[i] &#x3D;&#x3D; &#39;R&#39;) qr.push(i); else qd.push(i); &#125; while(!qd.empty() &amp;&amp; !qr.empty()) &#123; if(qd.front() &gt; qr.front()) &#123; qd.pop(); int idx &#x3D; qr.front() + n; qr.pop(); qr.push(idx); &#125; else &#123; qr.pop(); int idx &#x3D; qd.front() + n; qd.pop(); qd.push(idx); &#125; &#125; return qd.empty() ? &quot;Radiant&quot; : &quot;Dire&quot;; &#125; &#125;; 1221.分割平衡字符串解法 基本思路：贪心 分割的尽可能多，也就是子串都尽可能小，那么只要在遍历过程中，遇到一个平衡字串就计数+1即可。 Code class Solution &#123; public: int balancedStringSplit(string s) &#123; int l &#x3D; 0, r &#x3D; 0; int res &#x3D; 0; for(char&amp; c : s) &#123; if(c &#x3D;&#x3D; &#39;R&#39;) ++r; else ++l; if(l &#x3D;&#x3D; r) ++res; &#125; return res; &#125; &#125;; 2023.7.211499.满足不等式的最大值解法 基本思路：优先队列、单调队列 显然暴力双循环是会超时的，似乎又没看到可以剪枝的地方，那么就需要用空间换时间。 绝对值的计算是相对麻烦的，最好去掉：变为求 yj + xj + (yi - xi) 的最大值。由于 i &lt; j，那么就需要先在数组的前半段找到 （yi - xi）的最大值，然后在后半段中取（xj，yj），计算总的最大值。 涉及最大值，那么很显然可以用单调队列或大根堆存储 （yi - xi），将其最大值始终保持在队首，便于计算。 Code class Solution &#123; public: int findMaxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; int res &#x3D; INT_MIN; deque&lt;pair&lt;int, int&gt;&gt; q; for(auto&amp; vec : points) &#123; while(!q.empty() &amp;&amp; q.front().second &lt; vec[0] - k) q.pop_front(); if(!q.empty()) res &#x3D; max(res, q.front().first + vec[0] + vec[1]); while(!q.empty() &amp;&amp; q.back().first &lt; vec[1] - vec[0]) q.pop_back(); q.push_back(&#123;vec[1] - vec[0], vec[0]&#125;); &#125; return res; &#125; &#125;; 2023.7.235.最大回文子串解法 基本思路：动态规划、中心扩散 看到回文子串，就要想到中心扩散，回文串最中心的一个或两个字符一定也是回文串，在此基础上，每次向两边添加一个相同字符，即为回文串的中心扩散。 动态规划，首先定义dp[i] [j]：（i，j）区间的子串是否为回文串。其次思考递推：上述中心扩散说明中可以发现，当i、j下标的两个字符相等时，回文子串是分为两种情况的——1.只有1或2个字符，则直接置为true；2.超过两个字符时，都是由更基础的一层决定，也就是去掉边缘的两个字符后的子串是否为回文串，即 dp[i+1] [j-1] 。因此递推需要考虑以上两个条件（或）。最后思考初始化和循环方向：显然初始化为false，循环方向根据（i+1，j-1）可知，需要由下而上，从左往右。 由于循环只记录每个子串是否为回文串，而不统计最大长度，因此在循环中需要维护最大长度的子串长度和下标位置，用于获取最终结果。 空间优化：根据递推公式可知二维数组可以优化为一维，只需要记录前一格dp修改前的状态即可。需要注意的是，dp当前值若不符合条件时，记录的仍是上一轮的状态，因此需要手动置为false。 Code class Solution &#123; public: string longestPalindrome(string s) &#123; vector&lt;bool&gt; dp(s.size(), false); int maxLen &#x3D; 0, start; for(int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; --i) &#123; bool pre; for(int j &#x3D; i; j &lt; s.size(); ++j) &#123; bool tmp &#x3D; dp[j]; if(s[i] &#x3D;&#x3D; s[j] &amp;&amp; (j - i &lt; 2 || pre)) dp[j] &#x3D; true; else dp[j] &#x3D; false; if(dp[j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen &#x3D; j - i + 1; start &#x3D; i; &#125; pre &#x3D; tmp; &#125; &#125; return s.substr(start, maxLen); &#125; &#125;; 2023.7.24771.宝石与石头解法 基本思路：哈希表 Code class Solution &#123; public: int numJewelsInStones(string jewels, string stones) &#123; unordered_set&lt;char&gt; hash; for(char&amp; c : jewels) if(hash.count(c) &#x3D;&#x3D; 0) hash.emplace(c); int res &#x3D; 0; for(char&amp; c : stones) if(hash.count(c)) ++res; return res; &#125; &#125;; 2023.7.25132.分割回文串 Ⅱ解法 基本思路：动态规划 dp[i] 定义为 （0，i）的子串的最少分割次数。分析递推公式：一遍for循环肯定是不够的（例abab，再加个a，结果就从1变为了0，即存在加或减的情况），求的又是最少，那么很明显需要二层循环取最小值。 因此在（0，i）间遍历取 j ，来得到 dp[i] 的最小值。那么 dp[i] 和 dp[j] 的关系：如果（j+1，i）是回文串，那么dp[i] = min( dp[j] + 1，dp[i] ) 。注意剪枝：在遍历前可以先判断子串本身是否为回文串，若是则记为0，直接跳过当前层循环。 在上述过程中，还需要得到每个子串是否为回文串的信息，若是简单写个判断函数，对于长字符串存在超时情况，因此需要再用一个dp[i] [j]存储每个子串的情况。方法即为 5.最大回文子串 的方法。 Code class Solution &#123; public: int minCut(string s) &#123; vector&lt;vector&lt;bool&gt; &gt; isTrue(s.size(), vector&lt;bool&gt;(s.size(), false)); for(int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; --i) for(int j &#x3D; i; j &lt; s.size(); ++j) if(s[i] &#x3D;&#x3D; s[j] &amp;&amp; (j-i &lt; 2 || isTrue[i+1][j-1])) isTrue[i][j] &#x3D; true; vector&lt;int&gt; dp(s.size(), INT_MAX); dp[0] &#x3D; 0; for(int i &#x3D; 1; i &lt; s.size(); ++i) &#123; if(isTrue[0][i]) &#123; dp[i] &#x3D; 0; continue; &#125; for(int j &#x3D; 0; j &lt; i; ++j) if(isTrue[j+1][i]) dp[i] &#x3D; min(dp[i], dp[j] + 1); &#125; return dp[s.size() - 1]; &#125; &#125;; 2208.将数组和减半的最少操作次数解法 基本思路：贪心、优先队列（大根堆） 求和减半的最少次数，那么就需要每次减半的值尽可能大，所以贪心：每次取数组中最大的值减半直至符合要求。用大根堆作为容器，每次只需将堆顶元素减半后重新加入堆即可。 Code class Solution &#123; public: int halveArray(vector&lt;int&gt;&amp; nums) &#123; priority_queue&lt;double&gt; q; double sum &#x3D; 0; for(int&amp; n : nums) &#123; q.push(n); sum +&#x3D; n; &#125; double target &#x3D; sum &#x2F; 2.0; int res &#x3D; 0; while(sum &gt; target) &#123; double n &#x3D; q.top() &#x2F; 2; q.pop(); q.push(n); sum -&#x3D; n; res++; &#125; return res; &#125; &#125;; 2023.7.26673.最长递增子序列的个数解法 基本思路：动态规划 本题是 300.最长递增子序列 的进阶。光凭一个dp很难直接推出答案，因此需要在计算最长长度Len的基础上，再设置一个记录个数的数组dp。考虑如何计算 dp : 在用 j 遍历（0，i）子序列时，当满足 nums[j] &lt; nums[i]时，考虑 len[i]和 len[j] + 1的关系，如果前者更大，那么显然此时 j 还没能达到最长的位置，不用处理；当两者相等，说明该处是该子序列的其中一个最长子序列的倒数第二个元素，那么 dp[i] 就需要加上 dp[j] （如果有多个最长子序列，一定是在这种情况下计算的）；当后者更大时，则直接更新 dp[i] 为 dp[j] 。 Code class Solution &#123; public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; len(nums.size(), 1); vector&lt;int&gt; dp(nums.size(), 1); int maxLen &#x3D; 1; for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; for(int j &#x3D; 0; j &lt; i; ++j) &#123; if(nums[j] &lt; nums[i]) &#123; if(len[i] &lt; len[j] + 1) dp[i] &#x3D; dp[j]; else if(len[i] &#x3D;&#x3D; len[j] + 1) dp[i] +&#x3D; dp[j]; len[i] &#x3D; max(len[i], len[j] + 1); &#125; &#125; maxLen &#x3D; max(maxLen, len[i]); &#125; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i) if(len[i] &#x3D;&#x3D; maxLen) res +&#x3D; dp[i]; return res; &#125; &#125;; 2023.7.272500.删除每行中的最大值解法 基本思路：排序 Code class Solution &#123; public: int deleteGreatestValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; for(auto&amp; vec : grid) sort(vec.begin(), vec.end()); int res &#x3D; 0; for(int i &#x3D; 0; i &lt; grid[0].size(); ++i) &#123; int tmp &#x3D; 0; for(int j &#x3D; 0; j &lt; grid.size(); ++j) tmp &#x3D; max(tmp, grid[j][i]); res +&#x3D; tmp; &#125; return res; &#125; &#125;; 841.钥匙和房间解法 基本思路：DFS、有向图 有向图只能通过dfs或bfs来搜索全路径。DFS想明白递归三部曲：递归参数、终止条件、单层逻辑分别是什么。 Code class Solution &#123; public: bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123; vector&lt;bool&gt; visited(rooms.size(), false); int res &#x3D; 0; auto dfs &#x3D; [&amp;, circle &#x3D; [&amp;](auto&amp;&amp; self, int key) -&gt; void &#123; if(visited[key]) return; visited[key] &#x3D; true; ++res; for(int&amp; n : rooms[key]) self(self, n); &#125; ]() &#123; circle(circle, 0); &#125;; dfs(); return res &#x3D;&#x3D; rooms.size(); &#125; &#125;; 127.单词接龙题干 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk： 每一对相邻的单词只差一个字母。 对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。 sk == endWord 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。 示例1： 输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] 输出：5 示例2： 输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] 输出：0 解法 基本思路：BFS、无向图 首先要有无向图的概念，这里list中的字符串能推到差一个字符的另一个字符串，另一个自然也能推回来，因此图是无向的。无向图求最短路径，广搜最为合适。BFS只要搜到了终点，那么一定是最短的路径。 确定了算法主体，那么接下来我们需要一个队列存储每一层要搜索的单词和一个标记集合存储已搜索过的单词避免重复搜索出现闭环现象。之后便是循环出队、入队流程了。在代码随想录中，采用的是遍历字符 a - z；相比于遍历列表降低了时间复杂度（从O(单词长度 X 数量（上限5000）) 减少为O(单词长度 X 26) ）。 优化： 1.查找速度：用哈希表存储单词，查找只需要O（1）复杂度。因此用 unordered_set 替换 vector 和 queue。 2.剪枝：采用双向BFS，即设立头尾两个哈希表，从两端进行BFS遍历，每次取数量更少的那个表进行一层遍历。 Code class Solution &#123; public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; unordered_set&lt;string&gt; dict(wordList.begin(), wordList.end()); if(dict.count(endWord) &#x3D;&#x3D; 0) return 0; unordered_set&lt;string&gt; s, e, visited; s.emplace(beginWord); e.emplace(endWord); int res &#x3D; 2; while(!s.empty()) &#123; unordered_set&lt;string&gt; next; for(auto&amp; str : s) &#123; for(string&amp; word : wordList) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; beginWord.size(); ++i) &#123; if(str[i] !&#x3D; word[i]) ++cnt; if(cnt &gt; 1) break; &#125; if(cnt &#x3D;&#x3D; 1) &#123; if(e.count(word)) return res; if(visited.count(word) &#x3D;&#x3D; 0) &#123; next.emplace(word); visited.emplace(word); &#125; &#125; &#125; &#125; ++res; s &#x3D; next; if(s.size() &gt; e.size()) swap(s, e); &#125; return 0; &#125; &#125;; 相关题目433.最小基因变化解法 基本思路：BFS、无向图 和上题相同的思路，这里尝试了Carl哥的固定字符遍历而不是遍历列表，节约时间成本。 注意：本题求的是最短转换次数，上题求的是最短转换序列的单词数（是包含begin的），因此res的初始化为1。 注意2：set和unordered_set都有只读键。如果键值发生变化，数据结构会将其归档到错误的位置，您将无法再找到它。因此无论是for循环或迭代器遍历，返回的都是常量值，无法修改。 Code class Solution &#123; public: int minMutation(string startGene, string endGene, vector&lt;string&gt;&amp; bank) &#123; unordered_set&lt;string&gt; dict(bank.begin(), bank.end()); if(dict.count(endGene) &#x3D;&#x3D; 0) return -1; unordered_set&lt;string&gt; s, e, visited; const char gene[4] &#x3D; &#123;&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;&#125;; s.emplace(startGene); e.emplace(endGene); int res &#x3D; 1; while(!s.empty()) &#123; unordered_set&lt;string&gt; next; for(auto&amp; str : s) &#123; string newwd &#x3D; str; for(char&amp; c : newwd) &#123; char old &#x3D; c; for(const char&amp; g : gene) &#123; if(c &#x3D;&#x3D; g) continue; c &#x3D; g; if(e.count(newwd)) return res; if(visited.count(newwd) &#x3D;&#x3D; 0 &amp;&amp; dict.count(newwd)) &#123; visited.emplace(newwd); next.emplace(newwd); &#125; &#125; c &#x3D; old; &#125; &#125; ++res; s &#x3D; next; if(s.size() &gt; e.size()) swap(s, e); &#125; return -1; &#125; &#125;; 126.单词接龙 Ⅱ解法 基本思路：BFS、无向图 太复杂了，逻辑对了但是超时。TODO 2023.7.30684.冗余连接解法 基本思路：并查集 题意中，若有多个答案，返回数组中最后出现的那个。那么遍历顺序就为从前往后，优先将数组前面的一对节点都连接在同一个集合中。 直到碰到某条边，两个元素已经在同一集合中了，那么加上这条边就一定会出现环，因此直接返回即可。 Code class Solution &#123; public: class DisjointSet &#123; private: vector&lt;int&gt; father; public: DisjointSet(int size) : father(vector&lt;int&gt;(size)) &#123; for(int i &#x3D; 0; i &lt; size; ++i) father[i] &#x3D; i; &#125; int find(int u) &#123; return u &#x3D;&#x3D; father[u] ? u : father[u] &#x3D; find(father[u]); &#125; bool isSame(int u, int v) &#123; u &#x3D; find(u); v &#x3D; find(v); return u &#x3D;&#x3D; v; &#125; void join(int u, int v) &#123; u &#x3D; find(u); v &#x3D; find(v); if (u &#x3D;&#x3D; v) return ; father[v] &#x3D; u; &#125; &#125;; vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; DisjointSet ds(1002); for(auto&amp; vec : edges) &#123; if(ds.isSame(vec[0], vec[1])) return vec; else ds.join(vec[0], vec[1]); &#125; return &#123;&#125;; &#125; &#125;; 2023.7.31685.冗余连接 Ⅱ解法 基本思路：并查集、有向图 根据题意，每一个节点都有且只有一个父节点，而根节点没有父节点。而在此基础上多添加一条有向边，可能导致两种情况： 有向边指向非根节点，此时指向的节点入度为2（唯一） 有向边指向根节点，此时节点入度均为1但存在环。 首先统计所有节点的入度，之后记录入度为2的节点（如果有）相关联的两条有向边。再根据以上情况分别处理： 对于1，模拟从两条边中删除一条，那么将剩下的边都加入并查集，如果出现环了，说明删错了，返回另一条边。 对于2，将所有边都加入并查集，如果出现环，那么那条边就是指向根节点的有向边，除去。 Code class Solution &#123; public: vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; int n &#x3D; edges.size(); vector&lt;int&gt; indeg(n + 1, 0); vector&lt;int&gt; candi; for(auto&amp; vec : edges) indeg[vec[1]]++; for(int i &#x3D; n-1; i &gt;&#x3D; 0; --i) &#x2F;&#x2F; 这里注意返回最后的值，因此倒序遍历，这样可以先处理 if(indeg[edges[i][1]] &#x3D;&#x3D; 2) candi.emplace_back(i); auto isTree &#x3D; [&amp;edges, n](int delEdge) -&gt; bool &#123; DisjointSet ds(n + 1); for(int i &#x3D; 0; i &lt; n; ++i) &#123; if(i &#x3D;&#x3D; delEdge) continue; if(ds.isSame(edges[i][0], edges[i][1])) return false; ds.join(edges[i][0], edges[i][1]); &#125; return true; &#125;; auto removeLoop &#x3D; [&amp;edges, n]() -&gt; vector&lt;int&gt; &#123; DisjointSet ds(n + 1); for(auto&amp; vec : edges) &#123; if(ds.isSame(vec[0], vec[1])) return vec; ds.join(vec[0], vec[1]); &#125; return &#123;&#125;; &#125;; if(!candi.empty()) return isTree(candi[0]) ? edges[candi[0]] : edges[candi[1]]; return removeLoop(); &#125; &#125;; 721.账户合并解法 基本思路：并查集、哈希表 题意实际就是**根据邮箱判断是否属于同一个账户 **——&gt; 判断两个账户是否在同一集合：并查集。 字符串很多，但统计可以简化：并查集记录每个账户的下标即可。 因为是根据邮箱判断，所以建立邮箱到账户下标的映射，之后遍历所有邮箱，将重复出现的邮箱所在账户下标加入并查集。这样就建立起了相同账户之间的连通性。 根据并查集和哈希表，再次建立一个账户下标到邮箱列表的映射（便于给邮箱列表排序），将格式整理为合并后的账户下标对应的邮箱列表。最后将每个账户的邮箱排序后加入结果集。 Code class Solution &#123; public: vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123; int n &#x3D; accounts.size(); unordered_map&lt;string, int&gt; hash; DisjointSet ds(n); for(int i &#x3D; 0; i &lt; n; ++i) &#123; for(int j &#x3D; 1; j &lt; accounts[i].size(); ++j) &#123; if(hash.count(accounts[i][j])) ds.join(i, hash[accounts[i][j]]); else hash[accounts[i][j]] &#x3D; i; &#125; &#125; vector&lt;vector&lt;string&gt; &gt; res; unordered_map&lt;int, vector&lt;string&gt; &gt; accs; for(auto&amp; [str, n] : hash) accs[ds.find(n)].emplace_back(str); for(auto&amp; [n, vec] : accs) &#123; sort(vec.begin(), vec.end()); vector&lt;string&gt; tmp &#x3D; &#123;accounts[n][0]&#125;; tmp.insert(tmp.end(), vec.begin(), vec.end()); res.emplace_back(tmp); &#125; return res; &#125; &#125;; 657.机器人能否回到原点解法 基本思路：模拟、哈希 判断能否回到原点，第一反应就是记录四个方向移动的次数，最后判断左右、上下是否相等。再简化一下，只需维护两个变量，用加减来记录，判断最后是否为0即可。 剪枝：如果字符串长度为奇数，必然是false。 Code class Solution &#123; public: bool judgeCircle(string moves) &#123; if(moves.size() % 2) return false; int hash[2] &#x3D; &#123;0&#125;; for(char&amp; c : moves) &#123; if(c &#x3D;&#x3D; &#39;U&#39;) hash[0]++; else if(c &#x3D;&#x3D; &#39;D&#39;) hash[0]--; else if(c &#x3D;&#x3D; &#39;L&#39;) hash[1]++; else hash[1]--; &#125; return hash[0] &#x3D;&#x3D; 0 &amp;&amp; hash[1] &#x3D;&#x3D; 0; &#125; &#125;; 463.岛屿的周长解法 基本思路：模拟 一块土地可以带来4个单位的周长，但是每当土地周围存在一个接壤，周长就会少1。 因此答案为：土地数 X 4 - 接壤数 X 2。统计这两个值即可。 Code class Solution &#123; public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int land &#x3D; 0, border &#x3D; 0; for(int i &#x3D; 0; i &lt; grid.size(); ++i) &#123; for(int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123; if(grid[i][j]) &#123; ++land; if(i &gt; 0 &amp;&amp; grid[i-1][j]) ++border; if(j &gt; 0 &amp;&amp; grid[i][j-1]) ++border; &#125; &#125; &#125; return 4 * land - 2 * border; &#125; &#125;; 1356.根据数字二进制下1的数目排序解法 基本思路：二进制 本题的重点在于如何统计二进制数中1的数目。暴力解法就是遍历每一位是否为1。 n &amp;= (n - 1) 可以去除 n 最低位的1。 Code class Solution &#123; public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; auto clearBack &#x3D; [](int n) -&gt; int &#123; int cnt &#x3D; 0; while(n) &#123; n &amp;&#x3D; (n - 1); ++cnt; &#125; return cnt; &#125;; sort(arr.begin(), arr.end(), [&amp;](const int&amp; a, const int&amp; b)&#123; int ba &#x3D; clearBack(a); int bb &#x3D; clearBack(b); return ba &#x3D;&#x3D; bb ? a &lt; b : ba &lt; bb; &#125;); return arr; &#125; &#125;; 打卡8月LeetCode2023.8.183.删除排序链表中的重复元素解法 基本思路：删除链表 Code class Solution &#123; public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head &#x3D;&#x3D; nullptr) return head; ListNode* dummy &#x3D; head; while(dummy-&gt;next) &#123; if(dummy-&gt;val &#x3D;&#x3D; dummy-&gt;next-&gt;val) dummy-&gt;next &#x3D; dummy-&gt;next-&gt;next; else dummy &#x3D; dummy-&gt;next; &#125; return head; &#125; &#125;; 25.K个一组翻转链表题干 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，最后剩余的节点保持原有顺序。 解法 基本思路：翻转链表 不能死套模板方法，写一个翻转函数然后再每一段调用，会发现首尾节点的链接变得很复杂不好处理。 要理解翻转的本质：在首节点后的遍历过程中，1.将节点删除，2.插入到头节点后。（例：dummy –&gt; 1 –&gt; 2 –&gt; 3，先把2从链表中摘出来，然后插入到dummy后，3同理，就这么两步走就行）。 而要翻转的起始位置取决于头节点的位置，要翻转的长度取决于循环的次数+1。 Code class Solution &#123; public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(head &#x3D;&#x3D; nullptr || k &#x3D;&#x3D; 1) return head; ListNode* dummy &#x3D; new ListNode(0, head); int cnt &#x3D; 0; while(head) &#123; head &#x3D; head-&gt;next; ++cnt; &#125; ListNode* pre &#x3D; dummy, *cur &#x3D; dummy-&gt;next; while(cnt &gt;&#x3D; k) &#123; for(int i &#x3D; 1; i &lt; k; ++i) &#123; ListNode* tmp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; tmp-&gt;next; tmp-&gt;next &#x3D; pre-&gt;next; pre-&gt;next &#x3D; tmp; &#125; pre &#x3D; cur; cur &#x3D; cur-&gt;next; cnt -&#x3D; k; &#125; return dummy-&gt;next; &#125; &#125;; 160.相交链表解法 基本思路：双指针 本质就是统计两个链表的长度后计算差值sub，让长的链表先走sub步，之后一起移动，判断有无相同节点。 写法上可以更简洁：短的先走完后，重新指向长的首节点，等长的走完指向短的首节点时，快慢指针就形成了。 Code class Solution &#123; public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* a &#x3D; headA, *b &#x3D; headB; while(a || b) &#123; if(a &#x3D;&#x3D; NULL) a &#x3D; headB; if(b &#x3D;&#x3D; NULL) b &#x3D; headA; if(a &#x3D;&#x3D; b) return a; a &#x3D; a-&gt;next; b &#x3D; b-&gt;next; &#125; return NULL; &#125; &#125;; 21.合并两个有序链表解法 基本思路：双指针 注意循环结束后的接上。 Code class Solution &#123; public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123; ListNode* a &#x3D; list1, *b &#x3D; list2; ListNode* dummy &#x3D; new ListNode(); ListNode* cur &#x3D; dummy; while(a &amp;&amp; b) &#123; if(a-&gt;val &gt; b-&gt;val) &#123; cur-&gt;next &#x3D; b; b &#x3D; b-&gt;next; &#125; else &#123; cur-&gt;next &#x3D; a; a &#x3D; a-&gt;next; &#125; cur &#x3D; cur-&gt;next; &#125; cur-&gt;next &#x3D; a ? a : b; return dummy-&gt;next; &#125; &#125;; 148.排序链表题干 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 解法 基本思路：归并排序、切链、合并有序链表 常用的数组排序有快排，堆排，归并排序三种，其中前两种都需要通过数组下标访问元素，并不适合链表排序，因此归并是最好的选择，且符合 O(nlogn) 的时间复杂度要求。 归并分为两个步骤：分和治。 分就是不断将链表均分为两段，直至链表长度为1。注意 getMid() 中，while的判断条件，如果设为 fast &amp;&amp; fast-&gt;next，在切链时会复杂一些，需要维护一个pre指针指向slow前面一格才能切断。 治就是合并，将两段有序链表不断合并为一段有序链表，直至全部合并结束。下面代码中是一种简写的方式，逻辑更清晰的代码可见 21.合并两个有序链表 。 Code class Solution &#123; public: ListNode* getMid(ListNode* cur) &#123; ListNode* slow &#x3D; cur; ListNode* fast &#x3D; cur; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; &#125; fast &#x3D; slow-&gt;next; slow-&gt;next &#x3D; nullptr; return fast; &#125; ListNode* mergeList(ListNode* a, ListNode* b) &#123; ListNode* dummy &#x3D; new ListNode(); ListNode* cur &#x3D; dummy; while(a &amp;&amp; b) &#123; ListNode* &amp;tmp &#x3D; a-&gt;val &gt; b-&gt;val ? b : a; cur &#x3D; cur-&gt;next &#x3D; tmp; tmp &#x3D; tmp-&gt;next; &#125; cur-&gt;next &#x3D; a ? a : b; return dummy-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if(head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head; ListNode* mid &#x3D; getMid(head); return mergeList(sortList(head), sortList(mid)); &#125; &#125;; 2023.8.2822.翻转卡片游戏解法 基本思路：哈希表 阅读理解题。。首先正反相同的数字必不可能是答案，加入哈希表。之后在两个数组中找到不在哈希表中的最小数字即可。 Code class Solution &#123; public: int flipgame(vector&lt;int&gt;&amp; fronts, vector&lt;int&gt;&amp; backs) &#123; unordered_set&lt;int&gt; hash; for(int i &#x3D; 0; i &lt; fronts.size(); ++i) if(fronts[i] &#x3D;&#x3D; backs[i]) hash.emplace(fronts[i]); int res &#x3D; INT_MAX; for(int&amp; n : fronts) if(hash.count(n) &#x3D;&#x3D; 0) res &#x3D; min(res, n); for(int&amp; n : backs) if(hash.count(n) &#x3D;&#x3D; 0) res &#x3D; min(res, n); return res &#x3D;&#x3D; INT_MAX ? 0 : res; &#125; &#125;; 23.合并K个升序链表解法 基本思路：合并有序链表 合并方法见 148.排序链表，这里注意合并方式：for循环一个个合并过去时间复杂度为 O(K)，而两两合并可以降低到 O(logK) 。 Code class Solution &#123; public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if(lists.size() &#x3D;&#x3D; 0) return nullptr; auto merge &#x3D; [](ListNode* a, ListNode* b) -&gt; ListNode* &#123; ListNode* dummy &#x3D; new ListNode(); ListNode* cur &#x3D; dummy; while(a &amp;&amp; b) &#123; ListNode* &amp;tmp &#x3D; a-&gt;val &gt; b-&gt;val ? b : a; cur &#x3D; cur-&gt;next &#x3D; tmp; tmp &#x3D; tmp-&gt;next; &#125; cur-&gt;next &#x3D; a ? a : b; return dummy-&gt;next; &#125;; int num &#x3D; lists.size(); while(num &gt; 1) &#123; int idx &#x3D; 0; for(int i &#x3D; 0; i &lt; num; i +&#x3D; 2) &#123; if(i &#x3D;&#x3D; num - 1) lists[idx++] &#x3D; lists[i]; else lists[idx++] &#x3D; merge(lists[i], lists[i+1]); &#125; num &#x3D; idx; &#125; return lists[0]; &#125; &#125;; 2.两数相加Code class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummy &#x3D; new ListNode(); ListNode* res &#x3D; dummy; int carry &#x3D; 0; while(l1 || l2 || carry) &#123; if(l1) &#123; carry +&#x3D; l1-&gt;val; l1 &#x3D; l1-&gt;next; &#125; if(l2) &#123; carry +&#x3D; l2-&gt;val; l2 &#x3D; l2-&gt;next; &#125; dummy &#x3D; dummy-&gt;next &#x3D; new ListNode(carry % 10); carry &#x2F;&#x3D; 10; &#125; return res-&gt;next; &#125; &#125;; 92.反转链表 Ⅱ解法 基本思路：翻转链表 思路同 25.K个一组翻转链表 Code class Solution &#123; public: ListNode* reverseBetween(ListNode* head, int left, int right) &#123; ListNode* dummy &#x3D; new ListNode(-1, head); ListNode* pre &#x3D; dummy, *cur &#x3D; dummy; while(left-- &amp;&amp; right--) &#123; pre &#x3D; cur; cur &#x3D; cur-&gt;next; &#125; while(right--) &#123; ListNode* tmp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; tmp-&gt;next; tmp-&gt;next &#x3D; pre-&gt;next; pre-&gt;next &#x3D; tmp; &#125; return dummy-&gt;next; &#125; &#125;; 82.删除排序链表中的重复元素 II解法 基本思路：删除链表 如果存在多个相同值的节点，一个一个删并不好处理，因为删除次数 = 比较次数 + 1。换一种思路，维护一个pre指向虚拟头节点，cur指向head，当 cur-&gt;val == cur-&gt;next-&gt;val 时，就后移cur，直至遍历完相同节点。通过比较 pre的下一个节点和 cur是否相同来判断有无相同值，没有就正常双指针后移，若有则直接后移cur并将pre的下一个节点修改为cur（跳过所有相同值的节点）。 Code class Solution &#123; public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* dummy &#x3D; new ListNode(-1, head); ListNode* pre &#x3D; dummy, *cur &#x3D; head; while(cur) &#123; while(cur-&gt;next &amp;&amp; cur-&gt;val &#x3D;&#x3D; cur-&gt;next-&gt;val) cur &#x3D; cur-&gt;next; if(pre-&gt;next !&#x3D; cur) pre-&gt;next &#x3D; cur-&gt;next; else pre &#x3D; cur; cur &#x3D; cur-&gt;next; &#125; return dummy-&gt;next; &#125; &#125;; 445.两数相加 II解法 基本思路：栈 正常思路是翻转两个链表，使用 2.两数相加 的方法求和后再翻转结果链表。 若不允许翻转，可以用栈来模拟这一过程，在计算位数和创建节点时，采用头插法可以一步到位。 Code class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; stack&lt;int&gt; st1, st2; for (; l1; l1 &#x3D; l1-&gt;next) st1.push(l1-&gt;val); for (; l2; l2 &#x3D; l2-&gt;next) st2.push(l2-&gt;val); ListNode* dummy &#x3D; new ListNode(); int carry &#x3D; 0; while(!st1.empty() || !st2.empty() || carry) &#123; if(!st1.empty()) &#123; carry +&#x3D; st1.top(); st1.pop(); &#125; if(!st2.empty()) &#123; carry +&#x3D; st2.top(); st2.pop(); &#125; dummy-&gt;next &#x3D; new ListNode(carry % 10, dummy-&gt;next); carry &#x2F;&#x3D; 10; &#125; return dummy-&gt;next; &#125; &#125;; 61.旋转链表解法 基本思路：轮转链表 首先统计链表长（因为k可能大于链表长度，需要取余），并将链表结尾链接至head。 其次计算需要切链的位置，并将指针移动过去，完成切链，返回切链后的头节点。 Code class Solution &#123; public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head; ListNode* dummy &#x3D; new ListNode(-1, head); ListNode* cur &#x3D; dummy; int len &#x3D; 0; for(; cur-&gt;next; cur &#x3D; cur-&gt;next) ++len; cur-&gt;next &#x3D; head; len &#x3D; len - k % len; while(len--) dummy &#x3D; dummy-&gt;next; cur &#x3D; dummy-&gt;next; dummy-&gt;next &#x3D; nullptr; return cur; &#125; &#125;; 328.奇偶链表解法 基本思路：链表拼接 分别创建奇偶子链的指针，和一个指向偶链头节点的指针用于最后拼接。 因为 head-&gt;next 可能为空指针，因此while选择 even 和 even-&gt;next 作为判断条件，防止野指针。 遍历时每次移动两格拼接，注意顺序，先奇数，不然链表会断。 Code class Solution &#123; public: ListNode* oddEvenList(ListNode* head) &#123; if(head &#x3D;&#x3D; nullptr) return head; ListNode* odd &#x3D; head, *even &#x3D; head-&gt;next, *node &#x3D; head-&gt;next; while(even &amp;&amp; even-&gt;next) &#123; odd &#x3D; odd-&gt;next &#x3D; odd-&gt;next-&gt;next; even &#x3D; even-&gt;next &#x3D; even-&gt;next-&gt;next; &#125; odd-&gt;next &#x3D; node; return head; &#125; &#125;; 138.复制带随机指针的链表解法 基本思路：复制链表 因为随机指针的缘故，没有办法一边创建一边链接，因此需要保存原链的连接信息，用于复制。 第一遍遍历保存原链到新链相同位置节点的映射；第二遍时，将新节点的指针链接至正确位置。 Code class Solution &#123; public: Node* copyRandomList(Node* head) &#123; unordered_map&lt;Node*, Node*&gt; hash; Node* cur &#x3D; head; while(cur) &#123; hash[cur] &#x3D; new Node(cur-&gt;val); cur &#x3D; cur-&gt;next; &#125; cur &#x3D; head; while(cur) &#123; hash[cur]-&gt;next &#x3D; hash[cur-&gt;next]; hash[cur]-&gt;random &#x3D; hash[cur-&gt;random]; cur &#x3D; cur-&gt;next; &#125; return hash[head]; &#125; &#125;; 2023.8.3722.删除注释解法 基本思路：模拟 用一个string存储每行剩余内容，若字符串不为空且不处于块注释中，则加入结果集。 662.二叉树最大宽度解法 基本思路：层序、二叉树节点序号 求最大宽度，要找到每层的最左最右节点，很容易想到层序遍历。如何求宽度？可以给节点标序号，最后计算首尾节点序号的差值即可。 因此在队列存储时还要存储序号信息，注意序号越界问题（每个节点都只有右子树，3000层序号超过int了）。 初始序号为1，左子节点为 2 * 父节点序号；初始为0，左子节点为 2 * 父节点序号 + 1 。 Code class Solution &#123; public: int widthOfBinaryTree(TreeNode* root) &#123; using pti &#x3D; pair&lt;TreeNode*, unsigned long long&gt;; queue&lt;pti&gt; q; q.push(&#123;root, 1&#125;); int maxWid &#x3D; INT_MIN; while(!q.empty())&#123; int n &#x3D; q.size(); unsigned long long l &#x3D; q.front().second, r &#x3D; l; for(int i &#x3D; 0; i &lt; n; ++i)&#123; pti nd &#x3D; q.front(); q.pop(); r &#x3D; nd.second; if(nd.first-&gt;left) q.push(&#123;nd.first-&gt;left, 2 * r&#125;); if(nd.first-&gt;right) q.push(&#123;nd.first-&gt;right, 2 * r + 1&#125;); &#125; maxWid &#x3D; max(maxWid, (int)(r - l + 1)); &#125; return maxWid; &#125; &#125;; 剑指Offer 54.二叉搜索树的第k大节点解法 基本思路：中序、BST 利用好BST的特性，用中序遍历。求第k大，那么按照右中左的顺序，就是从大到小的顺序了。 递归时注意k要传引用进去，才能全局计数。终止条件可以对结果变量做一个判断，找到了直接结束，实现剪枝。 Code class Solution &#123; public: int res &#x3D; 0; void dfs(TreeNode* root, int&amp; k) &#123; if(!root || res) return; dfs(root-&gt;right, k); if(--k &#x3D;&#x3D; 0) res &#x3D; root-&gt;val; dfs(root-&gt;left, k); &#125; int kthLargest(TreeNode* root, int k) &#123; dfs(root, k); return res; &#125; &#125;; 相关题目230. 二叉搜索树中第K小的元素解法 同上，遍历顺序左右换一下即可。 958.二叉树的完全性检验解法 基本思路：层序 层序遍历，记录上一个节点的指针，若上个指针是null但当前不是，则不完全。遍历完成则是完全的。 巧妙的方法是层序将节点放入队列的同时判断出队的节点有无null，有则结束入队操作。遍历队列中剩余节点，若存在非空值，则返回false。实现剪枝。 Code class Solution &#123; public: bool isCompleteTree(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode* nd &#x3D; q.front(); q.pop(); if(!nd) break; q.push(nd-&gt;left); q.push(nd-&gt;right); &#125; while(!q.empty()) &#123; TreeNode* nd &#x3D; q.front(); q.pop(); if(nd) return false; &#125; return true; &#125; &#125;; 剑指Offer 26.树的子结构解法 基本思路：递归 相比于 572.另一个树的子树 ，本题是子结构，意味着子结构可能在树的中间，即树本身在子结构下还有节点。 因此 check() 函数中的判断条件需稍作修改。 Code class Solution &#123; public: bool check(TreeNode* root, TreeNode* sub) &#123; if(!sub) return true; if(!root || root-&gt;val !&#x3D; sub-&gt;val) return false; return check(root-&gt;left, sub-&gt;left) &amp;&amp; check(root-&gt;right, sub-&gt;right); &#125; bool isSubStructure(TreeNode* A, TreeNode* B) &#123; if(!A || !B) return false; return check(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B); &#125; &#125;; 103.二叉树的锯齿形层序遍历解法 基本思路：层序遍历 层序的基础上维护一个bool变量，每层取反，true时翻转单层数组即可。 2023.8.4980.不同路径 Ⅲ解法 基本思路：回溯、DFS 1.确定递归参数和返回值： 因为要求走过每个可通行格子，因此四个方向都需要走走看。那么递归的就是前往的格子坐标（x，y）。显然会有一种情况：递归走到了终点，但是没走完全部可通行格子，此时是不能算作路径的，因此还需维护一个cnt值记录剩余的步数。返回值就是0或1或累加和，即每次递归若不符合走的条件返回0，否则都会得到向四周走一格的结果，求和返回，顺利走到终点且步数走完了返回1。 2.确定终止条件： 终止条件显然就是1.终点 2.格子坐标不对。对于1，判断格子是否==2且步数cnt归0。对于2，由于向四周递归，需防止x、y越界；格子的值小于0：-1为不可通行，-2为已走过的格子不能再走。 3.单层逻辑 显然中间是累加四个dfs函数，分别输入坐标，并且令cnt-1。 那么回溯什么状态呢？路径。在本题中表示为本格是否被标记：先标记为-2，结束递归后恢复为0。 Code class Solution &#123; public: int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int cnt) &#123; if(x &lt; 0 || x &gt;&#x3D; grid.size() || y &lt; 0 || y &gt;&#x3D; grid[0].size() || grid[x][y] &lt; 0) return 0; if(grid[x][y] &#x3D;&#x3D; 2) return cnt &#x3D;&#x3D; 0 ? 1 : 0; grid[x][y] &#x3D; -2; int res &#x3D; dfs(grid, x-1, y, cnt-1) + dfs(grid, x+1, y, cnt-1) + \\ dfs(grid, x, y-1, cnt-1) + dfs(grid, x, y+1, cnt-1); grid[x][y] &#x3D; 0; return res; &#125; int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int cnt &#x3D; 0, sx, sy; for(int i &#x3D; 0; i &lt; grid.size(); ++i) &#123; for(int j &#x3D; 0; j &lt; grid[0].size(); ++j) &#123; if(grid[i][j] &#x3D;&#x3D; 0) ++cnt; else if(grid[i][j] &#x3D;&#x3D; 1) sx &#x3D; i, sy &#x3D; j; &#125; &#125; return dfs(grid, sx , sy, cnt+1); &#125; &#125;; 124.二叉树的最大路径和解法 基本思路：动态规划、DFS a &#x2F; \\ b c 上面是一个最基础的二叉树子结构。这个子结构可以得到两种情况： 若a为根节点或a不联络父节点，此时的最大路径和就是 a + b + c a联络父节点，此时只能在子节点中选一条路：a + b 或 a + c （取最大值） 但要注意求最大路径和，就需要避免负数的累加，因此对于所有的b、c，都要取和 0 之间的最大值。但 a 作为承上启下的联络节点，是不可能被舍弃的，因此不需要判断（实际是在返回到更上一层中被判断）。 最重要的： 全局最大路径和与节点返回的最大路径和是不一样的。因为dfs是需要将整个树递推一遍的，但全局的最大和可能只出现在某个子结构中。那么显然需要额外维护一个max值，记录递推过程中的最大值，而节点的最大路径和作为返回值，用于计算上一层的返回值和全局最大值。 全局最大值意味着所在的子结构的根节点一定是上述a的情况1，即根节点或不联络父节点，因此只有上述的情况1可能为全局最大值，而情况2是用于递推最大路径和的。 这一个子结构放在遍历的任意过程中都是成立的，这就是递推关系。 1.确定递归参数和返回值：一个节点指针、传入节点开始往下的最大路径和。 2.终止条件：节点为空。 3.单层逻辑：因为计算路径和需要从下往上递推，因此先左右递归，再处理计算。 记录左右子节点的最大路径和，根据情况1求取更新全局最大和，根据情况2返回节点的最大路径和。 Code class Solution &#123; public: int maxPathSum(TreeNode* root) &#123; int res &#x3D; INT_MIN; function&lt;int(TreeNode*)&gt; dfs &#x3D; [&amp;](TreeNode* nd) -&gt; int &#123; if(nd &#x3D;&#x3D; nullptr) return 0; int l &#x3D; dfs(nd-&gt;left); int r &#x3D; dfs(nd-&gt;right); int maxNum &#x3D; nd-&gt;val + max(l, 0) + max(r, 0); res &#x3D; max(res, maxNum); return nd-&gt;val + max(&#123;l, r, 0&#125;); &#125;; dfs(root); return res; &#125; &#125;; 543.二叉树的直径解法 基本思路：动态规划、DFS 本题的模式和上题是一样的，即：最终要求的结果可能出现在递归过程中，而非递归的最后返回值。 a / \\ b c 对于同样这么一个子结构，存在两种情况： 直径所在路径经过a，此时最大值为 b为根的子树高度 + c子树高度 。 不经过a，此时最大值为 所有子树中的最大直径长度。 那么递推返回的就是子树的高度，而在递推过程中统计全局的最大直径长度。 Code class Solution &#123; public: int diameterOfBinaryTree(TreeNode* root) &#123; int res &#x3D; INT_MIN; function&lt;int(TreeNode*)&gt; dfs &#x3D; [&amp;](TreeNode* nd) -&gt; int &#123; if(nd &#x3D;&#x3D; nullptr) return 0; int l &#x3D; dfs(nd-&gt;left), r &#x3D; dfs(nd-&gt;right); res &#x3D; max(l + r, res); &#x2F;&#x2F; 两种情况的选择 return max(l, r) + 1; &#125;; dfs(root); return res; &#125; &#125;; 297.二叉树的序列化与反序列化解法 基本思路：层序遍历、字符流 思路选择最简单的层序遍历。 序列化很简单，正常层序遍历即可。while中不用for循环，每次把左右节点都push进去即可：因为空节点也需要存进去（最后其实会将叶节点下面的一层空节点全存进去）。 反序列化用到了C++的istringstream类，将字符串转化为流输出时，每次遇到空格、制表、换行等字符即停止遍历并输出。因此可以很方便的获取每个节点值的字符串表示。之后也是利用队列不断添加子节点即可。 Code TreeNode* deserialize(string data) &#123; if(data.empty()) return NULL; istringstream iss(data); string str; iss &gt;&gt; str; TreeNode* root &#x3D; new TreeNode(stoi(str)); queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode* nd &#x3D; q.front(); q.pop(); iss &gt;&gt; str; if(str !&#x3D; &quot;-&quot;) &#123; nd-&gt;left &#x3D; new TreeNode(stoi(str)); q.push(nd-&gt;left); &#125; iss &gt;&gt; str; if(str !&#x3D; &quot;-&quot;) &#123; nd-&gt;right &#x3D; new TreeNode(stoi(str)); q.push(nd-&gt;right); &#125; &#125; return root; &#125; 114.二叉树展开为链表解法 基本思路：先序遍历、DFS 右子节点会被接到左子节点的最右侧节点下方，但是正常写太慢了，遍历太多，很容易考虑到递归。 要求与先序顺序相同 ，那就按照先序的方式递归（从上往下，当父节点及以上的位置关系被改变时，子节点及以下的位置仍是原来的）。因此每次先保存 root-&gt;left 和 root-&gt;right 。因为递归下去之后，这个子节点的指向是会变的。 需要维护一个全局的烧饼指针，指向上一个被移动过的节点。这样就方便将当前节点连接至其右节点处。 Code class Solution &#123; public: TreeNode* pre &#x3D; new TreeNode(-1); void flatten(TreeNode* root) &#123; if(!root) return; TreeNode* l &#x3D; root-&gt;left, *r &#x3D; root-&gt;right; pre-&gt;left &#x3D; nullptr; pre-&gt;right &#x3D; root; pre &#x3D; root; flatten(l); flatten(r); &#125; &#125;; 剑指Offer 36.二叉搜索树与双向链表解法 基本思路：BST、DFS、中序遍历 维护一个烧饼指针指向前一个结点，一个头指针指向链表最小的元素（也就是第一次处理单层逻辑时赋值）。中序遍历，每次链接：1.前一个节点的右指针——&gt;当前节点 2.当前节点的左指针——&gt;前个节点，这样最为高效。最后补充头尾之间的连接。 Code class Solution &#123; public: Node* pre &#x3D; NULL; Node* head &#x3D; pre; Node* treeToDoublyList(Node* root) &#123; if(!root) return NULL; function&lt;void(Node*)&gt; dfs &#x3D; [&amp;](Node* nd) -&gt; void &#123; if(!nd) return; dfs(nd-&gt;left); if(!pre) head &#x3D; nd; else &#123; pre-&gt;right &#x3D; nd; nd-&gt;left &#x3D; pre; &#125; pre &#x3D; nd; dfs(nd-&gt;right); &#125;; dfs(root); pre-&gt;right &#x3D; head; head-&gt;left &#x3D; pre; return head ; &#125; &#125;; 2023.8.5155.最小栈解法 基本思路：辅助栈 一个栈正常存值，一个栈每次保存栈中的最小值。为什么要每次保存？例如：1，3，3。每次栈顶元素出栈后，最小值都是1，相当于辅助栈要存储三个1，才能实现每次都能检索到最小值。因此入栈时将入栈值与辅助栈顶值中较小的加入辅助栈。 实现只定义了一个栈，不过存的是元组形式，本质依旧是辅助栈，可能节省点空间？ Code class MinStack &#123; public: MinStack() &#123;&#125; void push(int val) &#123; if(st.empty()) st.push(&#123;val, val&#125;); else st.push(&#123;val, min(val, getMin())&#125;); &#125; private: stack&lt;pair&lt;int, int&gt;&gt; st; &#125;; 224.基本计算器题干 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 s 由数字、&#39;+&#39;、&#39;-&#39;、&#39;(&#39;、&#39;)&#39;、和 &#39; &#39; 组成 s 表示一个有效的表达式 ‘+’ 不能用作一元运算(例如， “+1” 和 &quot;+(2 + 3)&quot; 无效) ‘-‘ 可以用作一元运算(即 “-1” 和 &quot;-(2 + 3)&quot; 是有效的) 输入中不存在两个连续的操作符 解法 基本思路：栈、模拟 策略是，把所有括号拆掉，所有减号转化为加负值。栈是针对括号需要的数据结构，表明当前层的基础符号。 维护一个符号变量 sign表示当前项的基础符号，一个全局数值 num 和一个结果数值 res。我们假定运算表达式的最外层有一层括号，且基础符号为 + ，初始化时将 sign = 1 入栈。括号内的所有数字的符号都要在本身的基础上针对括号前的符号再作一次变化。于是后续所有操作都符合如下逻辑： 如果是数字字符，累加至全局数值中，用于计算表达式的一个项。 如果非数字字符，说明一个项的值（num）已经拿到了，根据当前符号位情况累加至结果 res 中。并针对特殊符号作如下处理： 若是 + ，即保持当前层的基础符号不变，即 sign = st.top() 。 若是 - ，需要取反基础符号（正变负、负变正），即 sign = -st.top() 。 若是 ( ，则前一个必然是加减运算符，已经改变了当前项（整个括号的基础符号）的符号，此时将 sign 入栈，栈顶的符号就是拆掉全部括号后的该括号内的项的实际符号。 若是 ) ，则这一层内的计算结束，要恢复到上一层的基础符号，即将栈顶元素出栈即可。 注意的是，如下写法中，若表达式以数值结尾，循环结束时最后一项是没有累加至结果中的，需要额外处理。 Code class Solution &#123; public: int calculate(string s) &#123; stack&lt;char&gt; st; st.push(1); int sign &#x3D; 1, res &#x3D; 0; long num &#x3D; 0; for(char&amp; c : s) &#123; if(c &lt; &#39;0&#39;) &#123; res +&#x3D; sign * num; num &#x3D; 0; if(c &#x3D;&#x3D; &#39;(&#39;) st.push(sign); else if(c &#x3D;&#x3D; &#39;)&#39;) st.pop(); else if(c &#x3D;&#x3D; &#39;+&#39;) sign &#x3D; st.top(); else if(c &#x3D;&#x3D; &#39;-&#39;) sign &#x3D; -st.top(); &#125; else num &#x3D; num * 10 + c - &#39;0&#39;; &#125; res +&#x3D; sign * num; return res; &#125; &#125;; 227.基本计算器 Ⅱ解法 基本思路：栈、模拟 本题跟 224.基本计算器 类似，都是双层优先级（上题是括号内外，本题是加减和乘除）。 策略是，去掉所有的乘除减，将剩下的项都加入栈，最后计算结果。 维护运算符 sign，记录上一个从字符串中取出的项与栈顶元素的运算关系，且因为都是非负整数，因此直接初始化为 + ，这样第一项就可以直接入栈。维护全局数值 num 存储字符串中的每一项。维护结果数值 res。 由于对最后一项的处理原因（上题中的注意事项），代码写法稍作改变，先计算每一项的实际值，再处理符号，并且由于 sign 存储的是运算符而非正负，因此要滤除空格（不作任何处理）。通常逻辑是在遇到运算符时处理 num ，但最后一项没有符号了，得直接计算，因此加入判断条件。运算符处理如下： 若是 + ，符合要求直接num入栈。 若是 - ， 最重要累加，所以-num入栈。 若是 * 或 / ，取出栈顶值，与 num相乘 / 除后入栈。 并更新符号位。最后累加栈中所有值即可。 Code class Solution &#123; public: int calculate(string s) &#123; stack&lt;int&gt; st; long num &#x3D; 0; int res &#x3D; 0; char sign &#x3D; &#39;+&#39;; for(int i &#x3D; 0; i &lt; s.size(); ++i) &#123; if(s[i] &gt;&#x3D; &#39;0&#39;) num &#x3D; num * 10 + s[i] - &#39;0&#39;; if(s[i] &lt; &#39;0&#39; &amp;&amp; s[i] !&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.size() - 1)&#123; if(sign &#x3D;&#x3D; &#39;+&#39;) st.push(num); else if(sign &#x3D;&#x3D; &#39;-&#39;) st.push(-num); else if(sign &#x3D;&#x3D; &#39;*&#39;) &#123; int val &#x3D; st.top() * num; st.pop(); st.push(val); &#125; else if(sign &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123; int val &#x3D; st.top() &#x2F; num; st.pop(); st.push(val); &#125; sign &#x3D; s[i]; num &#x3D; 0; &#125; &#125; while(!st.empty()) &#123; res +&#x3D; st.top(); st.pop(); &#125; return res; &#125; &#125;; 402.移掉K位数字解法 基本思路：模拟单调栈 使得剩余数字最小，就意味着让高位的字符越小越好（优先删除前面的更大字符）。因此很容易想到维护一个局部递增栈，局部是因为只能在前K次移走时保持递增。确定可移除后的字符后，还需要1.遍历开头去除前导0。 2.需要考虑到一种情况，上述为可移除，意味着对于例如：1234567，k=3 这种情况，单调栈是不起任何作用的，单调栈只是让字符串组成的数字尽可能小，因此最终还是要在拼接回字符串时限定范围。 对于上述1、2这种对栈底部分数据进行操作的情况，用 stack 并不理想。用 vector 来模拟入栈出栈更好。 Code class Solution &#123; public: string removeKdigits(string num, int k) &#123; vector&lt;char&gt; st; for(char&amp; c : num) &#123; while(!st.empty() &amp;&amp; c &lt; st.back() &amp;&amp; k) &#123; st.pop_back(); --k; &#125; st.emplace_back(c); &#125; int cnt &#x3D; 0; for(char&amp; c : st) &#123; if(c !&#x3D; &#39;0&#39;) break; ++cnt; &#125; string res &#x3D; &quot;&quot;; for(int i &#x3D; cnt; i &lt; st.size() - k; ++i) res.push_back(st[i]); return res.empty() ? &quot;0&quot; : res; &#125; &#125;; 2023.8.63.无重复字符的最长字串解法 基本思路：哈希、滑动窗口双指针 设置双指针作为滑动窗口，内部维护的是不重复的子串。for循环遍历时右指针移动，每次将字符所在下标记录至哈希表中。若遇到重复字符，则需要将左指针移至重复字符所在下标的右侧，同时删除哈希表中这段移动范围内的所有字符的键值对（因为要维护滑动窗口内的唯一性）。在过程中记录最大值。 Code class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; int res &#x3D; 0; unordered_map&lt;char, int&gt; hash; int left &#x3D; 0; for(int i &#x3D; 0; i &lt; s.size(); ++i) &#123; if(hash.count(s[i])) &#123; int idx &#x3D; hash[s[i]]; for(int j &#x3D; left; j &lt;&#x3D; idx; ++j) hash.erase(s[j]); left &#x3D; idx + 1; &#125; hash[s[i]] &#x3D; i; res &#x3D; max(res, i - left + 1); &#125; return res; &#125; &#125;; 394.字符串解码解法 基本思路：栈 类似于 224.基本计算器 的思路，也是两层，要拆括号，不过操作更少一些。 拆括号从里往外拆，即先把里面的最小单元（括号内只有字符的）拆开，然后依次类推展开，最后拼接。 Code class Solution &#123; public: string decodeString(string s) &#123; string res &#x3D; &quot;&quot;; stack&lt;char&gt; st; for(char&amp; c : s) &#123; if(c &#x3D;&#x3D; &#39;]&#39;) &#123; string str &#x3D; &quot;&quot;; while(!st.empty() &amp;&amp; st.top() !&#x3D; &#39;[&#39;) &#123; str.insert(0, 1, st.top()); st.pop(); &#125; st.pop(); int num &#x3D; 0, ratio &#x3D; 1; while(!st.empty() &amp;&amp; st.top() &lt;&#x3D; &#39;9&#39; &amp;&amp; st.top() &gt;&#x3D; &#39;0&#39;) &#123; num +&#x3D; (st.top() - &#39;0&#39;) * ratio; st.pop(); ratio *&#x3D; 10; &#125; string tmp &#x3D; &quot;&quot;; while(num--) tmp.append(str); for(char t : tmp) st.push(t); &#125; else st.push(c); &#125; while(!st.empty()) &#123; res.insert(0, 1, st.top()); st.pop(); &#125; return res; &#125; &#125;; 14.最长公共前缀解法 基本思路：暴力、字典树（TODO） 暴力循环，每次取第一个字符串的一个字符，依次判断剩余字符串相同位置的字符是否相同，有不同或越界就直接终止返回。 Code class Solution &#123; public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res &#x3D; &quot;&quot;; for(int i &#x3D; 0; i &lt; strs[0].size(); ++i) &#123; for(int j &#x3D; 1; j &lt; strs.size(); ++j) if(i &gt;&#x3D; strs[j].size() || strs[0][i] !&#x3D; strs[j][i]) return res; res.push_back(strs[0][i]); &#125; return res; &#125; &#125;; 2023.8.78.字符串转换整数(atoi)解法 基本思路：字符串 去除先导0、正负判断和终止遍历没啥好说的，重点在于判断字符串数是否越界上。 因为会越界不能直接*10判断，而是要除法判断INT_MIN/10。而除法因为是取整，实际上还需要补判，即本次循环中累加的个位数的负值是否比取余的结果更小。 这里为什么用个位数的负值累加和，并且取INT_MIN而非INT_MAX，是因为 INT_MAX 的负值，是要比 INT_MIN 还要大1的，也就是没达到边界条件，这样处理会出现缺失。 Code class Solution &#123; public: int myAtoi(string s) &#123; int sign &#x3D; 1, idx &#x3D; 0; while(idx &lt; s.size() &amp;&amp; s[idx] &#x3D;&#x3D; &#39; &#39;) ++idx; if(s[idx] &#x3D;&#x3D; &#39;-&#39;) &#123; sign &#x3D; 0; ++idx; &#125; else if(s[idx] &#x3D;&#x3D; &#39;+&#39;) ++idx; int res &#x3D; 0; while(idx &lt; s.size() &amp;&amp; s[idx] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[idx] &lt;&#x3D; &#39;9&#39;) &#123; int digit &#x3D; &#39;0&#39; - s[idx]; if(res &lt; INT_MIN&#x2F;10 || (res &#x3D;&#x3D; INT_MIN&#x2F;10 &amp;&amp; digit &lt; INT_MIN%10)) &#123; res &#x3D; INT_MIN; break; &#125; res &#x3D; res * 10 + digit; ++idx; &#125; if(res &#x3D;&#x3D; INT_MIN &amp;&amp; sign) return INT_MAX; if(sign) res &#x3D; -res; return res; &#125; &#125;; 165.比较版本号解法1 基本思路：字符串、双指针 常规思路，双指针遍历两个串，累加得到一个数遇到 ‘.’ 停止，然后比较大小，直至都遍历完了返回0。 Code class Solution &#123; public: int compareVersion(string v1, string v2) &#123; int i &#x3D; 0, j &#x3D; 0; while(i &lt; v1.size() || j &lt; v2.size()) &#123; long long num1 &#x3D; 0, num2 &#x3D; 0; while(i &lt; v1.size() &amp;&amp; v1[i] !&#x3D; &#39;.&#39;) num1 &#x3D; num1 * 10 + v1[i++] - &#39;0&#39;; while(j &lt; v2.size() &amp;&amp; v2[j] !&#x3D; &#39;.&#39;) num2 &#x3D; num2 * 10 + v2[j++] - &#39;0&#39;; if(num1 &gt; num2) return 1; else if( num1 &lt; num2) return -1; i++,j++; &#125; return 0; &#125; &#125;; 解法2 基本思路：字符串分割split、双指针 这样写思路都是一样的，但是更耗空间。主要是实现了一种split。 第三个参数 const char&amp; c 也可以是 const string&amp; c。start和end 都是 string::size_type 类型的。 Code class Solution &#123; public: int compareVersion(string version1, string version2) &#123; auto split &#x3D; [](const string&amp; str, vector&lt;string&gt;&amp; res, const char&amp; c) -&gt; void &#123; auto start &#x3D; str.find_first_not_of(c, 0); auto end &#x3D; str.find_first_of(c, start); while(start !&#x3D; string::npos || end !&#x3D; string::npos) &#123; res.emplace_back(str.substr(start, end - start)); start &#x3D; str.find_first_not_of(c, end); end &#x3D; str.find_first_of(c, start); &#125; &#125;; vector&lt;string&gt; arr1, arr2; split(version1, arr1, &#39;.&#39;); split(version2, arr2, &#39;.&#39;); int i &#x3D; 0, j &#x3D; 0; while(i &lt; arr1.size() || j &lt; arr2.size()) &#123; int a &#x3D; 0, b &#x3D; 0; if(i &lt; arr1.size()) a &#x3D; stoi(arr1[i++]); if(j &lt; arr2.size()) b &#x3D; stoi(arr2[j++]); if(a !&#x3D; b) return a &gt; b ? 1 : -1; &#125; return 0; &#125; &#125;; 2023.8.81749.任意子数组和的绝对值的最大值解法 基本思路：动态规划 一眼动规。考虑到子数组是连续的，那么dp应该是一维的：dp[i] 表示以 nums[i] 结尾的子数组的和的最大值。 题中要求的是绝对值的最大值，我们可以再定一个dp表示 子数组和的最小值 。最后取 负的最小值和最大值之间的最大值即可。优化为常数级。 Code class Solution &#123; public: int maxAbsoluteSum(vector&lt;int&gt;&amp; nums) &#123; int min_dp &#x3D; 0, max_dp &#x3D; 0, res &#x3D; 0; for(int n : nums) &#123; max_dp &#x3D; max(max_dp, 0) + n; min_dp &#x3D; min(min_dp, 0) + n; res &#x3D; max(res, max(max_dp, -min_dp)); &#125; return res; &#125; &#125;; 2023.8.91281.整数的各位积和之差解法 基本思路：数学计算 Code class Solution &#123; public: int subtractProductAndSum(int n) &#123; int pro &#x3D; 1, sum &#x3D; 0; while(n) &#123; int digit &#x3D; n % 10; pro *&#x3D; digit; sum +&#x3D; digit; n &#x2F;&#x3D; 10; &#125; return pro - sum; &#125; &#125;; 2023.8.101289.下降路径最小和 Ⅱ解法 基本思路：动态规划 一眼动态规划。dp[i] [j] 定义为到达（i，j）处的最小和，显然是由上一层除同一列外的所有最小和中的最小值推出来的。因此双循环中还需要再加一个循环遍历上一层dp中的最小值。最后在最后一层dp中遍历出最小值即可。 Code class Solution &#123; public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n &#x3D; grid.size(); if(n &#x3D;&#x3D; 1) return grid[0][0]; vector&lt;vector&lt;int &gt;&gt; dp(n+1, vector&lt;int&gt;(n, 0)); for(int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; for(int j &#x3D; 0; j &lt; n; ++j) &#123; int minLast &#x3D; INT_MAX; for(int k &#x3D; 0; k &lt; n; ++k) if(k !&#x3D; j) minLast &#x3D; min(minLast, dp[i-1][k]); dp[i][j] &#x3D; minLast + grid[i-1][j]; &#125; &#125; int res &#x3D; INT_MAX; for(int n : dp[n]) res &#x3D; min(res, n); return res; &#125; &#125;; 空间优化 可以发现，递推操作就是找到上一层的最小值，然后加上当前节点的值。那么可以维护上一层的最小值来替代二维数组dp。但当遍历到跟上层最小值同一列时，是不能直接相加的。可以维护上一层的第二小值，用于这种情况的计算，同时维护上一层最小值所在的列用于判断。计算完成后更新这三个值为本层的即可。 class Solution &#123; public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n &#x3D; grid.size(); int minLast &#x3D; 0, min2Last &#x3D; 0, minIdx &#x3D; -1; for(vector&lt;int&gt;&amp; vec : grid) &#123; int tml &#x3D; INT_MAX, tm2l &#x3D; INT_MAX, tmi &#x3D; -1; for(int i &#x3D; 0; i &lt; n; ++i) &#123; int sum &#x3D; (i &#x3D;&#x3D; minIdx ? min2Last : minLast) + vec[i]; if(sum &lt; tml) &#123; tm2l &#x3D; tml; tml &#x3D; sum; tmi &#x3D; i; &#125; else if(sum &lt; tm2l) tm2l &#x3D; sum; &#125; minLast &#x3D; tml; min2Last &#x3D; tm2l; minIdx &#x3D; tmi; &#125; return minLast; &#125; &#125;; 2023.8.111572.矩阵对角线元素的和解法 基本思路：普通遍历 Code class Solution &#123; public: int diagonalSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int res &#x3D; 0, row &#x3D; 0; for(int i &#x3D; 0, j &#x3D; mat.size()-1; j &gt;&#x3D; 0; ++i, --j) &#123; if(i !&#x3D; j) res +&#x3D; mat[row][j]; res +&#x3D; mat[row++][i]; &#125; return res; &#125; &#125;; 2023.8.12美团笔.5题干 小美拿到了一棵树，每个节点有一个权值，初始每个节点都白色。小美有若干次操作，每次操作可以选择两个相邻的节点，如果它们都是白色且权值的乘积是完全平方数，小美就可以把这两个节点同时染红。小美想知道，自己最多可以染红多少个节点？ 输入描述 第一行输入一个正整数n，代表节点的数量。 第二行输入n个正整数ai，代表每个节点的权值。 接下来的n一1行，每行输入两个正整数u、v，代表节点u和节点v有一条边连接。 1 ≤ n ≤ 10^5 1 ≤ ai ≤ 10^9 1 ≤ u，v ≤ n 输出描述 输出一个整数，表示最多可以染红的节点数量。 示例 输入： 3 3 3 12 1 2 2 3 输出：2 解法 基本思路：无向图、DFS 相比于LC，笔试题还需要额外处理输入数据，也就是需要你考虑存储的数据结构。 本题写的是树，但在存储时其实可以按照无向图来理解，那么可以用二维数组存储每个节点的连通信息（包括父节点也存下来了）。用一维数组存储权值。 按照题意要染红尽可能多的节点，那么从叶节点向上染我认为是最佳策略，因此选择dfs后序的顺序，从叶节点向上递归。返回值设为以该节点为根的子树的最大染红节点数量。 Code int main() &#123; int n; &#x2F;&#x2F; 节点的数量 cin &gt;&gt; n; vector&lt;vector&lt;int&gt; &gt; tree(n+1); &#x2F;&#x2F; 邻接表表示无向图 vector&lt;int&gt; weights(n+1); &#x2F;&#x2F; 节点的权值 vector&lt;bool&gt; iswhite(n+1, true); &#x2F;&#x2F; 标记节点颜色 for(int i &#x3D; 1; i &lt;&#x3D; n; ++i) cin &gt;&gt; weights[i]; for(int i &#x3D; 1; i &lt; n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; tree[u].push_back(v); tree[v].push_back(u); &#125; auto isSqr &#x3D; [](int n) -&gt; bool &#123; int res &#x3D; sqrt(n); return res * res &#x3D;&#x3D; n; &#125;; function&lt;int(int, int)&gt; dfs &#x3D; [&amp;](int node, int parent)-&gt; int &#123; int redNodes &#x3D; 0; for(int child : tree[node]) if(child !&#x3D; parent) redNodes +&#x3D; dfs(child, node); if (parent &gt; 0 &amp;&amp; iswhite[parent] &amp;&amp; iswhite[node] &amp;&amp; isSqr(weights[node] * weights[parent])) &#123; redNodes +&#x3D; 2; iswhite[node] &#x3D; false; iswhite[parent] &#x3D; false; &#125; return redNodes; &#125;; cout &lt;&lt; dfs(1,0) &lt;&lt; endl; return 0; &#125; 2023.8.1388.合并两个有序数组解法 基本思路：双指针 因为是要存在nums1里，从前往后不好操作，但后面都是0，可以考虑从大到小填入nums1后面。 Code class Solution &#123; public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int ptr &#x3D; m + n - 1; --m;--n; while(n &gt;&#x3D; 0) &#123; if(m &gt;&#x3D; 0 &amp;&amp; nums1[m] &gt; nums2[n]) swap(nums1[ptr--], nums1[m--]); else nums1[ptr--] &#x3D; nums2[n--]; &#125; &#125; &#125;; 2023.8.15833.字符串中的查找与替换解法 基本思路：哈希？模拟 这题排序的话要三个数组一起排，python好写，CPP不太行。 边判断边修改会导致字符串长度变化从而使得下标失效，每次都需要重新计算。省力的方法就是先遍历找到需要修改的部分的下标和对应的操作下标保存下来，然后再遍历修改。 Code class Solution &#123; public: string findReplaceString(string s, vector&lt;int&gt;&amp; indices, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) &#123; vector&lt;int&gt; keys(s.size(), -1); for(int i &#x3D; 0; i &lt; indices.size(); ++i) &#123; int idx &#x3D; indices[i]; bool isDif &#x3D; false; for(char c : sources[i]) &#123; if(c !&#x3D; s[idx++]) &#123; isDif &#x3D; true; break; &#125; &#125; if(isDif) continue; keys[indices[i]] &#x3D; i; &#125; string res &#x3D; &quot;&quot;; for(int i &#x3D; 0; i &lt; s.size();) &#123; if(keys[i] !&#x3D; -1) &#123; res +&#x3D; targets[keys[i]]; i +&#x3D; sources[keys[i]].size(); &#125; else res +&#x3D; s[i++]; &#125; return res; &#125; &#125;; 2023.8.162682.找出转圈游戏输家解法 基本思路：哈希 Code class Solution &#123; public: vector&lt;int&gt; circularGameLosers(int n, int k) &#123; vector&lt;bool&gt; hash(n, false); int idx &#x3D; 0, time &#x3D; 1; while(!hash[idx]) &#123; hash[idx] &#x3D; true; idx &#x3D; (idx + k * time) % n; ++time; &#125; vector&lt;int&gt; res; for(int i &#x3D; 0; i &lt; n; ++i) if(!hash[i]) res.emplace_back(i+1); return res; &#125; &#125;; 2023.8.181388.3n块披萨解法 基本思路：贪心 最容易想到的贪心策略就是每次自己取最大的，但会存在问题。如示例2，[8,9,8,6,1,1]，第一次取9，第二次就只能取6，实际是不如取两次8的。这种情况主要体现在两侧的值和中间接近并且加起来的期望会更高。 首先确定一个前提，只要自己取的位置两两不相邻就肯定可以全部取到。那么继续上面的推理，选最优是 8 + 8，贪最大是 9 + 6，如何判断哪个更大？两边值的和 - 中间值。8 + 8 - 9 = 7 &gt; 6。因此选两边而不是中间和剩下的最大值。因为求的是最大和，那么8+8本质和9+7是一样的。由此可以继续贪心策略：每次依旧取最大的，并且删除三个，但是添加一个差值进入中间值所在位置，这样第二次取最大时，有三种情况： 最大是加入的差值，说明第一次是两边更优。因为加入差值时保留了相对位置，所以第二次删除时，差值相邻的两个元素是第一次中的两边各自相邻的元素。 最大是差值边上的元素，此时差值会被删除。那么加入元素的影响就被消除了，累加和依旧是两次的最大值。 最大不是以上两种情况，此时选择暂时和这一部分选中间还是两边无关，等到遍历到某一次最大值属于前两种情况时，再去处理这次的选择。 由于每次遍历都加入元素，最后会多出来一部分元素，不需要管。只要取完指定次数的最大值就可以了。 Code class Solution &#123; public: int maxSizeSlices(vector&lt;int&gt;&amp; slices) &#123; int res &#x3D; 0; int n &#x3D; slices.size() &#x2F; 3; for(int i &#x3D; 0; i &lt; n; ++i) &#123; int maxPos &#x3D; max_element(slices.begin(), slices.end()) - slices.begin(); int l &#x3D; (maxPos + slices.size() - 1) % slices.size(); int r &#x3D; (maxPos + slices.size() + 1) % slices.size(); res +&#x3D; slices[maxPos]; slices[maxPos] &#x3D; slices[l] + slices[r] - slices[maxPos]; if(r &lt; l) swap(l, r); slices.erase(slices.begin() + r); slices.erase(slices.begin() + l); &#125; return res; &#125; &#125;; 2023.8.212337.移动片段得到字符串解法 基本思路：双指针 L只能左移，R只能右移，同时字符之间无法跨越。那也就是说只需要比较两个字符串之间的相对位置即可。 使用两个数组，存储下两个字符串中的字符位置。之后遍历，针对上述三点进行判断：1.如果两个字符串的字符数量不一致或顺序不一致，直接false。2.如果start中的 L 在target相同顺序 L 的左侧，同样直接false，因为L无法右移。3.同理start中的 R 在target相同顺序 R 的右侧，同样直接false。 Code class Solution &#123; public: bool canChange(string start, string target) &#123; vector&lt;int&gt; schar, tchar; for(int i &#x3D; 0; i &lt; start.size(); ++i) &#123; if(start[i] !&#x3D; &#39;_&#39;) schar.emplace_back(i); if(target[i] !&#x3D; &#39;_&#39;) tchar.emplace_back(i); &#125; if(schar.size() !&#x3D; tchar.size()) return false; for(int i &#x3D; 0; i &lt; schar.size(); ++i) &#123; if(start[schar[i]] !&#x3D; target[tchar[i]]) return false; if(start[schar[i]] &#x3D;&#x3D; &#39;L&#39; &amp;&amp; schar[i] &lt; tchar[i]) return false; if(start[schar[i]] &#x3D;&#x3D; &#39;R&#39; &amp;&amp; schar[i] &gt; tchar[i]) return false; &#125; return true; &#125; &#125;; 2023.8.22849.到最近的人的最大距离解法 基本思路：数组 就是对题意的转化。离最近的人的最大距离，分两种情况： 如果是在两个人之间的，那么只能是已就坐的人中距离最大的两个人的中间位置（即最大值除以2） 如果最左/右边人的左/右边还有空位，那么还可能是最边的人到两端的距离中的更大值 Code class Solution &#123; public: int maxDistToClosest(vector&lt;int&gt;&amp; seats) &#123; int l &#x3D; -1, mid &#x3D; 0, r &#x3D; -1; for(int i &#x3D; 0; i &lt; seats.size(); ++i) &#123; if(seats[i]) &#123; if(l &gt;&#x3D; 0) mid &#x3D; max(mid, i - r); else l &#x3D; i; r &#x3D; i; &#125; &#125; r &#x3D; seats.size() - r - 1; return max(&#123;l, r, mid &#x2F; 2&#125;); &#125; &#125;; 2023.8.251448.统计二叉树中好节点的数目解法 基本思路：DFS 因为判断条件为父节点和当前节点的值大小，因此用前序遍历。维护该条路径上的最大值即可。 Code class Solution &#123; public: int goodNodes(TreeNode* root) &#123; int res &#x3D; 0; function&lt;void(TreeNode*, int)&gt; dfs &#x3D; [&amp;](TreeNode* cur, int preVal) &#123; if(!cur) return; if(cur-&gt;val &gt;&#x3D; preVal) &#123; ++res; preVal &#x3D; cur-&gt;val; &#125; dfs(cur-&gt;left, preVal); dfs(cur-&gt;right, preVal); &#125;; dfs(root, INT_MIN); return res; &#125; &#125;; 2023.8.26228.汇总区间解法 基本思路：双指针 Code class Solution &#123; public: vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; res; for(int i &#x3D; 0, j &#x3D; 0; j &lt; nums.size(); ++j) &#123; if(j &#x3D;&#x3D; nums.size()-1 || nums[j+1] !&#x3D; nums[j]+1) &#123; string str &#x3D; to_string(nums[i]); if(i !&#x3D; j) str +&#x3D; (&quot;-&gt;&quot; + to_string(nums[j])); res.emplace_back(str); i &#x3D; j + 1; &#125; &#125; return res; &#125; &#125;; 美团笔3.汇总区间 - AC题干 解法 基本思路：排序 虽然题目中说只能移动a数组，但实则在算法中可以随便移（因为只要a、b每个元素都匹配上了符合要求就必然是true，之后把b数组移回原样就相当于没移）。 之后要考虑的就是对于每个a的元素，看能不能在b中找到对应元素使得 1 - a[i] ≤ b[i] ≤ m- a[i] 。这里用的二分查找（ upper_bound和 lower_bound函数，要求数组是已排序的）。 Code int main() &#123; int q, n, m; cin &gt;&gt; q; while(q--) &#123; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n), b(n); for(int i &#x3D; 0; i &lt; n; ++i) cin &gt;&gt; a[i]; for(int i &#x3D; 0; i &lt; n; ++i) cin &gt;&gt; b[i]; sort(a.begin(), a.end()); sort(b.begin(), b.end()); bool possible &#x3D; true; for (int i &#x3D; 0; i &lt; n; ++i) &#123; int target &#x3D; m - a[i]; auto iter &#x3D; upper_bound(b.begin(), b.end()-i, target); auto iterMin &#x3D; lower_bound(b.begin(), b.end()-i, 1 - a[i]); if (iter !&#x3D; b.end()-i || iterMin &#x3D;&#x3D; b.end()-i) &#123; possible &#x3D; false; break; &#125; &#125; cout &lt;&lt; (possible ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl; &#125; &#125; 2023.8.301654.到家的最少跳跃次数解法 基本思路：BFS 本题计算步数，且每一步有多种选择，因此可以考虑BFS来解，本质其实是枚举。 用队列存储下一步的所有选项，直至走到x。1.因为不能连续后跳，以及为了标记，队列中应存储两个数据：下一步的位置和到达下一步的方向（0为后退1为前进）。2.对于BFS来说，走过的路径需要标记，否则会陷入死循环，用bool二维数组标记。3.排除forbidden数组中的位置，需要转化为哈希集合进行查找。4.范围问题；需要设置前进和后退的极限位置，否则同样会陷入死循环。后退题中给出是0，前进的最大值为6000，证明如下： 题中已给出 f , a , b , x ≤ 2000，如果 a ≥ b，当到达大于 x+b 的位置时，最多只能后跳一次，无法到达 x。此后最 保守的跳法也是前跳一次，后跳一次，无法更加接近 x。此时的最大值是 x+b。 如果 a &lt; b，最大值为 max⁡(f+a+b,x) Code class Solution &#123; public: int minimumJumps(vector&lt;int&gt;&amp; forbidden, int a, int b, int x) &#123; unordered_set&lt;int&gt; hash(forbidden.begin(), forbidden.end()); using pii &#x3D; pair&lt;int, int&gt;; queue&lt;pii&gt; q; q.push(&#123;0, -1&#125;); bool mark[6000][2] &#x3D; &#123;false&#125;; int res &#x3D; 0; while(!q.empty()) &#123; int n &#x3D; q.size(); for(int i &#x3D; 0; i &lt; n; ++i) &#123; if(q.front().first &#x3D;&#x3D; x) return res; int frt &#x3D; q.front().first + a; int bck &#x3D; q.front().first - b; if(frt &lt; 6000 &amp;&amp; !mark[frt][1] &amp;&amp; !hash.count(frt)) &#123; q.push(&#123;frt, 1&#125;); mark[frt][1] &#x3D; true; &#125; if(bck &gt;&#x3D; 0 &amp;&amp; !mark[bck][0] &amp;&amp; q.front().second &amp;&amp; !hash.count(bck)) &#123; q.push(&#123;bck, 0&#125;); mark[bck][0] &#x3D; true; &#125; q.pop(); &#125; ++res; &#125; return -1; &#125; &#125;; 打卡9月LeetCode2023.9.22511.最多可以摧毁的敌人城堡数目解法 基本思路：双指针 不需要先找到1，再找-1，只需要找到距离最远的一对即可（和为0）。 因此先找到第一个非0值，作为慢指针，记录下标和值，快指针向右遍历找到可以和慢指针组成一对的位置，更新最大杀敌数（距离 - 1）。由于每次只会从一个1到遇到的第一个 -1，因此只要快指针为非0值，都需要更新慢指针的下标和值（因为找的是一对，不是单纯的1找-1）。 Code class Solution &#123; public: int captureForts(vector&lt;int&gt;&amp; forts) &#123; int i &#x3D; 0, j; int res &#x3D; 0, headi &#x3D; -1, headv; for(; i &lt; forts.size(); ++i) &#123; if(forts[i]) &#123; headi &#x3D; i; headv &#x3D; forts[i]; break; &#125; &#125; if(headi &lt; 0) return 0; for(j &#x3D; headi + 1; j &lt; forts.size(); ++j) &#123; if(!forts[j]) continue; if(forts[j] + headv &#x3D;&#x3D; 0) res &#x3D; max(res, j - headi - 1); headi &#x3D; j; headv &#x3D; forts[j]; &#125; return res; &#125; &#125;; 小米.笔1 - AC同LeetCode.1665 hard 题干 解法 基本思路：排序 先处理输入，将数据存入vector&lt;pair&lt;int, int&gt;&gt;。之后按照差值从大到小的顺序排列（因为需要让最低要求电量满足尽可能多的任务）。 设置当前剩余电量batt和最低电量res，之后遍历数组，将当前剩余电量减去当前任务要耗费的电量。在减去之前如果batt比任务要求的最低电量小，就需要把差值补上，即 增加batt和res，使之符合当前任务的要求。 遍历结束后的值就是答案，注意有最大值4800，超过要输出-1。 Code int main() &#123; string input; getline(cin, input); istringstream iss(input); vector&lt;pair&lt;int, int&gt;&gt; taskList; string task; while (getline(iss, task, &#39;,&#39;)) &#123; int cost, req; sscanf(task.c_str(), &quot;%d:%d&quot;, &amp;cost, &amp;req); taskList.push_back(&#123;cost, req&#125;); &#125; sort(taskList.begin(), taskList.end(), [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123; return (a.first - a.second) &lt; (b.first - b.second); &#125;); int batt &#x3D; taskList[0].first; int res &#x3D; batt; for (const pair&lt;int, int&gt;&amp; item : taskList) &#123; if (batt &lt; item.second) &#123; int diff &#x3D; item.second - batt; batt +&#x3D; diff; res +&#x3D; diff; &#125; batt -&#x3D; item.first; &#125; cout &lt;&lt; (res &gt; 4800 ? -1 : res) &lt;&lt; endl; return 0; &#125;","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"}]},{"title":"查漏补缺CPP","slug":"查漏补缺CPP","date":"2023-06-20T08:08:36.000Z","updated":"2023-08-18T12:35:45.142Z","comments":true,"path":"原理/查漏补缺CPP/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BACPP/","excerpt":"C++11右值引用左值/右值左值可以取地址、位于等号左边；而右值没法取地址，位于等号右边。 int a &#x3D; 5; a可以通过 &amp; 取地址，位于等号左边，所以a是左值。 5位于等号右边，5没法通过 &amp; 取地址，所以5是个右值。 有地址的变量就是左值，没有地址的字面值、临时值就是右值。 左值引用","text":"C++11右值引用左值/右值左值可以取地址、位于等号左边；而右值没法取地址，位于等号右边。 int a &#x3D; 5; a可以通过 &amp; 取地址，位于等号左边，所以a是左值。 5位于等号右边，5没法通过 &amp; 取地址，所以5是个右值。 有地址的变量就是左值，没有地址的字面值、临时值就是右值。 左值引用能指向左值，不能指向右值的就是左值引用。引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。 int a &#x3D; 5; int &amp;ref_a &#x3D; a; &#x2F;&#x2F; 左值引用指向左值，编译通过 int &amp;ref_a &#x3D; 5; &#x2F;&#x2F; 左值引用指向了右值，会编译失败 特例： const左值引用是可以指向右值的： const int &amp;ref_a &#x3D; 5; &#x2F;&#x2F; 编译通过 const左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用const &amp;作为函数参数的原因之一，如std::vector的push_back： void push_back (const value_type&amp; val); 右值引用右值引用的标志是&amp;&amp;，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值： int &amp;&amp;ref_a_right &#x3D; 5; &#x2F;&#x2F; ok int a &#x3D; 5; int &amp;&amp;ref_a_left &#x3D; a; &#x2F;&#x2F; 编译不过，右值引用不可以指向左值 ref_a_right &#x3D; 6; &#x2F;&#x2F; 右值引用的用途：可以修改右值 引用本身的性质被声明出来的左、右值引用都是左值。 因为被声明出的左右值引用是有地址的，也位于等号左边。 void change(int&amp;&amp; right_value) &#123; &#x2F;&#x2F; 形参是个右值引用 right_value &#x3D; 8; &#125; int main() &#123; int a &#x3D; 5; &#x2F;&#x2F; a是个左值 int &amp;ref_a_left &#x3D; a; &#x2F;&#x2F; ref_a_left是个左值引用 int &amp;&amp;ref_a_right &#x3D; std::move(a); &#x2F;&#x2F; ref_a_right是个右值引用 change(a); &#x2F;&#x2F; 编译不过，a是左值，change参数要求右值 change(ref_a_left); &#x2F;&#x2F; 编译不过，左值引用ref_a_left本身也是个左值 change(ref_a_right); &#x2F;&#x2F; 编译不过，右值引用ref_a_right本身也是个左值 change(std::move(a)); &#x2F;&#x2F; 编译通过 change(std::move(ref_a_right)); &#x2F;&#x2F; 编译通过 change(std::move(ref_a_left)); &#x2F;&#x2F; 编译通过 change(5); &#x2F;&#x2F; 当然可以直接接右值，编译通过 cout &lt;&lt; &amp;a &lt;&lt; &#39; &#39;; cout &lt;&lt; &amp;ref_a_left &lt;&lt; &#39; &#39;; cout &lt;&lt; &amp;ref_a_right; &#x2F;&#x2F; 打印这三个左值的地址，都是一样的 &#125; 右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。 作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值。 这同样符合对左值，右值的判定方式：其实引用和普通变量是一样的，int &amp;&amp;ref = std::move(a)和 int a = 5没有什么区别，等号左边就是左值，右边就是右值。 综上可得以下概念： 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。 右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。 作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 std::moveint a &#x3D; 5; &#x2F;&#x2F; a是个左值 int &amp;ref_a_left &#x3D; a; &#x2F;&#x2F; 左值引用指向左值 int &amp;&amp;ref_a_right &#x3D; std::move(a); &#x2F;&#x2F; 通过std::move将左值转化为右值，可以被右值引用指向 cout &lt;&lt; a; &#x2F;&#x2F; 打印结果：5 该函数本质上等同于一个类型转换：把左值强制转化为右值，让右值引用可以指向左值。单纯的std::move()不会有性能提升。 实现移动语义实际场景中，右值引用和std::move被广泛用于STL和自定义类中实现移动语义，避免拷贝，从而提升程序性能。 class Array &#123; public: ...... &#x2F;&#x2F; 深拷贝构造 Array(const Array&amp; temp_array) &#123; size_ &#x3D; temp_array.size_; data_ &#x3D; new int[size_]; for (int i &#x3D; 0; i &lt; size_; i ++) &#123; data_[i] &#x3D; temp_array.data_[i]; &#125; &#125; &#x2F;&#x2F; 移动构造 Array(Array&amp;&amp; temp_array) &#123; data_ &#x3D; temp_array.data_; size_ &#x3D; temp_array.size_; &#x2F;&#x2F; 为防止temp_array析构时delete data，提前置空其data_ temp_array.data_ &#x3D; nullptr; &#125; public: int *data_; int size_; &#125;; int main()&#123; Array a; Array b(std::move(a)); &#125; 加个std::move会调用到移动语义函数，避免了深拷贝，这就是提高性能的原理。 编译器会默认在用户自定义的class和struct中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数。 因此，可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要**&gt;的场景，建议使用std::move**触发移动语义，提升性能。 还有些STL类是move-only的，比如unique_ptr，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝)。 关键字using导入命名空间使用C++在写不同的功能模块时，为了防止命名冲突，建议对模块取命名空间，这样在使用时就需要指定是哪个命名空间。 使用 using 导入命名空间，即使一个命名空间中的所有名字都在该作用域中可见，常见的如下： &#x2F;&#x2F; 导入整个命名空间到当前作用域 using namespace std; &#x2F;&#x2F; 只导入某个变量到当前作用域 using std::cout; 在.h头文件中，一般不应该使用using声明。 因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，从而可能产生名字冲突。 指定别名C++ 11 通过 using 指定别名，作用等同于 typedef，但相比 typedef，逻辑更直观，可读性更好。 typedef int T; &#x2F;&#x2F; 用 T 代替 int using T &#x3D; int; &#x2F;&#x2F; 用 T 代替 int 在派生类中引用基类成员 如上图代码所示，尽管派生类 Derived 对 基类 Base 是私有继承，但通过 using 声明，派生类的对象就可以访问基类的 proteced 成员变量和 public 成员函数了。 注意：using只是引用，不参与形参的指定。 operatoroperator const指针和引用关于int * const 与const int * 的区别，其实只用记住，const先修饰左边，左边没有就修饰右边。 int * const，const修饰的是指针，指针不能指向其他地址，但是指针所指向地址上保存的变量可以修改； const int * ，const左边没有，所以修饰右边的int，指针指向的变量不能修改，但是指针可以指向别的变量。 成员函数在类成员函数中，使用const关键字表示该成员函数不会修改类的任何非静态成员变量（除非它们被声明为mutable）。这样的成员函数被称为常量成员函数。 staticstatic关键字的一些主要用途： 隐藏：当static用于全局变量或函数时，它改变了变量或函数的可见性。静态的全局变量或函数仅在定义它们的源文件中可见，不会在其他源文件中产生链接冲突。这可以用来实现模块内的封装。 保持变量持久且唯一：当static用于局部变量时，它将变量的生命周期延长到整个程序执行期间。这意味着静态的局部变量在第一次执行包含它的函数时初始化，然后在程序的整个生命周期内保持其值。即使函数多次调用，静态的局部变量的值也会在调用之间保持不变。 静态类成员变量：当static用于类成员变量时，该成员变量被所有该类的对象共享。也就是说，类的所有实例都将访问同一个静态成员变量，而不是为每个实例分配独立的存储空间。 静态类成员函数：当static用于类成员函数时，这个函数可以在不创建类的实例的情况下直接通过类名调用。静态成员函数没有this指针，因此它只能访问类的静态成员变量。 静态变量的初始化时机c与c++不同： 静态变量只会初始化一次，静态变量放在全局区域，所以在主程之前就会为其分配内存。 对于c而言，c是在代码执行前，编译阶段分配好内存后，进行初始化。 对于c++而言，它是在执行相关代码时被初始化。 函数匿名函数C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式)。 它是定义和使用匿名函数对象的一种简便的方式。匿名函数是我们需要用到的一个函数，但是又不想去费力命名一个函数的场景。我们无需为每个值或者每种类型)单独编写函数，更不必把值保存在让人厌倦的全局变量中 。 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。 结构 一个可能为空的捕获列表，指明定义环境中的那些名字能被用在lambda表达式内，以及这些名字的访问形式拷贝还是引用，捕获列表位于 [] 内。 一个可选的参数列表，指明lambda表达式所需的参数，参数列表位于 () 内。 一个可以选的mutable修饰符，指明该lambda表达式可能会修改它自身的状态（即，改变通过值捕获的变量的副本） 一个可选的 -&gt; 形式的返回类型声明 一个表达式体，指明要执行的代码，表达式位于 {} 内。 [捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123; &#x2F;&#x2F; 函数体 &#125; 参数分析1.捕获列表 参数 效果 [] 默认不能使用所在函数中的变量 [=] 默认以值捕获所有变量 [&amp;] 默认以引用捕获所有变量 [x] 仅以值捕获x，其它变量不捕获 [&amp;x] 仅以引用捕获x，其它变量不捕获 [=,&amp;x] 默认以值捕获所有变量，但是x是例外，通过引用捕获 [&amp;,x] 默认以引用捕获所有变量，但是x是例外，通过值捕获 [this] 通过引用捕获当前对象（其实是复制指针） [*this] 通过传值方式捕获当前对象 2.捕获使用分析 值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝。 void value_capture() &#123; int value &#x3D; 1; auto copy_value &#x3D; [value] &#123; return value; &#125;; value &#x3D; 100; auto stored_value &#x3D; copy_value(); cout &lt;&lt; stored_value &lt;&lt; endl; &#125; 如上代码中， value == 100 而 stored_value == 1。 引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。 auto copy_value = [&amp;value] &#123;&#125; 上述代码中，改为引用捕获后，两个值均为100。 3.返回值 一般情况下，编译器会自动推断出lambda的返回类型。 但是如果函数体里面有多个返回语句，甚至有一些常量return返回时候，编译器无法自动推断其返回类型，这个时候我们需要指定其返回类型。 c++141.捕获时计算 int x &#x3D; 3, y &#x3D; 5; auto lam &#x3D; [z &#x3D; x + y]() &#123; return z; &#125; int z &#x3D; lam(); 在多次调用该函数时，可以直接从构造对象中读取 z，而非每次都计算一次 x + y 。 2.即调用函数表达式 int x &#x3D; 3, y &#x3D; 5; const int val &#x3D; [z &#x3D; x + y]() &#123; return z; &#125;(); 当初始化常量的过程较为复杂的时候，可以将初始化逻辑放入Lambda表达式中。 3.递归调用 int main() &#123; auto factorial &#x3D; [ f_impl &#x3D; [](int n ,auto&amp;&amp; impl)-&gt;int &#123; return n &gt; 1 ? n * impl(n-1,impl) : 1; &#125;](int n)&#123; return f_impl(n,f_impl); &#125;; &#125; 注意在递归时，需要显式给出匿名函数的返回值（即 f_impl 会返回的值） 编译器并不需要知道factorial、f_impl的类型，故使用auto不会出现无法确定factorial、f_impl的返回类型这种trick。并且将 f_impl 置于 Capture 中，仅在初始化 factorial 时初始化一次 f_impl ，而不用多次初始化。 STLSTL容器大纲底层实现 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 迭代器 random_access_iterator（随机访问迭代器，可通过偏移量直接访问(如 it + 5) ) array 由于数组是连续空间，可以根据头指针偏移量来直接寻址 vector 动态数组容器由于是连续空间，类似数组，所以也可以根据头指针偏移量来直接寻址 deque 双向队列的内部实现其实是通过多个连续空间拼接而成的，所以也可以直接寻址 bidirectional_iterator（双向迭代器，可以通过 **++**、 – 操作访问前后元素 ） list 列表的内部实现是双向链表，不是连续空间，因此只能使用指针逐一迭代间接寻址 底层实现为红黑树的，集合 set / multiset 和表 map / multimap 红黑树结构如下： struct __rb_tree_node_base &#123; typedef __rb_tree_color_type color_type; typedef __rb_tree_node_base* base_ptr; color_type color; base_ptr parent; base_ptr left; base_ptr right; &#125; forward_iterator（单向迭代器，可以通过**++**访问下一元素 ） 底层实现为哈希表的，无序集合 unordered_set / unordered_multiset 和无序表 unordered_map / unordered_multimap forward_list 单向列表的内部实现为单向链表，只支持单向迭代 哈希表结构如下： template &lt;class Value&gt; struct __hashtable_node &#123; __hashtable_node* next; Value val; &#125; input_iterator（输入迭代器） output_iterator（输出迭代器） 以上两种应用较少，常用于指向流，来读取流中的数据或向流中写入数据（若ostream_iterator（属于output_iterator）指向cout，那么即可向cout这个ostream写值，实现输出的效果） 效率： random_access_iterator &gt; bidirectional_iterator &gt; forward_iterator 继承关系：input_iterator → forward_iterator → bidirectional_iterator → random_access_iterator 但output_iterator和上述没有继承关系 setset和unordered_set都有只读键。如果键值发生变化，数据结构会将其归档到错误的位置，您将无法再找到它。因此无论是for循环或迭代器遍历，返回的都是常量值，无法修改。 C++提高速度运算减少除法运算 无论是整数还是浮点数的运算，除法都会比较耗时，所以最后将除法运算等效成乘法运算。例如：a/b&gt;20可改为a&gt;b*20，可以简化程序的运行时间。 多用++、–、+=、-= 通常使用自加、自减指令和复合赋值表达式(如a-=1及a+=1等)能生成高质量的程序代码，编译器通常都能够生成inc和dec之类的指令，而使用a=a+1或a=a-1之类的指令，有很多C编译器都会生成二到三个字节的指令。 变量&amp;参数减少值传递，多用引用来传递参数 bool Compare（string s1, string s2) bool Compare(string *s1, string *s2) bool Compare(string &amp;s1, string &amp;s2) bool Compare(const string &amp;s1, const string &amp;s2) 其中若使用第一个函数（值传递），则在参数传递和函数返回时，需要调用string的构造函数和析构函数两次（即共多调用了四个函数），而其他的三个函数（指针传递和引用传递）则不需要调用这四个函数。因为指针和引用都不会创建新的对象。如果一个构造一个对象和析构一个对象的开销是庞大的，这就是会效率造成一定的影响。 然而在很多人的眼中，指针是一个恶梦，使用指针就意味着错误，那么就使用引用吧！它与使用普通值传递一样方便直观，同时具有指针传递的高效和能力。因为引用是一个变量的别名，对其操作等同于对实际对象操作，所以当你确定在你的函数是不会或不需要变量参数的值时，就大胆地在声明的前面加上一个const吧，就如最后的一个函数声明一样。同时加上一个const还有一个好处，就是可以对常量进行引用，若不加上const修饰符，引用是不能引用常量的。 多用局部变量，少用静态变量 使用局部变量的效率比使用静态变量要高。 局部变量是存在于堆栈中的，对其空间的分配仅仅是修改一次esp寄存器的内容即可（即使定义一组局部变量也是修改一次）。而局部变量存在于堆栈中最大的好处是，函数能重复使用内存，当一个函数调用完毕时，退出程序堆栈，内存空间被回收，当新的函数被调用时，局部变量又可以重新使用相同的地址。当一块数据被反复读写，其数据会留在CPU的一级缓存（Cache）中，访问速度非常快。而静态变量却不存在于堆栈中。 多用直接初始化 ClassTest ct1; ClassTest ct2(ct1); &#x2F;&#x2F;直接初始化 ClassTest ct3 &#x3D; ct1; &#x2F;&#x2F;复制初始化 当用于类类型对象时，初始化的复制形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，复制初始化总是调用复制构造函数。复制初始化首先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象”。 通常直接初始化和复制初始化仅在低级别优化上存在差异，然而，对于不支持复制的类型，或者使用非explicit构造函数的时候，它们有本质区别。 ifstream file1(&quot;filename&quot;):&#x2F;&#x2F;ok:direct initialization ifstream file2 &#x3D; &quot;filename&quot;;&#x2F;&#x2F;error:copy constructor is private 类 成员变量初始化的顺序为：先进行声明时初始化，然后进行初始化列表初始化，最后进行构造函数初始化。（另外初始化列表中初始化的顺序是和变量声明的顺序一样，而与列表中的顺序无关）","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"}]},{"title":"常用数据结构和算法的CPP实现","slug":"常用数据结构和算法的CPP实现","date":"2023-06-06T01:55:34.000Z","updated":"2023-08-03T02:25:29.154Z","comments":true,"path":"原理/常用数据结构和算法的CPP实现/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/","excerpt":"数据结构二叉树二叉树的种类满二叉树如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。具有如下性质： 满二叉树中第 i 层的节点数为 2 ^ (i - 1) 个。 深度为 k 的满二叉树必有 2 ^ k - 1 个节点 ，叶子数为 **2 ^ (k - 1)**。 满二叉树中不存在度为 1 的节点，每一个分支点中都有两棵深度相同的子树，且叶子节点都在最底层。 具有 n 个节点的满二叉树的深度为 **log2(n+1)**。 完全二叉树如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。","text":"数据结构二叉树二叉树的种类满二叉树如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。具有如下性质： 满二叉树中第 i 层的节点数为 2 ^ (i - 1) 个。 深度为 k 的满二叉树必有 2 ^ k - 1 个节点 ，叶子数为 **2 ^ (k - 1)**。 满二叉树中不存在度为 1 的节点，每一个分支点中都有两棵深度相同的子树，且叶子节点都在最底层。 具有 n 个节点的满二叉树的深度为 **log2(n+1)**。 完全二叉树如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。 二叉搜索树上述结构的树均没有数值，而二叉搜索树是有数值的。二叉搜索树是一个有序树，也叫二叉排序树、二叉查找树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 平衡二叉搜索树AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是 logn。 二叉树的属性对称性采用类前序遍历，比较的是左右子树是否对称，左子树按照中左右的顺序，那么右子树就是中右左的顺序。 递归处理顺序为： 比较当前左右节点 比较左节点的左子节点和右子树右子节点 比较左节点的右子节点和右子树左子节点 bool recursion(TreeNode* left, TreeNode* right) &#123; if(!left &amp;&amp; !right) return true; if(!left || !right || (left-&gt;val !&#x3D; right-&gt;val)) return false; return recursion(left-&gt;left, right-&gt;right) &amp;&amp; recursion(left-&gt;right, right-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; return recursion(root-&gt;left, root-&gt;right); &#125; 节点数采用后序遍历，递归好写： int countNodes(TreeNode* root) &#123; if (root &#x3D;&#x3D; NULL) return 0; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125; 时间复杂度：O(n) 空间复杂度：O(log n)，算上了递归系统栈占用的空间 深度 &amp; 高度 二叉树节点的深度：指从根节点到该节点的最长简单路径边的长度。（多用层序） 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的长度。（多用后序） 最近公共祖先LCALCA（Lowest Common Ancestor）又分为普通二叉树和搜索二叉树两种遍历方式。 普通二叉树 从根节点开始遍历整个二叉树。 如果当前节点为空节点或者等于其中一个目标节点，那么当前节点就是其中一个目标节点或者其中一个目标节点的祖先。返回当前节点。 递归在当前节点的左子树中寻找两个目标节点的LCA，返回结果为left。 递归在当前节点的右子树中寻找两个目标节点的LCA，返回结果为right。 如果left和right都不为空，说明两个目标节点分别位于当前节点的左右子树中，那么当前节点就是它们的LCA。返回当前节点。 如果left为空，说明两个目标节点都不在当前节点的左子树中，LCA一定在右子树中。返回right。 如果right为空，说明两个目标节点都不在当前节点的右子树中，LCA一定在左子树中。返回left。 这个递归的过程会自底向上地找到LCA。在遍历过程中，每个节点都会被访问一次，因此时间复杂度为O(N)，其中N是二叉树中的节点数。递归过程中使用的额外空间取决于二叉树的高度，最坏情况下为**O(N)**。 TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root &#x3D;&#x3D; p || root &#x3D;&#x3D; q || root &#x3D;&#x3D; NULL) return root; TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q); if(left &amp;&amp; right) return root; if(left &#x3D;&#x3D; NULL) return right; return left; &#125; 二叉搜索树BST 从根节点开始，将目标节点的值与当前节点的值进行比较。 如果当前节点的值大于两个目标节点的值，说明两个目标节点都位于当前节点的左子树中，那么继续在左子树中寻找LCA。 如果当前节点的值小于两个目标节点的值，说明两个目标节点都位于当前节点的右子树中，那么继续在右子树中寻找LCA。 如果以上两种情况都不满足，那么当前节点就是我们要找的LCA。 这是因为根据BST的性质，对于任意节点x，其左子树中的所有节点值都小于x的值，右子树中的所有节点值都大于x的值。因此，如果两个目标节点分别位于x的左右子树中，那么x就是它们的LCA。 这个方法的时间复杂度取决于树的高度，最坏情况下为O(H)，其中H是树的高度。递归过程中使用的额外空间取决于递归栈的深度，最坏情况下为**O(H)**。 TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); else return root; &#125; 二叉树的存储方式链式存储 顺序存储 用数组来存储二叉树的遍历：如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 二叉树的遍历方式深度优先方式（栈） 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 前中后，指的是中间节点的遍历顺序。 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 广度优先方式（队列） 层次遍历（迭代法） 二叉树的构造后序 + 中序 第一步：如果数组大小为零的话，说明是空节点 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点 第四步：切割中序数组，切成中序左数组和中序右数组 第五步：切割后序数组，切成后序左数组和后序右数组（切割后的两个数组长度依旧和中序的相等） 第六步：递归处理左区间和右区间 前序 + 中序前序和后序的构造步骤差不多，区别在于第二步，前序是从序列头部取第一个值。 前序 + 后序 X前序和后序不能唯一确定一棵二叉树！，因为没有中序遍历无法确定左右部分，也就是无法分割。例如： tree1 和 tree2 的前序遍历都是[1 2 3]， 后序遍历都是[3 2 1]。 二叉树的实现链表：节点实现struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; &#125;; 前中后序遍历（递归）void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123; if (cur &#x3D;&#x3D; NULL) return; vec.push_back(cur-&gt;val); &#x2F;&#x2F; 中 traversal(cur-&gt;left, vec); &#x2F;&#x2F; 左 traversal(cur-&gt;right, vec); &#x2F;&#x2F; 右 &#125; 前序：中左右 中序：左中右 后序：左右中 前序遍历（迭代）void traversal(TreeNode* root, vector&lt;int&gt;&amp; vec) &#123; stack&lt;TreeNode*&gt; st; if(root &#x3D;&#x3D; nullptr) return; st.push(root); while(!st.empty())&#123; TreeNode* node &#x3D; st.top(); st.pop(); vec.push_back(node-&gt;val); if(node-&gt;right) st.push(node-&gt;right); if(node-&gt;left) st.push(node-&gt;left); &#x2F;&#x2F; 因为读完根节点后是左节点，因此需要先将右节点压栈，才能先读左节点 &#125; &#125; 后序遍历（迭代）前序是中左右，反一下遍历子节点的顺序，先右再左，就是中右左；而后序是左右中，两者相反，只需在中序的基础上反转数组即可。 void traversal(TreeNode* root, vector&lt;int&gt;&amp; vec) &#123; stack&lt;TreeNode*&gt; st; if(root &#x3D;&#x3D; nullptr) return; st.push(root); while(!st.empty())&#123; TreeNode* node &#x3D; st.top(); st.pop(); vec.push_back(node-&gt;val); if(node-&gt;left) st.push(node-&gt;left); if(node-&gt;right) st.push(node-&gt;right); &#125; reverse(vec.begin(), vec.end()); &#125; 中序遍历（迭代）比较特殊，存在访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。 因为中序是左中右的顺序，所以需要先遍历到最左侧的左节点（没下一个左节点时），加入结果中。此时该节点为局部根节点（相当于中），然后就访问右节点。（右节点可能存在左节点和右节点，所以跟根节点的遍历一样处理）。 class Solution &#123; public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; st; TreeNode* cur &#x3D; root; if(root &#x3D;&#x3D; nullptr) return res; while(!st.empty() || cur)&#123; if(cur)&#123; st.push(cur); cur &#x3D; cur-&gt;left; &#125; else &#123; cur &#x3D; st.top(); st.pop(); res.push_back(cur-&gt;val); cur &#x3D; cur-&gt;right; &#125; &#125; return res; &#125; &#125;; 层序遍历void levelOrder(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if(root &#x3D;&#x3D; nullptr) return; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt; layer; int n &#x3D; q.size(); for(int i &#x3D; 0; i &lt; n; ++i)&#123; TreeNode* node &#x3D; q.front(); q.pop(); layer.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; res.push_back(layer); &#125; return; &#125; 前中序构造TreeNode* buildChild(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preHead, int inHead, int len) &#123; if(len &#x3D;&#x3D; 0) return nullptr; TreeNode* node &#x3D; new TreeNode(preorder[preHead]); if(len &#x3D;&#x3D; 1) return node; int seg; for(seg &#x3D; inHead; seg &lt; inHead + len; ++seg) if(inorder[seg] &#x3D;&#x3D; node-&gt;val) break; int rightLen &#x3D; inHead + len - seg - 1; node-&gt;left &#x3D; buildChild(preorder, inorder, preHead + 1, inHead, seg - inHead); node-&gt;right &#x3D; buildChild(preorder, inorder, preHead + 1 + seg - inHead, seg + 1, rightLen); return node; &#125; buildChild(preorder, inorder, 0, 0, preorder.size()); 中后序构造TreeNode* buildChild(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int inHead, int postTail, int len) &#123; if(len &#x3D;&#x3D; 0) return nullptr; TreeNode* node &#x3D; new TreeNode(postorder[postTail]); if(len &#x3D;&#x3D; 1) return node; int seg; for(seg &#x3D; inHead; seg &lt; inHead + len; ++seg) if(inorder[seg] &#x3D;&#x3D; node-&gt;val) break; int rightLen &#x3D; inHead + len - seg - 1; node-&gt;left &#x3D; buildChild(inorder, postorder, inHead, postTail - rightLen - 1, seg - inHead); node-&gt;right &#x3D; buildChild(inorder, postorder, seg + 1, postTail - 1, rightLen); return node; &#125; buildChild(inorder, postorder, 0, postorder.size() - 1, postorder.size()); 删除TreeNode* deleteNode(TreeNode* root, int key) &#123; if (root &#x3D;&#x3D; nullptr) return root; if (root-&gt;val &#x3D;&#x3D; key) &#123; if (root-&gt;right &#x3D;&#x3D; nullptr) &#123; &#x2F;&#x2F; 这里第二次操作目标值：最终删除的作用 return root-&gt;left; &#125; TreeNode *cur &#x3D; root-&gt;right; while (cur-&gt;left) &#123; cur &#x3D; cur-&gt;left; &#125; swap(root-&gt;val, cur-&gt;val); &#x2F;&#x2F; 这里第一次操作目标值：交换目标值其右子树最左面节点。 &#125; root-&gt;left &#x3D; deleteNode(root-&gt;left, key); root-&gt;right &#x3D; deleteNode(root-&gt;right, key); return root; &#125; BST插入递归 TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(root &#x3D;&#x3D;nullptr) return new TreeNode(val); if(root-&gt;val &gt; val) root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val); else root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val); return root; &#125; 迭代 TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(root &#x3D;&#x3D; nullptr) return new TreeNode(val); TreeNode* cur &#x3D; root; TreeNode* parent &#x3D; root; while(cur) &#123; parent &#x3D; cur; if(cur-&gt;val &gt; val) cur &#x3D; cur-&gt;left; else cur &#x3D; cur-&gt;right; &#125; if(parent-&gt;val &gt; val) parent-&gt;left &#x3D; new TreeNode(val); else parent-&gt;right &#x3D; new TreeNode(val); return root; &#125; BST删除（迭代）TreeNode* deleteNode(TreeNode* root, int key) &#123; if(root &#x3D;&#x3D; nullptr) return root; if(root-&gt;val &gt; key) root-&gt;left &#x3D; deleteNode(root-&gt;left, key); else if(root-&gt;val &lt; key) root-&gt;right &#x3D; deleteNode(root-&gt;right, key); else &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; &#x2F;&#x2F; 全空，叶子节点不用调整结构 delete root; return nullptr; &#125; if(!root-&gt;left) &#123; &#x2F;&#x2F; 只有右子树，把右子树挪上来 TreeNode* tmp &#x3D; root-&gt;right; delete root; return tmp; &#125; if(!root-&gt;right) &#123; &#x2F;&#x2F; 只有左子树，把左子树挪上来 TreeNode* tmp &#x3D; root-&gt;left; delete root; return tmp; &#125; else &#123; &#x2F;&#x2F; 左右子树均有，左子树归入右子树的最左侧叶子节点下，右子树上挪 TreeNode* cur &#x3D; root-&gt;right; while(cur-&gt;left) cur &#x3D; cur-&gt;left; cur-&gt;left &#x3D; root-&gt;left; TreeNode* tmp &#x3D; root-&gt;right; delete root; return tmp; &#125; &#125; return root; &#125; 有序数组构造高度平衡BST（递归）迭代会较为麻烦，因为需要开辟多个队列存储数组下标和节点信息。 TreeNode* sortedArrayToSubBST(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if(l &gt; r) return nullptr; int mid &#x3D; l + (r - l) &#x2F; 2; TreeNode* nd &#x3D; new TreeNode(nums[mid]); nd-&gt;left &#x3D; sortedArrayToSubBST(nums, l, mid - 1); nd-&gt;right &#x3D; sortedArrayToSubBST(nums, mid + 1, r); return nd; &#125; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return sortedArrayToSubBST(nums, 0, nums.size() - 1); &#125; BST2平衡BST在上一步的基础上，先用中序遍历将BST转化为有序数组，再将数组构造为平衡BST TreeNode* balanceBST(TreeNode* root) &#123; vector&lt;int&gt; nums; auto tree2SortedArray &#x3D; [&amp;nums, circle &#x3D; [&amp;](auto&amp;&amp; self, TreeNode* cur) -&gt; void &#123; if(cur &#x3D;&#x3D; nullptr) return; self(self, cur-&gt;left); nums.emplace_back(cur-&gt;val); self(self, cur-&gt;right); return; &#125; ](TreeNode* root) &#123; circle(circle, root); &#125;; auto SortedArray2BBST &#x3D; [&amp;nums, circle &#x3D; [&amp;](auto&amp;&amp; self, int l, int r) -&gt; TreeNode* &#123; if(l &gt; r) return nullptr; int mid &#x3D; (l + r) &#x2F; 2; TreeNode* node &#x3D; new TreeNode(nums[mid]); node-&gt;left &#x3D; self(self, l, mid - 1); node-&gt;right &#x3D; self(self, mid + 1, r); return node; &#125; ]() &#123; return circle(circle, 0, nums.size() - 1); &#125;; tree2SortedArray(root); return SortedArray2BBST(); &#125; 注 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。 堆堆的定义二叉堆堆是一个树形结构，底层是一棵完全二叉树。而完全二叉树是一层一层按照进入的顺序排成的。按照这个特性，我们可以用数组来按照完全二叉树实现堆。 上图就是一个完全二叉树，也是一个最大堆。而最大堆有一个性质：每一个节点的值都小于它父节点的值。 需要注意的是，每一个节点的值的大小与它所处的深度没有必然的联系。如第三层的六号和七号节点都小于处于最后一层的八号和十号节点。 堆的实现堆的存储如果将这个最大堆存入数组中，黑色的数字就是存储的顺序。可以根据任意一个节点的索引(除去根节点)找到它的父节点的索引，如果当前节点的索引为index，那么： 当前节点的父节点 = index / 2(这里我们将结果取整)。 当前节点的左子节点 = index * 2 当前节点的右子节点 = index * 2 + 1。 堆的插入删除1.建立堆 数组具有对应的树表示形式。一般情况下，树并不满足堆的条件，通过重新排列元素，可以建立一颗“堆化”的树。以下以大根堆为例。 2.插入元素 新元素被插入到列表层（即完全二叉树最后的位置），将其和父节点比较。如果新元素比父节点大，那么交换两者。交换之后，继续和新的父节点比较，直至新元素不比父节点大，随后树被更新以恢复堆次序。（其时间复杂度为O(logN)），以上操作称为上溯（percolate up）操作。 3.删除元素 删除总是发生在根节点处。树中最后一个元素被用来填补空缺位置，称为暂时根节点，然后将暂时根节点不断和子节点（左右两子节点中大的那一个节点）进行比较，如果他比子节点小，则交换节点位置，直到暂时根节点不小于任何一个子节点，结果树被更新以恢复堆条件。以上操作被称为下溯（percolate down）。 具体实现简单版本： 一个固定空间大小，支持选择基础数据类型的大根堆。 template&lt;typename T&gt; class MaxHeapStable&#123; private: T* data; int idx; int len; void percolate_up(int i)&#123; while(i &gt; 1 &amp;&amp; data[i] &gt; data[i&#x2F;2])&#123; swap(data[i], data[i&#x2F;2]); i &#x2F;&#x3D; 2; &#125; &#125; void percolate_down(int i)&#123; while(i * 2 &lt;&#x3D; idx)&#123; int child &#x3D; i * 2; if(child + 1 &lt;&#x3D; idx &amp;&amp; data[child] &lt; data[child + 1]) child +&#x3D; 1; if(data[i] &gt;&#x3D; data[child]) break; swap(data[i], data[child]); i &#x3D; child; &#125; &#125; public: MaxHeapStable(int len)&#123; data &#x3D; new T[len + 1]; idx &#x3D; 0; this-&gt;len &#x3D; len; &#125; ~MaxHeapStable()&#123; delete [] data; &#125; int size()&#123; return idx; &#125; bool isEmpty()&#123; return idx &#x3D;&#x3D; 0; &#125; void push(T val)&#123; assert(idx &lt; len); data[++idx] &#x3D; val; percolate_up(idx); &#125; T pop()&#123; assert(idx &gt; 0); T res &#x3D; data[1]; swap(data[1], data[idx]); idx--; percolate_down(1); return res; &#125; &#125;; 2.0版本 底层改用vector实现，支持动态大小、选择基础数据类型的大根堆。 template&lt;typename T&gt; class MaxHeapBase&#123; private: vector&lt;T&gt; data; int idx; void big_percolate_up(int i)&#123; while(i &gt; 1 &amp;&amp; data[i] &gt; data[i&#x2F;2])&#123; swap(data[i], data[i&#x2F;2]); i &#x2F;&#x3D; 2; &#125; &#125; void big_percolate_down(int i)&#123; while(i * 2 &lt;&#x3D; idx)&#123; int child &#x3D; i * 2; if(child + 1 &lt;&#x3D; idx &amp;&amp; data[child] &lt; data[child + 1]) child +&#x3D; 1; if(data[i] &gt;&#x3D; data[child]) break; swap(data[i], data[child]); i &#x3D; child; &#125; &#125; public: MaxHeapBase()&#123; data.emplace_back(0); &#125; MaxHeapBase(int len)&#123; data.resize(len + 1); data.emplace_back(0); &#125; MaxHeapBase(initializer_list&lt;T&gt; vals)&#123; data.resize(vals.size() + 1); idx &#x3D; 0; for(auto v : vals) push(v); &#125; ~MaxHeapBase() &#123; vector&lt;T&gt;().swap(data); &#125; int size() &#123; return idx; &#125; int capacity() &#123; return data.capacity(); &#125; int depth() &#123; return ceil(log2(idx + 1)); &#125; bool isEmpty() &#123; return idx &#x3D;&#x3D; 0; &#125; void clear() &#123; data.clear(); idx &#x3D; 0; &#125; void push(T val)&#123; idx++; if(idx &lt; capacity()) data[idx] &#x3D; val; else data.emplace_back(val); big_percolate_up(idx); &#125; T pop()&#123; assert(idx &gt; 0); swap(data[1], data[idx]); idx--; big_percolate_down(1); return data[idx+1]; &#125; T top()&#123; return data[1]; &#125; &#125;; STL版本（priority_queue）刚好写了道算法题，打算测试2.0时，发现需要对 pair&lt;int, int&gt; 类型进行排序，也就意味着需要真正的泛型编程，支持自定义比较方式，才能支持底层容器vector能支持的全部类型。 注意，使用template实现模板类和函数时，必须将实现也放在头文件中，因为模板类和函数的实例化都是在预处理阶段，而不是编译、链接。若将其声明和定义分开，在预处理阶段在CPP文件填入声明时，找不到定义会报错。 学习STL源码： 1.首先形成一个堆的核心结构在于两个算法：上溯和下溯。 &#x2F;&#x2F; 上溯 template&lt;typename _Iterator, typename _Distance, typename _Tp, typename _Compare&gt; void _push_heap_S(_Iterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __cp) &#123; &#x2F;&#x2F; 获取它的父节点 _Distance __parent &#x3D; (__holeIndex - 1) &#x2F; 2; &#x2F;&#x2F; 不断向上更新直至不满足_Compare规则 while(__holeIndex &gt; __topIndex &amp;&amp; __cp(__first + __parent, __value)) &#123; *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(*(__first + __parent)); __holeIndex &#x3D; __parent; __parent &#x3D; (__holeIndex - 1) &#x2F; 2; &#125; *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(__value); &#125; 在上溯中， __holeIndex就是新加入的需要调整的节点序号（从0开始）， __value是该节点的值， __cp是一个实现自定义比较方式的 funtor仿函数的临时对象。 __topIndex需要和后文结合起来看才明白意义，这里只是表明在调整过程中新加节点的位置不得超过它。 只要满足上述条件并且满足 __cp规则，就将父节点的值赋给新节点处，并更新待调整节点及其父节点位置。直至不满足 __cp规则，将 __value赋给当前待调整节点。 &#x2F;&#x2F; 下溯 template&lt;typename _Iterator, typename _Distance, typename _Tp, typename _Compare&gt; void _adjust_heap_S(_Iterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __cp) &#123; &#x2F;&#x2F; __topIndex是保持整体结构不出问题的关键 const _Distance __topIndex &#x3D; __holeIndex; _Distance __secondChild &#x3D; __holeIndex; &#x2F;&#x2F; 将非叶子节点沉入叶子节点深度 while (__secondChild &lt; (__len - 1) &#x2F; 2) &#123; &#x2F;&#x2F; 取子节点中更符合__Compare的节点 __secondChild &#x3D; 2 * (__secondChild + 1); if (__cp(__first + __secondChild, __first + (__secondChild - 1))) __secondChild--; &#x2F;&#x2F; 交换两者位置（此时不比较） *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(*(__first + __secondChild)); __holeIndex &#x3D; __secondChild; &#125; &#x2F;&#x2F; 当size()为偶数，且洞节点被移至这个最小的非叶节点时，需要特殊处理（因为只有左节点） if ((__len &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; __secondChild &#x3D;&#x3D; (__len - 2) &#x2F; 2) &#123; __secondChild &#x3D; 2 * (__secondChild + 1); *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(*(__first + (__secondChild - 1))); __holeIndex &#x3D; __secondChild - 1; &#125; &#x2F;&#x2F; 此时洞节点为最右的叶子节点，前面的节点均调整至了符合__cp规则的情况（合理的堆），相当于将这个洞节点的值插入前面的堆中 _push_heap_S(__first, __holeIndex, __topIndex, _GLIBCXX_MOVE(__value), __gnu_cxx::__ops::__iter_comp_val(__cp)); &#125; 该函数表现为以 __holeIndex 为根节点的局部下溯操作。当 __holeIndex = 0 为根节点时，该函数表现为全局的下溯操作。 while循环负责将 __holeIndex 节点逐层下沉直至叶子节点深度。 注意：当size()为奇数时，最后一个非叶节点有两个叶子节点，此时正常完成循环，选择符合 __cp 规则的子节点交换沉入；但当size()为偶数时， (__len - 1) / 2计算得到的序号为最后的非叶节点，但实际上该节点依旧可以下沉一步，因此由下面的if处理特殊情况。 size()为偶数时， (__len - 1) / 2和 (__len - 2) / 2的计算结果是一致的（后者用于计算最后的非叶节点序号）。 此时，已经完成了一次下溯操作，，除去刚下沉至最后的那个叶子节点， __holeIndex及以下的节点已经调整至了符合 __cp规则的情况（合理的堆），此时又进行了一次上溯操作，相当于将这个节点插入堆中（TODO：这里不太明白为什么不直接下溯一步到位，要排除这个下沉元素再重新上溯一次）。 2.其次，在初始化堆时，需要执行建堆操作。 template&lt;typename _Iterator, typename _Compare&gt; void _make_heap_S(_Iterator __first, _Iterator __last, _Compare __cp) &#123; typedef typename iterator_traits&lt;_Iterator&gt;::value_type _ValueType; typedef typename iterator_traits&lt;_Iterator&gt;::difference_type _DistanceType; if (__last - __first &lt; 2) return; &#x2F;&#x2F; size() const _DistanceType __len &#x3D; __last - __first; &#x2F;&#x2F; 获取最后一个非叶子节点的位置 _DistanceType __parent &#x3D; (__len - 2) &#x2F; 2; &#x2F;&#x2F; 从后向前遍历所有非叶子节点，每个节点都仅与其下面的节点按照_Compare进行调整，不影响树的整体结构 while (true) &#123; &#x2F;&#x2F; 取出每个非叶子节点的值 &#x2F;&#x2F; _GLIBCXX_MOVE根据_Compare版本选择使用std::move还是直接赋值。 _ValueType __value &#x3D; _GLIBCXX_MOVE(*(__first + __parent)); _adjust_heap_S(__first, __parent, __len, _GLIBCXX_MOVE(__value), __cp); if (__parent &#x3D;&#x3D; 0) return; __parent--; &#125; &#125; &#x2F;&#x2F; make heap template&lt;typename _Iterator&gt; inline void make_heap_S(_Iterator _first, _Iterator _last) &#123; _make_heap_S(_first, _last, __gnu_cxx::__ops::__iter_less_iter()); &#125; template&lt;typename _Iterator, typename _Compare&gt; inline void make_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123; _make_heap_S(_first, _last, __gnu_cxx::__ops::__iter_comp_iter(_cp)); &#125; 注意：这里有个关键点就是把 __parent作为 __topIndex参数传入，保证非叶节点在调整时不会和节点上方的父节点有交集，影响树的整体结构。 举个例子：大根堆中，根节点序号0是整个堆的最小值，而最后一个非叶节点序号2是整个堆的最大值，此时按照 _adjust_heap_S() 函数的逻辑，2将下沉至叶子节点然后上溯。若没有 __topIndex限制，2回到原本位置后并不会停止，而是会继续向上与根节点比较，来到根节点的位置。此时根节点最小值被换到了2原本的位置，但2这个位置在 _make_heap_S() 中已经遍历结束了，不再碰了。但实际上这个节点是比它的叶子节点更小的，却没有处理的机会了，这就破坏了堆的结构。 3.然后就是堆的插入、删除。 插入就是在底层容器vector中加入新元素，然后调用上文中的上溯函数调整即可。 &#x2F;&#x2F; push heap template&lt;typename _Iterator&gt; inline void push_heap_S(_Iterator _first, _Iterator _last) &#123; typedef typename iterator_traits&lt;_Iterator&gt;::value_type _ValueType; typedef typename iterator_traits&lt;_Iterator&gt;::difference_type _DistanceType; _ValueType _value &#x3D; _GLIBCXX_MOVE(*(_last - 1)); _push_heap_S(_first, _DistanceType(_last - _first - 1), _DistanceType(0), _value, __gnu_cxx::__ops::__iter_less_val()); &#125; template&lt;typename _Iterator, typename _Compare&gt; inline void push_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123; typedef typename iterator_traits&lt;_Iterator&gt;::value_type _ValueType; typedef typename iterator_traits&lt;_Iterator&gt;::difference_type _DistanceType; _ValueType _value &#x3D; _GLIBCXX_MOVE(*(_last - 1)); _push_heap_S(_first, _DistanceType(_last - _first - 1), _DistanceType(0), _value, __gnu_cxx::__ops::__iter_comp_val(_cp)); &#125; 删除是对 _adjust_heap_S() 函数的应用。 template&lt;typename _Iterator, typename _Compare&gt; inline void _pop_heap_S(_Iterator __first, _Iterator __last, _Iterator __res, _Compare __cp) &#123; typedef typename iterator_traits&lt;_Iterator&gt;::value_type _ValueType; typedef typename iterator_traits&lt;_Iterator&gt;::difference_type _DistanceType; _ValueType __value &#x3D; _GLIBCXX_MOVE(*__res); *__res &#x3D; _GLIBCXX_MOVE(*__first); _adjust_heap_S(__first, _DistanceType(0), _DistanceType(__last - __first), _GLIBCXX_MOVE(__value), __cp); &#125; &#x2F;&#x2F;pop heap template&lt;typename _Iterator&gt; inline void pop_heap_S(_Iterator _first, _Iterator _last) &#123; if(_last - _first &gt; 1)&#123; --_last; _pop_heap_S(_first, _last, _last, __gnu_cxx::__ops::__iter_less_iter()); &#125; &#125; template&lt;typename _Iterator, typename _Compare&gt; inline void pop_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123; if(_last - _first &gt; 1)&#123; --_last; _pop_heap_S(_first, _last, _last, __gnu_cxx::__ops::__iter_comp_iter(_cp)); &#125; &#125; 这里 __last自减后再计算 _DistanceType(last - first) ，相当于忽略最后一个元素（被换下来的根节点），从第一个元素（被换到根节点的叶节点）开始进行下溯操作。 4.最后是堆排序 template&lt;typename _Iterator, typename _Compare&gt; void _sort_heap_S(_Iterator __first, _Iterator __last, _Compare __cp) &#123; typedef typename iterator_traits&lt;_Iterator&gt;::value_type _ValueType; typedef typename iterator_traits&lt;_Iterator&gt;::difference_type _DistanceType; while(__last - __first &gt; 1)&#123; --__last; _pop_heap_S(__first, __last, __last, __cp); &#125; &#125; template&lt;typename _Iterator&gt; inline void sort_heap_S(_Iterator _first, _Iterator _last) &#123; _sort_heap_S(_first, _last, __gnu_cxx::__ops::__iter_less_iter()); &#125; template&lt;typename _Iterator, typename _Compare&gt; inline void sort_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123; _sort_heap_S(_first, _last, __gnu_cxx::__ops::__iter_comp_iter(_cp)); &#125; 堆排序在建堆完成之后就非常简单了，就是不断将堆顶元素弹出，加入到迭代器末端end()的过程。之后end()前移，继续在 [ begin(), end() ) 范围内完成pop操作直至范围内仅剩一个元素。 5.以上堆的方法函数设计好后，就可以通过它们定义一些利用堆特性的类了，例如优先队列。 template&lt;typename _Tp, typename _Sequence &#x3D; vector&lt;_Tp&gt;, typename _Compare &#x3D; less&lt;typename _Sequence::value_type&gt; &gt; class priority_queue_S&#123; public: typedef typename _Sequence::value_type value_type; typedef typename _Sequence::reference reference; typedef typename _Sequence::const_reference const_reference; typedef typename _Sequence::size_type size_type; typedef _Sequence container_type; public: _Sequence sq; _Compare cp; public: explicit priority_queue_S(const _Sequence&amp; _s, const _Compare&amp; _c) : sq(_s), cp(_c) &#123; make_heap_S(sq.begin(), sq.end(), cp); &#125; explicit priority_queue_S(const _Sequence&amp; _s &#x3D; _Sequence(), _Compare&amp;&amp; _c &#x3D; _Compare()) : sq(move(_s)), cp(_c) &#123; make_heap_S(sq.begin(), sq.end(), cp); &#125; bool empty() const &#123; return sq.empty(); &#125; size_type size() const &#123; return sq.size(); &#125; size_type depth() const &#123; return ceil(log2(this-&gt;size() + 1)); &#125; void clear() &#123; sq.clear(); &#125; const_reference top() const &#123; __glibcxx_requires_nonempty(); return sq.front(); &#125; void push(const value_type&amp; _x)&#123; sq.push_back(_x); push_heap_S(sq.begin(), sq.end(), cp); &#125; void push(value_type&amp;&amp; _x)&#123; sq.push_back(move(_x)); push_heap_S(sq.begin(), sq.end(), cp); &#125; template&lt;typename... _Args&gt; void emplace(_Args&amp;&amp;... _args)&#123; sq.emplace_back(forward&lt;_Args&gt;(_args)...); push_heap_S(sq.begin(), sq.end(), cp); &#125; void pop()&#123; __glibcxx_requires_nonempty(); pop_heap_S(sq.begin(), sq.end(), cp); sq.pop_back(); &#125; &#125;; 算法链表头插法ListNode* dummy &#x3D; new ListNode(); dummy-&gt;next &#x3D; new ListNode(val, dummy-&gt;next); 翻转链表 - O(n)双指针法1ListNode* reverseList(ListNode* head) &#123; ListNode* cur &#x3D; head; ListNode* pre &#x3D; NULL; while(cur) &#123; ListNode* temp &#x3D; cur-&gt;next; &#x2F;&#x2F; 保存cur的下一个节点 cur-&gt;next &#x3D; pre; pre &#x3D; cur; cur &#x3D; temp; &#125; return pre; &#125; 双指针法2ListNode* reverseList(ListNode* head) &#123; ListNode* dummy &#x3D; new ListNode(-1, head); ListNode* pre &#x3D; dummy, *cur &#x3D; head; while(cur) &#123; ListNode* temp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; temp-&gt;next; temp-&gt;next &#x3D; pre-&gt;next; pre-&gt;next &#x3D; temp; &#125; return pre; &#125; 环形链表判断bool hasCycle(ListNode *head) &#123; ListNode* slow &#x3D; head; ListNode* fast &#x3D; head; while(fast &amp;&amp; fast-&gt;next) &#123; fast &#x3D; fast-&gt;next-&gt;next; slow &#x3D; slow-&gt;next; if(fast &#x3D;&#x3D; slow) return true; &#125; return false; &#125; 找入口计算环长 ListNode* slow &#x3D; head; ListNode* fast &#x3D; head; int len &#x3D; 0; int count &#x3D; 0; while(fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; if(count) len++; if(slow &#x3D;&#x3D; fast)&#123; if(count) break; count++; &#125; &#125; 快指针先移动环长距离，之后一同移动，相同时即为入口。 中点切链ListNode* getMid(ListNode* cur) &#123; ListNode* slow &#x3D; cur; ListNode* fast &#x3D; cur; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; &#125; fast &#x3D; slow-&gt;next; slow-&gt;next &#x3D; nullptr; return fast; &#125; 合并有序链表ListNode* mergeList(ListNode* a, ListNode* b) &#123; ListNode* dummy &#x3D; new ListNode(); ListNode* cur &#x3D; dummy; while(a &amp;&amp; b) &#123; ListNode* &amp;tmp &#x3D; a-&gt;val &gt; b-&gt;val ? b : a; cur &#x3D; cur-&gt;next &#x3D; tmp; tmp &#x3D; tmp-&gt;next; &#125; cur-&gt;next &#x3D; a ? a : b; return dummy-&gt;next; &#125; 链表排序归并 ListNode* sortList(ListNode* head) &#123; if(head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return head; ListNode* mid &#x3D; getMid(head); return mergeList(sortList(head), sortList(mid)); &#125; 相交链表对于相交在尾部的两个链表，要找其交点，首先要让两个链表指针距交点的距离相同。只需计算两个链表的长度并求差值sub，那么长的链表先往前遍历sub个节点，此时两个指针距离交点的位置是一样的，只需在后续共同遍历时判断相等即可。 查找二分查找 - O(log(n))时间复杂度计算假使总共有 n 个元素，那么二分后每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。最坏的情况是K次二分之后，每个区间的大小为1，找到想要的元素，于是： 令n/2^k=1，可得k=log2n，得到时间复杂度 **O(log(n))**。 递归实现int binarySearch(vector&lt;int&gt;&amp; vec, int low, int high, int key) &#123; if(low &gt; high) return -1; int mid &#x3D; (low + high) &#x2F; 2; if(vec[mid] &#x3D;&#x3D; key) return mid; else if(vec[mid] &lt; key) binarySearch(vec, mid + 1, high, key); else binarySearch(vec, low, mid - 1, key); &#125; int main() &#123; vector&lt;int&gt; vec &#x3D; xxx; int key &#x3D; yyy; &#x2F;&#x2F; method 1 res &#x3D; binarySearch(vec, 0, vec.size() - 1, key); &#x2F;&#x2F;method 2 auto binarySearch &#x3D; [&amp;, circle &#x3D; [&amp;](auto&amp;&amp; self, int low, int high) -&gt; int &#123; if(low &gt; high) return -1; int mid &#x3D; (low + high) &#x2F; 2; if(vec[mid] &#x3D;&#x3D; key) return mid; else if(vec[mid] &lt; key) self(self, mid + 1, high); else self(self, low, mid - 1); &#125; ]() &#123; return circle(circle, 0, vec.size() - 1); &#125;; res &#x3D; binarySearch(); &#125; 迭代实现int binarySearch(vector&lt;int&gt;&amp; vec, int key) &#123; if(vec.size() &#x3D;&#x3D; 0) return -1; int low &#x3D; 0, high &#x3D; vec.size() - 1; while(low &lt;&#x3D; high) &#123; int mid &#x3D; (low + high) &#x2F; 2; if(vec[mid] &#x3D;&#x3D; key) return mid; else if(vec[mid] &lt; key) low &#x3D; mid + 1; else high &#x3D; mid - 1; &#125; return -1; &#125; 注意：以上代码中，均是 low &lt;= high， 这是建立在闭区间的情况下的。若是写成 low &lt; high，则双指针是在左闭右开的区间内实现的。 单调栈 - O(n)通常是在一维数组中，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。 单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。 单调栈只需要存放元素的下标。 单调栈需要明确在遍历时，vec[i] 与 vec[st.top()] 之间的三种大小关系的处理方式 Codevector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; vec) &#123; vector&lt;int&gt; res(vec.size()); stack&lt;int&gt; st; for(int i &#x3D; 0; i &lt; vec.size(); ++i) &#123; while(!st.empty() &amp;&amp; vec[i] &gt; vec[st.top()]) &#123; res[st.top()] &#x3D; i; st.pop(); &#125; st.push(i); &#125; return res; &#125; 排序 堆排序 - O(n*log(n))1.函数调用实现堆排序其实仅需两个步骤：建堆、排序（将堆顶元素依次下溯）。 承接上文中的STL写法，实现仅需调用两个对应的函数： vector&lt;int&gt; a &#x3D; &#123;33, 1, 44, 2, 999, 77&#125;; make_heap_S(a.begin(), a.end(), greater&lt;int&gt;()); sort_heap_S(a.begin(), a.end(), greater&lt;int&gt;()); 注意，make heap和sort heap操作，要求堆的比较方式是相同的才行，也就是说如果不使用默认比较方式（less），就需要在两个函数中均传入同一个比较仿函数。 再注意，sort_heap_S() 排序的容器内的元素必须为一个堆，在排序后，这些元素将不再组成一个堆。 2.简单数组实现void adjustHeap(vector&lt;int&gt;&amp; arr, int start, int end) &#123; int parent &#x3D; start; &#x2F;&#x2F; 这里选择左子节点，因为可能存在没有右子节点的情况 int child &#x3D; 2 * start + 1; while(child &lt;&#x3D; end)&#123; if(child+1 &lt;&#x3D; end &amp;&amp; arr[child] &lt; arr[child+1]) ++child; if(arr[child] &lt; arr[parent]) return; else&#123; swap(arr[child], arr[parent]); parent &#x3D; child; child &#x3D; 2 * parent + 1; &#125; &#125; &#125; void heapSort(vector&lt;int&gt;&amp; arr)&#123; int len &#x3D; arr.size(); &#x2F;&#x2F; 第一步：建堆 for(int i &#x3D; (len - 2) &#x2F; 2; i &gt;&#x3D; 0; --i) adjustHeap(arr, i, len - 1); &#x2F;&#x2F; 第二步：排序 for(int i &#x3D; len - 1; i &gt; 0; --i)&#123; swap(arr[i], arr[0]); adjustHeap(arr, 0, i - 1); &#125; &#125; 归并排序 - O(n*log(n))void merge(vector&lt;int&gt;&amp; arr, int l, int mid, int r) &#123; vector&lt;int&gt; tmp(r-l+1); int i &#x3D; l, j &#x3D; mid+1, k &#x3D; 0; while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) tmp[k++] &#x3D; arr[i] &lt;&#x3D; arr[j] ? arr[i++] : arr[j++]; while(i &lt;&#x3D; mid) tmp[k++] &#x3D; arr[i++]; while(j &lt;&#x3D; r) tmp[k++] &#x3D; arr[j++]; for(int&amp; n : tmp) arr[l++] &#x3D; n; &#125; void mergeSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123; if(l &lt; r) &#123; int mid &#x3D; l + (r - l) &#x2F; 2; &#x2F;&#x2F; 防止超出int范围 mergeSort(arr, l, mid); mergeSort(arr, mid+1, r); merge(arr, l, mid, r); &#125; &#125; 回溯回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 所有回溯法的问题都可以抽象为树形结构！ 因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。 模板函数void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); &#x2F;&#x2F; 递归 回溯，撤销处理结果 &#125; &#125; 时空复杂度子集问题分析： 时间复杂度：**O(n × 2 ^ n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)，构造每一组子集都需要填进数组，又有需要O(n)，最终时间复杂度：O(n × 2^n)**。 空间复杂度：**O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)**。 排列问题分析： 时间复杂度：**O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ….. 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：res.push_back(path)），该操作的复杂度为O(n)。所以，最终时间复杂度为：n * n!，简化为O(n!)**。 空间复杂度：**O(n)**，和子集问题同理。 组合问题分析： 时间复杂度：**O(n × 2^n)**，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。 空间复杂度：**O(n)**，和子集问题同理。 贪心手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。 贪心算法一般分为如下四步： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 动态规划 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 背包问题 01背包例：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 按照动态规划五部曲进行分析： 确定dp数组以及下标的含义（后续一切均以dp的含义为基础进行推理） dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 确定递推公式 有两个方向推出来dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]) 不放物品i：即 **dp[i - 1] [j]**。背包容量为 j ，里面不放物品 i 的最大价值，就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。) 放物品i：由 dp[i - 1] [j - weight[i]] 推出，dp[i - 1] [j - weight[i]] 为背包容量为 j - weight[i] 的时候不放物品 i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 dp初始化 如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。 状态转移方程可以看出 i 是由 i - 1 推导出来，那么 i 为0的时候就一定要初始化。 vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0)); for (int j &#x3D; weight[0]; j &lt;&#x3D; bagweight; j++) dp[0][j] &#x3D; value[0]; 确立遍历顺序 先遍历物品，然后遍历背包重量（均为正序） 01背包 - 滚动数组对于上述的二维dp数组，也是可以优化为一维的，类似于之前的动态规划数组一样。 可以发现在递推公式中，如果把 **dp[i - 1]**那一层拷贝到 **dp[i]上，表达式即为：dp[i] [j] = max(dp[i] [j], dp[i] [j - weight[i]] + value[i])**。这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 于是可以得到滚动数组的通用模板如下： 先遍历物品（正序），然后遍历背包重量（反序） vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i &#x3D; 0; i &lt; weight.size(); i++) &#123; &#x2F;&#x2F; 遍历物品 for(int j &#x3D; bagWeight; j &gt;&#x3D; weight[i]; j--) &#123; &#x2F;&#x2F; 遍历背包容量 dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; 关于遍历顺序： 在01背包一维数组的遍历中，一定是外层物品（正序）内层容量（反序）。因为滚动数组在本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角（因此外层为遍历物品，内层容量反序）的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。 完全背包相当于01背包的变种。物品由取用1次变为了无数次。 因此上文中提到的遍历顺序，在完全背包中为：内外层可以互换，均为正序遍历，注意判断下标是否越界。 for(int j &#x3D; 0; j &lt;&#x3D; bagWeight; j++) &#123; &#x2F;&#x2F; 遍历背包容量 for(int i &#x3D; 0; i &lt; weight.size(); i++) &#123; &#x2F;&#x2F; 遍历物品 if (j - weight[i] &gt;&#x3D; 0) dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; 组合 在完全背包的组合问题中，采用 += 的累加计算方式替换 max 等比较函数。 同时注意遍历顺序：一定是外层物品，内层容量，均正序。 说明举例：给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 nums = [1, 2, 3] target = 4 计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面。这就避免了同一组合多种排列导致重复的情况。 排列 在完全背包的排列问题中，同样采用 += 的计算方式。 同时注意遍历顺序：一定是外层容量，内层物品，均正序。 证明见组合的说明举例。 多重背包实际是一个01背包问题：每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。 void multi_pack() &#123; vector&lt;int&gt; weight &#x3D; &#123;1, 3, 4&#125;; vector&lt;int&gt; value &#x3D; &#123;15, 20, 30&#125;; vector&lt;int&gt; nums &#x3D; &#123;2, 3, 2&#125;; int bagWeight &#x3D; 10; for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123; while (nums[i] &gt; 1) &#123; &#x2F;&#x2F; nums[i]保留到1，把其他物品都展开 weight.push_back(weight[i]); value.push_back(value[i]); nums[i]--; &#125; &#125; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i &#x3D; 0; i &lt; weight.size(); i++) &#x2F;&#x2F; 遍历物品 for(int j &#x3D; bagWeight; j &gt;&#x3D; weight[i]; j--) &#x2F;&#x2F; 遍历背包容量 dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); &#125; 或是在遍历01背包时，将每个物品种类都再遍历一遍： void test_multi_pack() &#123; vector&lt;int&gt; weight &#x3D; &#123;1, 3, 4&#125;; vector&lt;int&gt; value &#x3D; &#123;15, 20, 30&#125;; vector&lt;int&gt; nums &#x3D; &#123;2, 3, 2&#125;; int bagWeight &#x3D; 10; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i &#x3D; 0; i &lt; weight.size(); i++) &#x2F;&#x2F; 遍历物品 for(int j &#x3D; bagWeight; j &gt;&#x3D; weight[i]; j--) &#x2F;&#x2F; 遍历背包容量 &#x2F;&#x2F; 以上为01背包，然后加一个遍历个数 for (int k &#x3D; 1; k &lt;&#x3D; nums[i] &amp;&amp; (j - k * weight[i]) &gt;&#x3D; 0; k++) &#x2F;&#x2F; 遍历个数 dp[j] &#x3D; max(dp[j], dp[j - k * weight[i]] + k * value[i]); &#125; 总结 股票问题 可以发现，只有在限制最多买卖次数时，需要设立多状态：即第 i 天买卖 0 ~ k - 1次各自的状态。 其余均是双状态：持有、不持有。 字符串问题最长公共子序列LCS定义 dp[i] [j] 为考虑 s 中前 i 个字符，t 中前 j 个字符的LCS长度。对于 dp[i] [j] ，包含两类决策： s[i] = t[j]，此时必然会使用 s[i] 和 t[j] ，所以dp[i] [j] = dp[i-1] [j-1] + 1。 s[i] ≠ t[j]，此时有两种情况：必然不使用 s[i] （可能使用 t[j]）和 必然不使用 t[j]（可能使用 s[i]）时的LCS长度。于是可得 dp[i] [j] = max(dp[i-1] [j], dp[i] [j - 1]) 。 在上述两种决策中，已经包含了 「不使用 s[i] 和 t[j]」、「仅使用 s[i] 」、「**仅使用 t[j]」和「使用 s[i] 和 t[j]**」四种情况。其中第一种情况是被2、3两种情况重复包含了，但对于求最值，重复比较并不想影响答案正确性。 字符串匹配对于两个字符串匹配，一个非常通用的状态定义如下： 定义 dp[i] [j] 为考虑 s 中 [0，i] 个字符，t 中 [0，j] 个字符的匹配个数。那么显然对于某个 dp[i] [j] 而言，从「最后一步」的匹配进行分析，包含两类决策： s[i] 不参与匹配，需要让 s 中 [0，i-1] 个字符去匹配 t 中的 [0，j] 字符。此时匹配值为 dp[i-1] [j] s[i] 参与匹配，这时只需让 s 中 [0，i-1] 个字符去匹配 t 中的 [0，j-1] 字符即可，同时满足 s[i] = t[j]。此时匹配值为 dp[i-1] [j-1] 显然，当出现 s[i] = t[j]时，dp值为以上两者之和，若不相等，则仅满足 s[i] 不参与匹配的情况。 树形DPTODO 图论无向图无向图求最短路径，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径。 并查集并查集常用来解决连通性问题。当我们需要判断两个元素是否在同一个集合里的时候，就要想到用并查集。 并查集主要有两个功能： 判断两个元素在不在同一个集合。 将两个元素添加到一个集合中。 原理思考如何将两个元素添加到同一个集合中？ 可以尝试把他放到同一个数组、set 或 map 中，这样就表述两个元素在同一个集合。但存在问题：可能有很多集合，那么要定义这么多个数组吗？ 可以尝试定义一个二维数组。但存在问题：判断两个元素是否在同一个集合里时、添加一个元素到某集合时，都只能遍历一遍二维数组。这仅仅是一个粗略的思路，如果沿着这个思路去实现代码，非常复杂，因为管理集合还需要很多逻辑。那如何处理比较灵活呢？ 解决方案我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，如何连通呢。 只需用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。 初始化int n &#x3D; 1005; &#x2F;&#x2F; n根据节点数量而定 vector&lt;int&gt; father &#x3D; vector&lt;int&gt; (n, 0); &#x2F;&#x2F; 并查集初始化 void init() &#123; for (int i &#x3D; 0; i &lt; n; ++i) father[i] &#x3D; i; &#125; 寻根只要 A ，B，C 在同一个根下就是同一个集合。 给出A元素，就可以通过 father[A] = B，father[B] = C，找到根为 C。 给出B元素，就可以通过 father[B] = C，找到根也为为 C，说明 A 和 B 是在同一个集合里。 给出C元素，father[C] = C，这样就方便表示 A，B，C 都在同一个集合里。所以数组初始化的时候要 father[i] = i，默认自己指向自己。 int find(int u) &#123; if (u &#x3D;&#x3D; father[u]) return u; &#x2F;&#x2F; 如果根就是自己，直接返回 else return find(father[u]); &#x2F;&#x2F; 如果根不是自己，就根据数组下标一层一层向下找 &#125; 路径压缩如上代码所示，搜索过程像是一个多叉树中从叶子到根节点的过程。如果这棵多叉树高度很深的话，每次find函数去寻找根的过程就要递归很多次。而我们的目的只需要知道这些节点在同一个根下。 通过 路径压缩，将非根节点的所有节点直接指向根节点。这样我们在寻根的时候就很快，只需要一步。 实现：在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。 int find(int u) &#123; return u &#x3D;&#x3D; father[u] ? u : father[u] &#x3D; find(father[u]); &#125; 元素是否在同一集合即判断是否有相同的根。 bool isSame(int u, int v) &#123; u &#x3D; find(u); v &#x3D; find(v); return u &#x3D;&#x3D; v; &#125; 元素加入集合一定要先通过find函数寻根后，再进行关联，才能保证元素在这个有向图里是强连通。关联的是根元素。 void join(int u, int v) &#123; u &#x3D; find(u); &#x2F;&#x2F; 寻找u的根 v &#x3D; find(v); &#x2F;&#x2F; 寻找v的根 if (u &#x3D;&#x3D; v) return ; &#x2F;&#x2F; 若根相同，则说明在一个集合，直接返回 father[v] &#x3D; u; &#x2F;&#x2F; 将两个元素的根关联 &#125; 过程模拟join(1, 8); join(3, 8); join(1, 7); join(8, 5); join(6, 2); join(2, 9); 按秩合并rank表示树的高度，即树中结点层次的最大值。例如两个集合（多叉树）需要合并，如图所示： 如下图可见，树2 合入 树1 会导致整棵树的高度变的更高，而 树1 合入 树2 整棵树的高度 和 树2 保持一致。 一定是 rank 小的树合入 到 rank大 的树，这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。 实现初始化 vector&lt;int&gt; rank &#x3D; vector&lt;int&gt; (n, 1); &#x2F;&#x2F; 初始化为1 压缩 操作不再在find函数中，而是放在添加元素时。 void join(int u, int v) &#123; u &#x3D; find(u); &#x2F;&#x2F; 寻找u的根 v &#x3D; find(v); &#x2F;&#x2F; 寻找v的根 &#x2F;&#x2F; rank小的树合入到rank大的树 rank[u] &lt;&#x3D; rank[v] ? father[u] &#x3D; v : father[v] &#x3D; u; &#x2F;&#x2F; 依据上一行的判断&lt;&#x3D;，如果两棵树高度相同，则 v 的高度 + 1 if (rank[u] &#x3D;&#x3D; rank[v] &amp;&amp; u !&#x3D; v) rank[v]++; &#125; 效率相比路径压缩较低，不常用。 时空复杂度时间在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是O(logn)，但路径压缩后，后面的查询操作都是O(1)。 因此，路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。 空间O(n) ，申请一个father数组。","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"}]},{"title":"LeetCode--2023Q2","slug":"LeetCode--2023Q2","date":"2023-04-01T02:32:55.000Z","updated":"2023-08-03T07:07:45.596Z","comments":true,"path":"原理/LeetCode--2023Q2/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/","excerpt":"打卡4月LeetCode2023.4.1831.隐藏个人信息解法基本思路：模拟？ 这也算算法题。。吗？ 代码class Solution &#123; public: string maskPII(string s) &#123; if(s[0] &gt;&#x3D; &#39;A&#39;)&#123; int split &#x3D; s.find(&#39;@&#39;); for(int i &#x3D; split + 1; i &lt; s.length(); ++i)&#123; if(s[i] &lt;&#x3D; &#39;Z&#39; &amp;&amp; s[i] &gt;&#x3D; &#39;A&#39;) s[i] +&#x3D; 32; &#125; if(s[0] &lt;&#x3D; &#39;Z&#39;) s[0] +&#x3D; 32; if(s[split - 1] &lt;&#x3D; &#39;Z&#39;) s[split - 1] +&#x3D; 32; s.replace(1, split - 2, &quot;*****&quot;); &#125; else&#123; for(string::iterator i &#x3D; s.begin(); i &lt; s.end(); ++i)&#123; if(*i &lt; &#39;0&#39;) s.erase(i--); &#125; int len &#x3D; s.length(); if(len &#x3D;&#x3D; 10) return &quot;***-***-&quot; + s.substr(6, 4); else if(len &#x3D;&#x3D; 11) return &quot;+*-***-***-&quot; + s.substr(7, 4); else if(len &#x3D;&#x3D; 12) return &quot;+**-***-***-&quot; + s.substr(8, 4); else if(len &#x3D;&#x3D; 13) return &quot;+***-***-***-&quot; + s.substr(9, 4); &#125; return s; &#125; &#125;;","text":"打卡4月LeetCode2023.4.1831.隐藏个人信息解法基本思路：模拟？ 这也算算法题。。吗？ 代码class Solution &#123; public: string maskPII(string s) &#123; if(s[0] &gt;&#x3D; &#39;A&#39;)&#123; int split &#x3D; s.find(&#39;@&#39;); for(int i &#x3D; split + 1; i &lt; s.length(); ++i)&#123; if(s[i] &lt;&#x3D; &#39;Z&#39; &amp;&amp; s[i] &gt;&#x3D; &#39;A&#39;) s[i] +&#x3D; 32; &#125; if(s[0] &lt;&#x3D; &#39;Z&#39;) s[0] +&#x3D; 32; if(s[split - 1] &lt;&#x3D; &#39;Z&#39;) s[split - 1] +&#x3D; 32; s.replace(1, split - 2, &quot;*****&quot;); &#125; else&#123; for(string::iterator i &#x3D; s.begin(); i &lt; s.end(); ++i)&#123; if(*i &lt; &#39;0&#39;) s.erase(i--); &#125; int len &#x3D; s.length(); if(len &#x3D;&#x3D; 10) return &quot;***-***-&quot; + s.substr(6, 4); else if(len &#x3D;&#x3D; 11) return &quot;+*-***-***-&quot; + s.substr(7, 4); else if(len &#x3D;&#x3D; 12) return &quot;+**-***-***-&quot; + s.substr(8, 4); else if(len &#x3D;&#x3D; 13) return &quot;+***-***-***-&quot; + s.substr(9, 4); &#125; return s; &#125; &#125;; 54.螺旋矩阵、剑指 Offer 29. 顺时针打印矩阵题干给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 示例 1： 输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 解法基本思路：模拟过程 相比于 59.螺旋矩阵Ⅱ ，这题的长宽不一定相同，因此不再适用按圈缩减的方法。 维护上、下、左、右四个边界的下标。 第一次移动，从左到右移动一整行，移动后直接将1~4从上图中抹掉，变成了一个 4 x 2 的矩阵。如何抹掉？维护的上边界加一即可。因为循环都是统一从一个边界到另一个边界的。 第二次移动，从上到下，移动后抹去8、12，相当于右边界减一。这样下一次移动中从右到左时从右边界开始就是从11开始的，顺序不会错乱。 第三从右往左，第四次从下往上，四次组成一次大循环。 每当有两个对应边界错位（左 &gt; 右，上 &gt; 下）时，就直接结束了。例如当仅剩一行时，上下边界重合，抹去这行时，无论up++还是down–，都会出现错位，以此为结束的判断依据。 思路清晰，逻辑明了。 代码class Solution &#123; public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; int up &#x3D; 0, left &#x3D; 0; int down &#x3D; matrix.size() - 1, right &#x3D; matrix[0].size() - 1; while(1)&#123; for(int i &#x3D; left; i &lt;&#x3D; right; ++i) res.push_back(matrix[up][i]); if(++up &gt; down) break; for(int i &#x3D; up; i &lt;&#x3D; down; ++i) res.push_back(matrix[i][right]); if(--right &lt; left) break; for(int i &#x3D; right; i &gt;&#x3D; left; --i) res.push_back(matrix[down][i]); if(--down &lt; up) break; for(int i &#x3D; down; i &gt;&#x3D; up; --i) res.push_back(matrix[i][left]); if(++left &gt; right) break; &#125; return res; &#125; &#125;; 11.盛最多水的容器题干给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。 示例 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 示例 2： 输入：height &#x3D; [1,1] 输出：1 解法基本思路：双指针 代码很简单，这题主要在于思路上：为什么双指针按代码所示方法往中间移动时不会漏掉某种情况呢？ 容量和两个因素有关：双指针的距离、双指针中短的那个的高度。 开始双指针在两端，距离是最大的，此时移动指针若想要让容量更大，就必须提高双指针中短的那个的高度，也就是把短的指针往中间移动找找有没有更高的位置。这样移动下来就不存在漏掉某种最大的情况了。 代码class Solution &#123; public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int n &#x3D; height.size()， res &#x3D; 0; int l &#x3D; 0, r &#x3D; n - 1; while(l &lt; r)&#123; int area &#x3D; min(height[l], height[r]) * (r - l); res &#x3D; max(res, area); if(height[l] &lt; height[r]) l++; else r--; &#125; return res; &#125; &#125;; 2023.4.31053.交换一次的先前排列题干给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。 如果无法这么操作，就请返回原数组。 示例 示例 1： 输入：arr &#x3D; [3,2,1] 输出：[3,1,2] 示例 2： 输入：arr &#x3D; [1,9,4,6,7] 输出：[1,7,4,6,9] 解法基本思路：贪心 对于数组中的两元素下标 i 、j 且 i &lt; j**，若交换 arr[i] 和 arr[j] 得到的新数组按字典序排列比原数组小，显然有**arr[i] &gt; arr[j] 。因此符合题意要求的交换会使得数组 arr[i] 在下标 i 处的元素变小。那么为了得到按字典序排列小于原数组的最大新数组，尽可能地保持前面的元素不变是这一步的最优解，即让 i 最大化。 也就是说，从右往左遍历，找到的第一个arr[i] &gt; arr[i + 1] 处，就是需要被交换的 i 。 显然，找到 i 后，j 需要在 i 右半边去找。在满足 arr[i] &gt; arr[j] 的情况下，取最大的 arr[j] 是这一步的最优解，但需要注意元素可能存在重复的情况需要排除，此时把大的值换到相同数字的最左边，在小于原序列的状态下得到的序列是更大的，因此取最大的、j 尽量小的 arr[j] 为最优解。 代码class Solution &#123; public: vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; arr) &#123; for(int i &#x3D; arr.size() - 2; i &gt;&#x3D; 0; --i)&#123; if(arr[i] &gt; arr[i + 1])&#123; for(int j &#x3D; arr.size() - 1; j &gt; i; --j)&#123; if(arr[j] &lt; arr[i] &amp;&amp; arr[j] !&#x3D; arr[j - 1])&#123; swap(arr[j], arr[i]); return arr; &#125; &#125; &#125; &#125; return arr; &#125; &#125;; 31.下一个排列题干整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。必须 原地 修改，只允许使用额外常数空间。 示例 示例 1： 输入：nums &#x3D; [1,2,3] 输出：[1,3,2] 示例 2： 输入：nums &#x3D; [3,2,1] 输出：[1,2,3] 解法基本思路：贪心？、双指针？ 这题和今天的每日一题是相同原理，是找大于原序列的最小字典序。 对于数组中的一部分，若完全的降序排列（不存在 arr[i] &lt; arr[i+1]** 的情况），则这段子序列是最大的。那么最优解就是从右往左找到第一个 **arr[i] &gt; arr[i+1] 处，就是从尾部开始的最大子序列长度再加一，i 即是要交换的位置。 显然，找到 i 后，j 需要在 i 右半边去找。在满足 arr[i] &lt; arr[j] 的情况下，取最小的 arr[j] 是这一步的最优解，此题不需要考虑元素重复的情况，因为换哪个都一样。 交换完成后，由于 i 增大了，要找大于原序列的最小字典序，右侧的子序列自然是要最小的，因此升序排列即可。 若找不到这样的 i ，说明原序列就是最大字典序，直接把整个数组升序排列即可。 代码class Solution &#123; public: void nextPermutation(vector&lt;int&gt;&amp; nums)&#123; for(int i &#x3D; nums.size() - 2; i &gt;&#x3D; 0; --i)&#123; if(nums[i] &lt; nums[i+1])&#123; for(int j &#x3D; nums.size() - 1; j &gt; i; --j)&#123; if(nums[j] &gt; nums[i])&#123; swap(nums[j], nums[i]); sort(nums.begin()+i+1,nums.end()); return; &#125; &#125; &#125; &#125; sort(nums.begin(),nums.end()); &#125; &#125;; 2023.4.446.全排列题干给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 示例 1： 输入：nums &#x3D; [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 输入：nums &#x3D; [1] 输出：[[1]] 解法基本思路：回溯、DFS 实际就是一个排列组合问题，每一个数字都要放到最前面，而对剩下的数字里同样是每个数字都要被放在最前（第二个）。。以此类推。这就是分布解决问题的过程。 回溯法采用的是试错思想：当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。这通常是使用递归来实现的。 而本题中不需要判断分步答案是否正确，只需记录所有分布答案即可。 回溯与动态规划的异同： 1.共同点 用于求解多阶段决策问题。即：求解一个问题分为很多步骤（阶段）；每一个步骤（阶段）可以有多种选择。 2.不同点 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果； 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。 对于该题，示例1： 深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」 代码class Solution &#123; public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start &#x3D;&#x3D; end)&#123; res.push_back(nums); return; &#125; for(int i &#x3D; start; i &lt; end; ++i)&#123; swap(nums[start], nums[i]); dfs(res, nums, start + 1, end); swap(nums[start], nums[i]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; dfs(res, nums, 0, nums.size()); return res; &#125; &#125;; 2023.4.52427.公因子的数目解法基本思路：暴力 公因子的最大值就是最大公约数，因此先求最大公约数（库函数 __gcd ），再从1开始循环判断。 代码class Solution &#123; public: int commonFactors(int a, int b) &#123; int divisor &#x3D; __gcd(a, b); int res &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; divisor; ++i) if(a % i &#x3D;&#x3D; 0 &amp;&amp; b % i &#x3D;&#x3D; 0) res++; return res; &#125; &#125;; 2023.4.61017.负二进制转换题干给你一个整数 n ，以二进制字符串的形式返回该整数的 负二进制（base -2）表示。 注意，除非字符串就是 &quot;0&quot;，否则返回的字符串中不能含有前导零。 示例 示例 1： 输入：n &#x3D; 2 输出：&quot;110&quot; 解释：(-2)2 + (-2)1 &#x3D; 2 示例 2： 输入：n &#x3D; 3 输出：&quot;111&quot; 解释：(-2)2 + (-2)1 + (-2)0 &#x3D; 3 解法基本思路：模拟、数学 本题主要用到了十进制转n进制的方法：除n取余，逆序排列。代码模拟了这个过程。 注意：因为填入的结果只有0、1，而余数可能为 -1，可以通过商+1重新计算余数，不影响结果。 代码class Solution &#123; public: string baseNeg2(int n) &#123; if(n &#x3D;&#x3D; 0) return &quot;0&quot;; string res &#x3D; &quot;&quot;; while(n)&#123; int quotient &#x3D; n &#x2F; -2; int remainder &#x3D; n - quotient * -2; if(remainder &lt; 0) remainder &#x3D; n - ++quotient * -2; res +&#x3D; to_string(remainder); n &#x3D; quotient; &#125; return string(res.rbegin(), res.rend()); &#125; &#125;; 47.全排列Ⅱ题干给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 示例 1： 输入：nums &#x3D; [1,1,2] 输出：[[1,1,2],[1,2,1],[2,1,1]] 示例 2： 输入：nums &#x3D; [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 解法基本思路：回溯、DFS 相比于46.全排列，这题在输入数组中存在重复数字，这意味着按照之前的方法会导致重复数字被使用导致排列相同的情况。因此需要判断和剪枝。 首先，要先找到重复数字是哪些，最方便的方法就是先对原数组进行排序，那么是否重复只需和上一个数字比较即可。 其次，因为排序，不能直接在原数组上操作了，需要新开一个数组存储每次排列的结果，通过push和pop来实现状态重置。 接着，就需要找到要被剪枝的部分的判断条件—— 以本题的示例1来说： 可以发现，对于一个重复数字，如果它的上一个相同数字已经被使用了（添加进了数组中），那么该数字是不影响接下来的使用的，因为是添加到上一个数字后面的。而对于未被使用（不在结果数组中）的相同数字，就会导致结果重复。1、1、2中选1和选1，剩下的都是1、2，那么结果也都是一样的，因此可以得到跳过的条件： 遍历到的数字和上一个相同（重复了）且上一个数字未被使用。使用一个数组进行记录使用情况，在递归前后改变状态完成状态重置。 注意： i - 1 越界问题，要加上 i &gt; 0; 由于原数组被排序了，也无法得知上一个被push进数组的是哪个，因此for循环需要全部遍历一遍，对于已经被push的（状态数组为true，直接跳过即可）。 idx用于统计结果数组中已push的数字数量，满了就存储一个结果并开始状态重置。 代码class Solution &#123; public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; sub, vector&lt;bool&gt;&amp; used, vector&lt;int&gt;&amp; nums, int idx)&#123; if(idx &#x3D;&#x3D; nums.size())&#123; res.push_back(sub); return; &#125; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1] &amp;&amp; !used[i-1]) continue; sub.push_back(nums[i]); used[i] &#x3D; true; dfs(res, sub, used, nums, idx + 1); used[i] &#x3D; false; sub.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sub; vector&lt;bool&gt; used(nums.size()); sort(nums.begin(), nums.end()); dfs(res, sub, used, nums, 0); return res; &#125; &#125;; 56.合并区间题干以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 示例 1： 输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 示例 2： 输入：intervals &#x3D; [[1,4],[0,4]] 输出：[[0,4]] 解法基本思路：双指针？ 先对二维数组排序，sort默认按第一列升序排，不需要自定义比较函数（自定义的比较函数会让排序慢上很多，其中单写函数比lambda函数要快一些）。排完序后需要合并的区间必然是连续的。 双指针（这里用了一个大小为2的vector便于存储），只需要判断左区间和上一个的右区间即可。 左区间大，不用合并，则直接将当前区间加入结果，双指针替换为当前区间的左右边界； 左区间小，再判断右区间和上一个的右区间，只有当前右区间更大的时候需要替换右边界的值。 结束循环后，若最后一个区间需要合并，则值已经更新在双指针sub中；若不需要合并，则sub也已经替换为了该区间。仅需将sub再加入结果中即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sub &#x3D; intervals[0]; for(int i &#x3D; 1; i &lt; intervals.size(); ++i)&#123; if(intervals[i][0] &lt;&#x3D; sub[1])&#123; if(intervals[i][1] &gt; sub[1]) sub[1] &#x3D; intervals[i][1]; &#125; else&#123; res.push_back(sub); sub &#x3D; intervals[i]; &#125; &#125; res.push_back(sub); return res;56 &#125; &#125;; 57.插入区间题干给你一个 无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 示例 1： 输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8] 输出：[[1,2],[3,10],[12,16]] 解法基本思路：模拟 遍历一遍，每个元素判断以下三种状态： 完全在插入区间左边，直接push 与插入区间有重叠，求他们的并集，更新插入区间的左右边界。 完全在插入区间右侧，需要判断插入区间是否push了，没push就push一下，然后push本次元素。 如果遍历完都没有push过，那么最后push插入区间。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; bool merged &#x3D; false; vector&lt;vector&lt;int&gt;&gt; res; for (auto&amp; range: intervals) &#123; if (range[1] &lt; newInterval[0]) res.push_back(range); else if (range[0] &gt; newInterval[1]) &#123; if (!merged) &#123; res.push_back(newInterval); merged &#x3D; true; &#125; res.push_back(range); &#125; else &#123; newInterval[0] &#x3D; min(newInterval[0], range[0]); newInterval[1] &#x3D; max(newInterval[1], range[1]); &#125; &#125; if (!merged) &#123; res.push_back(newInterval); &#125; return res; &#125; &#125;; 73.矩阵置0题干给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 你能想出一个仅使用常量空间的解决方案吗？ 示例 示例 1： 输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]] 输出：[[1,0,1],[0,0,0],[1,0,1]] 示例 2： 输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]] 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]] 解法基本思路：模拟 仅用常数空间，那只能利用原数组进行操作，也就是挑一行和一列记录该行/列是否有0。于是问题转化为了如何记录这一行一列本身是否有0？ 思考过程中发现，第一行是最先遍历的话，就能先知道这一行是否有0，那么这一行的值就不重要了，可以用来存储。那么对于列来说，如果是行内遍历列的话（for循环行在外面），只需要维护一个标志位，每次行内遍历时先判断的是第一列，如果是0，标志位置位，就知道了第一列是否有0。这样第一列的值也不重要了（判断过了），也可以用来存储了。 最后按照第一行和第一列的记录情况把对应行列置0。注意跟上述过程相反，为了将记录信息保存到最后，从右下角开始遍历，先向左（到第一列时，这个位置的记录就不需要了。根据标志位对第一列单独置0）再向上。 代码class Solution &#123; public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; bool col0 &#x3D; false; int row &#x3D; matrix.size(); int col &#x3D; matrix[0].size(); for(int i &#x3D; 0; i &lt; row; ++i)&#123; if(matrix[i][0] &#x3D;&#x3D; 0) col0 &#x3D; true; for(int j &#x3D; 1; j &lt; col; ++j)&#123; if(matrix[i][j] &#x3D;&#x3D; 0)&#123; matrix[i][0] &#x3D; 0; matrix[0][j] &#x3D; 0; &#125; &#125; &#125; for(int i &#x3D; row - 1; i &gt;&#x3D; 0; --i)&#123; for(int j &#x3D; col - 1; j &gt;&#x3D; 1; --j) if(matrix[i][0] &#x3D;&#x3D; 0 || matrix[0][j] &#x3D;&#x3D; 0) matrix[i][j] &#x3D; 0; if(col0) matrix[i][0] &#x3D; 0; &#125; &#125; &#125;; 2023.4.8203.移除链表元素解法基本思路：链表的删除 注意： 创建的链表指针temp是new的，需要用delete手动释放；而tmp指向的是要删除的链表元素，因此也需要delete。 cur指针不是new或malloc分配了空间的，系统会自动释放内存。 free是C的API，适用于malloc和calloc；delete是C++的关键字，主要用于释放new分配的内存，也可用于malloc和calloc。 代码class Solution &#123; public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode* temp &#x3D; new ListNode(0, head); ListNode* cur &#x3D; temp; while(cur-&gt;next)&#123; if(cur-&gt;next-&gt;val &#x3D;&#x3D; val)&#123; ListNode* tmp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; cur-&gt;next-&gt;next; delete tmp; &#125; else cur &#x3D; cur-&gt;next; &#125; head &#x3D; temp-&gt;next; delete temp; return head; &#125; &#125;; 707.设计链表题干你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 示例 示例 1： 输入： [&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;] [[], [1], [3], [1, 2], [1], [1], [1]] 输出：[null, null, null, null, 2, null, 3] 解法基本思路：链表的增删查 代码class MyLinkedList &#123; public: MyLinkedList() &#123; dummy &#x3D; new ListNode(0); length &#x3D; 0; &#125; int get(int index) &#123; if(index &gt;&#x3D; length || index &lt; 0) return -1; ListNode* cur &#x3D; dummy-&gt;next; while(index--) cur &#x3D; cur-&gt;next; return cur-&gt;val; &#125; void addAtHead(int val) &#123; ListNode* newNode &#x3D; new ListNode(val); newNode-&gt;next &#x3D; dummy-&gt;next; dummy-&gt;next &#x3D; newNode; length++; &#125; void addAtTail(int val) &#123; ListNode* newNode &#x3D; new ListNode(val); ListNode* cur &#x3D; dummy; while(cur-&gt;next) cur &#x3D; cur-&gt;next; cur-&gt;next &#x3D; newNode; length++; &#125; void addAtIndex(int index, int val) &#123; if(index &gt; length || index &lt; 0) return; ListNode* newNode &#x3D; new ListNode(val); ListNode* cur &#x3D; dummy; while(index--) cur &#x3D; cur-&gt;next; newNode-&gt;next &#x3D; cur-&gt;next; cur-&gt;next &#x3D; newNode; length++; &#125; void deleteAtIndex(int index) &#123; if(index &gt;&#x3D; length || index &lt; 0) return; ListNode* cur &#x3D; dummy; while(index--) cur &#x3D; cur-&gt;next; ListNode* tmp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; cur-&gt;next-&gt;next; delete tmp; length--; &#125; private: ListNode* dummy; int length; &#125;; 206.反转链表解法基本思路：双指针 代码class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; ListNode* tmp; ListNode* slow &#x3D; nullptr; ListNode* fast &#x3D; head; while(fast)&#123; tmp &#x3D; fast-&gt;next; fast-&gt;next &#x3D; slow; slow &#x3D; fast; fast &#x3D; tmp; &#125; return slow; &#125; &#125;; 优化基本思路：虚拟头节点、头插法 建立一个新链表的虚拟头节点，指向nullptr。遍历原链表元素，依次插入到虚拟节点后。 速度比双指针快一些。 class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; ListNode* dummy &#x3D; new ListNode(0); ListNode* cur &#x3D; head; while(cur)&#123; ListNode* tmp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; dummy-&gt;next; dummy-&gt;next &#x3D; cur; cur &#x3D; tmp; &#125; cur &#x3D; dummy-&gt;next; delete dummy; return cur; &#125; &#125;; 24.两两交换链表中的节点题干给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 示例 1： 输入：head &#x3D; [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head &#x3D; [1] 输出：[1] 解法基本思路：模拟 代码class Solution &#123; public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy &#x3D; new ListNode(0, head); ListNode* cur &#x3D; dummy; while(cur-&gt;next !&#x3D; nullptr &amp;&amp; cur-&gt;next-&gt;next !&#x3D; nullptr)&#123; ListNode* tmp &#x3D; cur-&gt;next; ListNode* tmp2 &#x3D; cur-&gt;next-&gt;next-&gt;next; cur-&gt;next &#x3D; cur-&gt;next-&gt;next; cur-&gt;next-&gt;next &#x3D; tmp; cur-&gt;next-&gt;next-&gt;next &#x3D; tmp2; cur &#x3D; cur-&gt;next-&gt;next; &#125; cur &#x3D; dummy-&gt;next; delete dummy; return cur; &#125; &#125;; 2023.4.92399.检查相同字母间的距离解法基本思路：哈希表 遍历，如果这个字符是第一次扫到（用哈希表存储判断），就判断与该下标+对应distance+1处的字符（注意越界）是否相同，任何一次不同就返回false。 代码class Solution &#123; public: bool checkDistances(string s, vector&lt;int&gt;&amp; distance) &#123; unordered_set&lt;char&gt; hash; for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; if(!hash.count(s[i]))&#123; hash.emplace(s[i]); int idx &#x3D; i + distance[s[i] - &#39;a&#39;] + 1; if(idx &gt;&#x3D; s.length()) return false; if(s[i] !&#x3D; s[idx]) return false; &#125; &#125; return true; &#125; &#125;; 24.两两交换链表中的节点题干给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 示例 1： 输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1] 示例 2： 输入：head &#x3D; [1], n &#x3D; 1 输出：[] 示例 3： 输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5] 解法基本思路：双指针、链表删除 双指针的间距为 n - 1。当快指针到末尾元素时，慢指针的下一个元素就是要删的元素。 注意删除的是末尾元素和链表只有一个元素的情况。 代码class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* slow &#x3D; head; ListNode* fast &#x3D; head; while(n--) fast &#x3D; fast-&gt;next; if(fast !&#x3D; nullptr)&#123; while(fast-&gt;next !&#x3D; nullptr)&#123; fast &#x3D; fast-&gt;next; slow &#x3D; slow-&gt;next; &#125; if(slow-&gt;next &#x3D;&#x3D; fast) slow-&gt;next &#x3D; nullptr; else&#123; ListNode* tmp &#x3D; slow-&gt;next; slow-&gt;next &#x3D; slow-&gt;next-&gt;next; delete tmp; &#125; &#125; else head &#x3D; head-&gt;next; return head; &#125; &#125;; 2023.4.101019.链表中的下一个更大节点题干给定一个长度为 n 的链表 head，对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。 返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。 示例 示例 1： 输入：head &#x3D; [2,1,5] 输出：[5,5,0] 示例 2： 输入：head &#x3D; [2,1,5] 输出：[5,5,0] 解法基本思路：单调栈 维护一个底大顶小的单调栈。假设前几个元素为9、7、5、3，此时没有任意一个更大的元素时，则把每个元素都压入栈。这时出现一个6，发现比栈顶的3大，那么把3出栈，更新该处的值为6。再跟栈顶的5比，还大，就继续出栈，更新。直至跟7比小了，就结束；然后把6入栈，记录该处的值为本身6。 也就是说，入栈的元素栈底的必然比上面的大，而每次来一个较大元素，都把所有比他小的元素出栈，一直遍历到链表结束。此时栈中若还有元素，说明整个链表他们右边没有更大的了，那么值就是0，依次出栈记录0即可。 用栈维护下标，值存储在数组中。 代码class Solution &#123; public: vector&lt;int&gt; nextLargerNodes(ListNode* head) &#123; vector&lt;int&gt; res; stack&lt;int&gt; bigger; for(ListNode* cur &#x3D; head; cur; cur &#x3D; cur-&gt;next)&#123; while(!bigger.empty() &amp;&amp; res[bigger.top()] &lt; cur-&gt;val)&#123; res[bigger.top()] &#x3D; cur-&gt;val; bigger.pop(); &#125; bigger.emplace(res.size()); res.push_back(cur-&gt;val); &#125; while(!bigger.empty())&#123; res[bigger.top()] &#x3D; 0; bigger.pop(); &#125; return res; &#125; &#125;; 面试题 02.07.链表相交题干给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 示例 1： 输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3 输出：Intersected at &#39;8&#39; 示例 2： 输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2 输出：null 解法基本思路：**双指针 ** 因为两个链表后半部分相同，因此只要将其末尾对齐，找有无公共节点即可。 代码class Solution &#123; public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* a &#x3D; headA; ListNode* b &#x3D; headB; int aLen &#x3D; 0, bLen &#x3D; 0; while(a)&#123; a &#x3D; a-&gt;next; aLen++; &#125; while(b)&#123; b &#x3D; b-&gt;next; bLen++; &#125; a &#x3D; headA; b &#x3D; headB; if(bLen &gt; aLen)&#123; swap(a, b); swap(aLen, bLen); &#125; int sub &#x3D; aLen - bLen; while(sub--) a &#x3D; a-&gt;next; while(a)&#123; if(a &#x3D;&#x3D; b) return a; a &#x3D; a-&gt;next; b &#x3D; b-&gt;next; &#125; return NULL; &#125; &#125;; 优化天才解法 设链表a长度为a，b长度为b，公共部分长度为c。可知a到公共节点前长度为a - c，b为 b - c。 双指针A、B指向a、b头部，A遍历完a后遍历b，B遍历完b后遍历a，当走到公共节点时，两者所走步数分别为a + b - c 和 b + a - c。 此时指针A、B重合，a + (b - c) = b + (a - c) 必然成立，会有两种情况： 有公共尾部，c ≠ 0，那么双指针肯定指向同一个节点，返回； 无公共尾部，c = 0，那么双指针都指向末尾NULL，也返回。 真牛吧！ class Solution &#123; public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *A &#x3D; headA, *B &#x3D; headB; while (A !&#x3D; B) &#123; A &#x3D; A !&#x3D; nullptr ? A-&gt;next : headB; B &#x3D; B !&#x3D; nullptr ? B-&gt;next : headA; &#125; return A; &#125; &#125;; 142.环形链表 Ⅱ题干给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 示例 1： 输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1 输出：返回索引为 1 的链表节点 示例 2： 输入：head &#x3D; [1,2], pos &#x3D; -1 输出：返回NULL 解法基本思路：双指针 第一步：快慢指针，统计环长 slow步长为1，fast步长为2。当第一次相遇时开始维护变量len，当第二次相遇时，len即为环长（由于双指针的速度差为1，当slow走完一圈时fast正好走完两圈相遇在同一位置，也就是slow动的次数即为环长）。 注意：fast步长为2，循环时要考虑到fast后两个节点是否为NULL的情况。以及循环结束时根据len值判断有无环。 第二步：前后指针，找到进入环的节点 slow与fast步长均为1，fast先走len步。于是当slow到达环入口节点时，fast多走了一个环长也到了入口处，两者相遇处即为答案。 代码class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; ListNode* slow &#x3D; head; ListNode* fast &#x3D; head; int len &#x3D; 0; int count &#x3D; 0; while(fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; if(count) len++; if(slow &#x3D;&#x3D; fast)&#123; if(count) break; count++; &#125; &#125; if(len &#x3D;&#x3D; 0) return NULL; slow &#x3D; head; fast &#x3D; head; while(len--) fast &#x3D; fast-&gt;next; while(slow !&#x3D; fast)&#123; fast &#x3D; fast-&gt;next; slow &#x3D; slow-&gt;next; &#125; return slow; &#125; &#125;; 287.寻找重复数题干给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 示例 示例 1： 输入：nums &#x3D; [1,3,4,2,2] 输出：2 示例 2： 输入：nums &#x3D; [3,1,3,4,2] 输出：3 解法基本思路：双指针 思路同上题 142.环形链表 Ⅱ 。 居然把数组当成一个特殊链表来看，只有一个重复数就像只有一个环的入口。同时n+1的长度，元素在 [1，n] 范围内不存在越界问题。 代码class Solution &#123; public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int slow &#x3D; 0, fast &#x3D; 0; int len &#x3D; 0, count &#x3D; 0; while(count !&#x3D; 2)&#123; if(count) len++; if(nums[slow] &#x3D;&#x3D; nums[fast]) count++; slow &#x3D; nums[slow]; fast &#x3D; nums[nums[fast]]; &#125; slow &#x3D; fast &#x3D; 0; while(len--) fast &#x3D; nums[fast]; while(nums[slow] !&#x3D; nums[fast])&#123; slow &#x3D; nums[slow]; fast &#x3D; nums[fast]; &#125; return nums[slow]; &#125; &#125;; 2023.4.111041.困于环中的机器人题干在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。注意: 北方向 是y轴的正方向。 南方向 是y轴的负方向。 东方向 是x轴的正方向。 西方向 是x轴的负方向。 机器人可以接受下列三条指令之一： “G”：直走 1 个单位 “L”：左转 90 度 “R”：右转 90 度 机器人按顺序执行指令 instructions，并一直重复它们。只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。 示例 示例 1： 输入：instructions &#x3D; &quot;GGLLGG&quot; 输出：true 示例 2： 输入：instructions &#x3D; &quot;GL&quot; 输出：true 解法基本思路：模拟 主要就是判断走完后的状态。若回到原点了，那一定是环。 若没能回到原点，分四个方向： 朝北，说明回不去了，因为相当于一直在朝一个方向移动。 朝南，则下一次相当于原路返回原点，是环。 朝西、朝东，都是相当于每次移动相同形状的轨迹，转90°，也是环。 因此返回false的条件必须是结束时不在原点且朝向北。 代码class Solution &#123; public: bool isRobotBounded(string instructions) &#123; int x &#x3D; 0, y &#x3D; 0, direct &#x3D; 0; vector&lt;vector&lt;int&gt;&gt; step &#x3D; &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; for(char c : instructions)&#123; if(c &#x3D;&#x3D; &#39;G&#39;)&#123; x +&#x3D; step[direct][0]; y +&#x3D; step[direct][1]; &#125; else if(c &#x3D;&#x3D; &#39;L&#39;)&#123; direct +&#x3D; 3; direct %&#x3D; 4; &#125; else&#123; direct++; direct %&#x3D; 4; &#125; &#125; return !(direct &#x3D;&#x3D; 0 &amp;&amp; (x || y)); &#125; &#125;; 2023.4.121147.段式回文题干你会得到一个字符串 text 。你应该把它分成 k 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足: subtexti 是 非空 字符串，所有子字符串的连接等于 text ( 即subtext1 + subtext2 + … + subtextk == text )。对于所有 i 的有效值( 即 1 &lt;= i &lt;= k ) ，subtexti == subtextk - i + 1 均成立 返回k可能最大值。 示例 示例 1： 输入：text &#x3D; &quot;ghiabcdefhelloadamhelloabcdefghi&quot; 输出：7 示例 2： 输入：text &#x3D; &quot;merchant&quot; 输出：1 解法基本思路：双指针 双指针指向字符串头尾，用于锁定为判断字符串的范围。 因为要求最大值，因此字串长度要尽可能小。子串长度k从1开始（注意头串的尾部下标 &lt; 尾串的头部下标），有相同的子串直接记录+2，双指针向中间移动k。 缩小判断范围后重复上述过程。如果k平分了整个字符串都没有找到，那就返回整个串作为子串，记录只能+1，并直接结束。 代码class Solution &#123; public: int longestDecomposition(string text) &#123; auto checkSame &#x3D; [&amp;](int i, int j, int k)&#123; while(k--) if(text[i++] !&#x3D; text[j++]) return false; return true; &#125;; int res &#x3D; 0; for(int i &#x3D; 0, j &#x3D; text.length() - 1; i &lt;&#x3D; j;)&#123; bool flag &#x3D; false; for(int k &#x3D; 1; i + k - 1 &lt; j - k + 1; ++k)&#123; if(checkSame(i, j - k + 1, k))&#123; res +&#x3D; 2; i +&#x3D; k; j -&#x3D; k; flag &#x3D; true; break; &#125; &#125; if(!flag)&#123; res++; break; &#125; &#125; return res; &#125; &#125;; 匿名函数Lambda函数主体：[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; 捕获形式 说明 [] 不捕获任何外部变量 [变量名, …] 默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符） [this] 以值的形式捕获this指针 [=] 以值的形式捕获所有外部变量 [&amp;] 以引用形式捕获所有外部变量 [=, &amp;x] 变量x以引用形式捕获，其余变量以传值形式捕获 [&amp;, x] 变量x以值的形式捕获，其余变量以引用形式捕获 若要在匿名函数内修改值引用的外部变量，可以在括号后使用 mutable 关键字（[a] () mutable { cout &lt;&lt; ++a; }; 这里a在这个函数内部自加了，但是外部的a的值是不变的）。 return type若不指定，编译器会根据内部返回值的类型确定该匿名函数的返回值类型。 2023.4.132404.出现最频繁的偶数元素题干给你一个整数数组 nums ，返回出现最频繁的偶数元素。 如果存在多个满足条件的元素，只需要返回 最小 的一个。如果不存在这样的元素，返回 -1 。 示例 示例 1： 输入：nums &#x3D; [0,1,2,2,4,4,1] 输出：2 示例 2： 输入：nums &#x3D; [29,47,21,41,13,37,25,7] 输出：-1 解法基本思路：哈希表 用哈希表统计每个偶数元素出现的次数，然后遍历哈希表找到次数最多的元素中值最小的。 代码class Solution &#123; public: int mostFrequentEven(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; cnt; for(int n : nums)&#123; if(n % 2 &#x3D;&#x3D; 0) cnt[n]++; &#125; if(cnt.empty()) return -1; int maxNum &#x3D; 0, minVal &#x3D; INT_MAX; for(auto c : cnt)&#123; if(c.second &gt; maxNum || c.second &#x3D;&#x3D; maxNum &amp;&amp; c.first &lt; minVal)&#123; maxNum &#x3D; c.second; minVal &#x3D; c.first; &#125; &#125; return minVal; &#125; &#125;; 2023.4.141023.驼峰式匹配题干如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。） 给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。 示例 示例 1： 输入：queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FB&quot; 输出：[true,false,true,true,false] 示例 2： 输入：queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FoBaT&quot; 输出：[false,true,false,false,false] 解法基本思路：双指针 本质其实是字符串比较。规则是：大写字符必须全部匹配。 双指针i、j指向query和pattern，以pattern为循环体，字符比较 若不同 ——小写字符，i++继续比较； ——大写字符直接false，不能有匹配不上的大写字符； 若相同 ——i++、j++。 如果j没结束时i就遍历完了，说明 j 有没匹配到的，false。 如果j先遍历完了，遍历剩下的i，若有大写的false，全小写true。 代码class Solution &#123; public: vector&lt;bool&gt; camelMatch(vector&lt;string&gt;&amp; queries, string pattern) &#123; vector&lt;bool&gt; res; auto check &#x3D; [](string s, string t)&#123; int i &#x3D; 0, j &#x3D; 0; for(; j &lt; t.length(); ++i, ++j)&#123; while(i &lt; s.length() &amp;&amp; s[i] !&#x3D; t[j] &amp;&amp; s[i] &gt; 96) ++i; if(i &#x3D;&#x3D; s.length() || s[i] !&#x3D; t[j]) return false; &#125; while(i &lt; s.length() &amp;&amp; s[i] &gt; 96) ++i; return i &#x3D;&#x3D; s.length(); &#125;; for(auto str : queries) res.push_back(check(str, pattern)); return res; &#125; &#125;; 2023.4.172409.统计共同度过的日子数解法基本思路：模拟、数学计算 简单的日期转换，转换为当年的第多少天，然后求交集。 代码class Solution &#123; public: int getDays(string s)&#123; int days[13] &#x3D; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int res &#x3D; 0; int m &#x3D; atoi(s.substr(0, 2).c_str()); int d &#x3D; atoi(s.substr(3, 2).c_str()); for(int i &#x3D; 1; i &lt; m; ++i) res +&#x3D; days[i]; return res + d; &#125; int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) &#123; int aa &#x3D; getDays(arriveAlice); int la &#x3D; getDays(leaveAlice); int ab &#x3D; getDays(arriveBob); int lb &#x3D; getDays(leaveBob); if(aa &gt; lb || ab &gt; la) return 0; return min(la, lb) - max(aa, ab) + 1; &#125; &#125;; 242.有效的字母异位词解法基本思路：哈希表 代码class Solution &#123; public: bool isAnagram(string s, string t) &#123; if(s.length() !&#x3D; t.length()) return false; vector&lt;int&gt; hash(26, 0); for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; hash[s[i] - &#39;a&#39;]++; hash[t[i] - &#39;a&#39;]--; &#125; for(int n : hash) if(n) return false; return true; &#125; &#125;; 383.赎金信解法基本思路：哈希表 和上题242.有效的字母异位词一个思路。 代码class Solution &#123; public: bool canConstruct(string ransomNote, string magazine) &#123; vector&lt;int&gt; hash(26, 0); for(char c : magazine) hash[c - &#39;a&#39;]++; for(char c : ransomNote) hash[c - &#39;a&#39;]--; for(int n : hash) if(n &lt; 0) return false; return true; &#125; &#125;; 49.字母异位词分组题干给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。 示例 示例 1： 输入: strs &#x3D; [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;] 输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]] 示例 2： 输入: strs &#x3D; [&quot;&quot;] 输出: [[&quot;&quot;]] 解法基本思路：哈希 因为所有的异位词在排序后都是相同的，那么就可以用哈希表存储vector保存属于同一种类的字符串。 代码class Solution &#123; public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; res; unordered_map&lt;string, vector&lt;string&gt;&gt; hash; auto sortStr &#x3D; [](string str)&#123; sort(str.begin(), str.end()); return str; &#125;; for(string s : strs) hash[sortStr(s)].push_back(s); for(auto m : hash) res.push_back(m.second); return res; &#125; &#125;; 438.找到字符串中所有字母异位词题干给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例 示例 1： 输入: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot; 输出: [0,6] 示例 2： 输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot; 输出: [0,1,2] 解法基本思路：滑动窗口、双指针、哈希 第一想法是滑动窗口扫一遍，每次将窗口内字符排序后与排序后的p比较。实际是暴力解法，O(n^2)复杂度，其中有很多不必要的操作： 例如[i, j]和[i+1, j+1]两个子串在暴力法第二步中，需要各遍历一次，完全没必要。其实[i+1, j+1]完全可以在[i, j]的基础上做判断，也就是去掉头部的字符（i位置），加上尾部的字符（j+1位置）。这样第一步的复杂度可以降到O(1)，整体复杂度降到O(n)。 代码class Solution &#123; public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; if(s.length() &lt; p.length()) return &#123;&#125;; vector&lt;int&gt; res; vector&lt;int&gt; shash(26, 0); vector&lt;int&gt; phash(26, 0); for(char c : p) phash[c - &#39;a&#39;]++; for(int i &#x3D; 0; i &lt; p.length(); ++i) shash[s[i] - &#39;a&#39;]++; int i &#x3D; p.length(), j &#x3D; 0; for(; i &lt; s.length(); ++i, ++j)&#123; if(shash &#x3D;&#x3D; phash) res.push_back(j); shash[s[i] - &#39;a&#39;]++; shash[s[j] - &#39;a&#39;]--; &#125; if(shash &#x3D;&#x3D; phash) res.push_back(j); return res; &#125; &#125;; 2023.4.22349.两个数组的交集解法基本思路：哈希表 代码class Solution &#123; public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; hash; vector&lt;int&gt; res; for(int n : nums1) if(!hash.count(n)) hash.emplace(n); for(int n : nums2)&#123; if(hash.count(n))&#123; res.push_back(n); hash.erase(n); &#125; &#125; return res; &#125; &#125;; 350.两个数组的交集Ⅱ解法基本思路：哈希表 代码class Solution &#123; public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; res; for(int n : nums1) ++hash[n]; for(int n : nums2)&#123; if(hash.count(n) &amp;&amp; hash[n] &gt; 0)&#123; res.push_back(n); --hash[n]; &#125; &#125; return res; &#125; &#125;; 202.快乐数解法基本思路：哈希表 这题的关键在于找到什么情况下是无解的？当某次平方和的值重复出现的时候，那么用哈希表做个判断即可。 代码class Solution &#123; public: bool isHappy(int n) &#123; unordered_set&lt;int&gt; hash; int sum &#x3D; 0, unit; while(1)&#123; unit &#x3D; n % 10; sum +&#x3D; unit * unit; n &#x2F;&#x3D; 10; if(n &#x3D;&#x3D; 0)&#123; n &#x3D; sum; if(sum &#x3D;&#x3D; 1) return true; if(hash.count(sum)) return false; hash.emplace(sum); sum &#x3D; 0; &#125; &#125; return true; &#125; &#125;; 1.两数之和解法基本思路：哈希表 将数组元素依次加入哈希表，并判断target - 当前元素的值是否在哈希表中。 代码class Solution &#123; public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hashs; for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123; auto iter &#x3D; hashs.find(target - nums[i]); if (iter !&#x3D; hashs.end()) return &#123;iter-&gt;second, i&#125;; hashs.insert(&#123;nums[i], i&#125;); &#125; return &#123;&#125;; &#125; &#125;; 454.四数相加Ⅱ题干给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 示例 1： 输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2] 输出：2 示例 2： 输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0] 输出：1 解法基本思路：哈希 因为所有的异位词在排序后都是相同的，那么就可以用哈希表存储vector保存属于同一种类的字符串。 乍一看有点懵，实际就是转换一下条件，变成：nums1[i] + nums2[j] == -(nums3[k] + nums4[l]） 也就是先记录每一对1、2的和的数量存入哈希，然后将3、4的和放入哈希去找，若存在，直接增加记录的数量（因为和为该值的每一对1、2都能与这对3、4相匹配，所以直接加数量）。 代码class Solution &#123; public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; hash; int res &#x3D; 0; for(int i : nums1) for(int j : nums2) ++hash[i+j]; for(int i : nums3) for(int j : nums4) if(hash.count(-i-j)) res +&#x3D; hash[-i-j]; return res; &#125; &#125;; 2023.4.231105.填充书架题干给定一个数组 books ，其中 books[i] = [thicknessi, heighti] 表示第 i 本书的厚度和高度。你也会得到一个整数 shelfWidth 。 按顺序 将这些书摆放到总宽度为 shelfWidth 的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelfWidth ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度为这一层书架的层高，书架整体高度为各层高之和。以这种方式布置书架，返回书架整体可能的最小高度。 示例 示例 1： 输入：books &#x3D; [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth &#x3D; 4 输出：6 示例 2： 输入: books &#x3D; [[1,3],[2,4],[3,2]], shelfWidth &#x3D; 6 输出: 4 解法基本思路：动态规划 设前i本书摆放完成后的总高度为 f[i] ,答案为 f[n] 。那么对于第i本书的w和h：1.若单独拜访一层有 f[i] = f[i - 1] + h ；2.若与之前 ？本书一起放，则需要找到这些书的最大高度作为该层层高。 从第 i - 1 本书开始向前遍历，停止条件为累加书的w大于了shelfWidth。找到这些书中 的最大高度，那么可得 f[i] = min(f[i], f[j - 1] + h) 代码class Solution &#123; public: int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) &#123; int n &#x3D; books.size(); vector&lt;int&gt; f(n + 1, 0); for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123; int w &#x3D; books[i - 1][0], h &#x3D; books[i - 1][1]; f[i] &#x3D; f[i - 1] + h; for(int j &#x3D; i - 1; j &gt; 0; --j)&#123; w +&#x3D; books[j - 1][0]; if(w &gt; shelfWidth) break; h &#x3D; max(h, books[j - 1][1]); f[i] &#x3D; min(f[i], f[j - 1] + h); &#125; &#125; return f[n]; &#125; &#125;; 344.反转字符串解法基本思路：双指针、swap swap的实现方法有两种：1.是通过临时变量存储交换；2.是通过位运算(异或)交换。 a ^&#x3D; b; b ^&#x3D; a; a ^&#x3D; b; 代码class Solution &#123; public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int l &#x3D; 0, r &#x3D; s.size() - 1; while(l &lt; r) swap(s[l++], s[r--]); &#125; &#125;; 541.反转字符串Ⅱ解法基本思路：双指针、swap 在上题344.反转字符串的基础上，判断每段要反转的部分的两端位置即可。 代码class Solution &#123; public: string reverseStr(string s, int k) &#123; auto revStr &#x3D; [&amp;s](int l, int r)&#123; while(l &lt; r) swap(s[l++], s[r--]); &#125;; int cnt &#x3D; s.length() &#x2F; (2 * k); int unit &#x3D; s.length() % (2 * k); for(int i &#x3D; 0; i &lt; cnt; ++i) revStr(i * k * 2, i * k * 2 + k - 1); if(unit &gt;&#x3D; k) revStr(cnt * k * 2, cnt * k * 2 + k - 1); else revStr(cnt * k * 2, s.length() - 1); return s; &#125; &#125;; 剑指offer 05.替换空格解法基本思路：双指针、string::resize()函数 先统计空格数量，计算出要扩充的空间（cnt * 2）。 扩充之后使用双指针分别指向原字符串的末尾和现在的末尾，将原来的依次填入，碰到空格填入”%20”即可。 resize(size_t n, char c) c为可选参数，表示扩充后的位置填入的字符。 n为扩充后的字符串长度。若n小于原长，删除 [0, n) 范围外的所有字符；若n大于原长，有c填入c，无c参数填入null。 代码class Solution &#123; public: string replaceSpace(string s) &#123; int cnt &#x3D; 0; for(char c : s) cnt +&#x3D; c &#x3D;&#x3D; &#39; &#39;; int l &#x3D; s.length() - 1; s.resize(s.length() + cnt * 2); int r &#x3D; s.length() - 1; while(l &gt;&#x3D; 0)&#123; if(s[l] !&#x3D; &#39; &#39;) s[r--] &#x3D; s[l]; else&#123; s[r--] &#x3D; &#39;0&#39;; s[r--] &#x3D; &#39;2&#39;; s[r--] &#x3D; &#39;%&#39;; &#125; l--; &#125; return s; &#125; &#125;; 151.反转字符串中的单词题干给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 示例 示例 1： 输入：s &#x3D; &quot;the sky is blue&quot; 输出：&quot;blue is sky the&quot; 示例 2： 输入：s &#x3D; &quot;a good example&quot; 输出：&quot;example good a&quot; 解法基本思路：双指针 整体思路就是先处理掉多余空格，然后整体反转字符串，此时单词也是反的，再反转回来即可。 代码class Solution &#123; public: string reverseWords(string s) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; &#x2F;&#x2F; 只处理有字符的（每个单词的第一个字符） if(s[i] !&#x3D; &#39; &#39;)&#123; &#x2F;&#x2F; 如果已经有单词填入了，那这时候进来说明找到下一个个词了，需用空格隔开 if(cnt !&#x3D; 0) s[cnt++] &#x3D; &#39; &#39;; while(i &lt; s.length() &amp;&amp; s[i] !&#x3D; &#39; &#39;) &#x2F;&#x2F; 双指针cnt和i，cnt是修改后的字符位置 s[cnt++] &#x3D; s[i++]; &#x2F;&#x2F; 把一个完整单词填入 &#125; &#125; s.resize(cnt); &#x2F;&#x2F; 重置长度 auto revStr &#x3D; [&amp;s](int l, int r)&#123; &#x2F;&#x2F; 反转函数 while(l &lt; r) swap(s[l++], s[r--]); &#125;; revStr(0, s.length() - 1); &#x2F;&#x2F; 先整体反转 int start &#x3D; 0; for(int i &#x3D; 0; i &lt;&#x3D; s.length(); ++i)&#123; if(s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length())&#123; &#x2F;&#x2F; 最后一个单词后没有空格，因此要多加一个判定条件 revStr(start, i - 1); &#x2F;&#x2F; 把每个单词再单独反转回来 start &#x3D; i + 1; &#125; &#125; return s; &#125; &#125;; 2023.4.241163.按字典序排在最后的子串题干给你一个字符串 s ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。 示例 示例 1： 输入：s &#x3D; &quot;abab&quot; 输出：&quot;bab&quot; 示例 2： 输入：s &#x3D; &quot;leetcode&quot; 输出：&quot;tcode&quot; 解法基本思路：双指针 首先要明白如何判断是排最后的：字母越大越靠后、子串末尾一定是s末尾（假如存在非后缀的子串，那么再往后延伸一个字符一定更大）。 维护快慢指针slow和fast，slow表示当前最大的子串，fast向后遍历找有无更大的子串。 因为双指针指向两个子串的头部，因此如果判断相同位置字符相同时，往后移动判断需要另维护一个idx变量。 代码class Solution &#123; public: string lastSubstring(string s) &#123; int slow &#x3D; 0, fast &#x3D; 1, idx &#x3D; 0; while(fast + idx &lt; s.length())&#123; if(s[slow + idx] &#x3D;&#x3D; s[fast + idx])&#123; ++idx; &#125; else if(s[slow + idx] &lt; s[fast + idx])&#123; slow +&#x3D; idx + 1; idx &#x3D; 0; if(slow &gt;&#x3D; fast) fast &#x3D; slow + 1; &#125; else&#123; fast +&#x3D; idx + 1; idx &#x3D; 0; &#125; &#125; return s.substr(slow); &#125; &#125;; 2023.4.252418.按身高排序解法基本思路：排序 代码class Solution &#123; public: vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) &#123; int n &#x3D; heights.size(); vector&lt;int&gt; idx(n); for(int i &#x3D; 0; i &lt; n; ++i) idx[i] &#x3D; i; sort(idx.begin(), idx.end(), [&amp;heights](int i, int j)&#123;return heights[i] &gt; heights[j];&#125;); vector&lt;string&gt; res; for(int i : idx) res.push_back(names[i]); return res; &#125; &#125;; 2023.4.26剑指offer 58.Ⅱ 左旋转字符串解法基本思路：双指针 在344.反转字符串的基础上，做多次反转。 代码class Solution &#123; public: string reverseLeftWords(string s, int n) &#123; auto revStr &#x3D; [&amp;s](int l, int r)&#123; while(l &lt; r) swap(s[l++], s[r--]); &#125;; revStr(0, n - 1); revStr(n, s.length() - 1); revStr(0, s.length() - 1); return s; &#125; &#125;; 28.找出字符串中第一个匹配项的下标题干给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 示例 示例 1： 输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot; 输出：0 示例 2： 输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot; 输出：-1 解法基本思路：字符串匹配、KMP 代码class Solution &#123; public: vector&lt;int&gt; getNextArr(string p)&#123; vector&lt;int&gt; next(p.length()); next[0] &#x3D; -1; int k &#x3D; -1, j &#x3D; 0; while(j &lt; p.length() - 1)&#123; if(k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) next[++j] &#x3D; ++k; else k &#x3D; next[k]; &#125; return next; &#125; int kmp(string pattern, string word)&#123; int i &#x3D; 0, j &#x3D; 0; int pLen &#x3D; pattern.length(), wLen &#x3D; word.length(); vector&lt;int&gt; next &#x3D; getNextArr(pattern); while(i &lt; wLen &amp;&amp; j &lt; pLen)&#123; if(j &#x3D;&#x3D; -1 || word[i] &#x3D;&#x3D; pattern[j])&#123; ++i; ++j; &#125; else j &#x3D; next[j]; if(j &#x3D;&#x3D; pLen) return i - pLen; &#125; return -1; &#125; int strStr(string haystack, string needle) &#123; return kmp(needle, haystack); &#125; &#125;; 459.重复的子字符串解法基本思路：字符串匹配、KMP 对于最小重复子串的理解： 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 需要注意，如下的前缀表计算方式，存储的值是后移一位的，即next[2]对应的是到下标1（0~1）处的最长相同前后缀，因此在主程序中计算时做了特殊处理。 代码class Solution &#123; public: vector&lt;int&gt; getNextArr(string p)&#123; vector&lt;int&gt; next(p.length()); next[0] &#x3D; -1; int k &#x3D; -1, j &#x3D; 0; while(j &lt; p.length() - 1)&#123; if(k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) next[++j] &#x3D; ++k; else k &#x3D; next[k]; &#125; return next; &#125; bool repeatedSubstringPattern(string s) &#123; if(s.size() &#x3D;&#x3D; 0) return false; vector&lt;int&gt; next &#x3D; getNextArr(s+&#39; &#39;); int l &#x3D; next.size(); return next[l - 1] &gt; 0 &amp;&amp; (l - 1) % (l - 1 - next[l - 1]) &#x3D;&#x3D; 0; &#125; &#125;; 打卡5月LeetCode2023.5.31003.检查替换后的词是否有效题干给你一个字符串 s ，请你判断它是否 有效 。字符串 s 有效 需要满足：假设开始有一个空字符串 t = “” ，你可以执行 任意次 下述操作将 t 转换为 s ： 将字符串 “abc“ 插入到 t 中的任意位置。形式上，t 变为 tleft + “abc” + tright，其中 t == tleft + tright 。注意，tleft 和 tright 可能为 空 。 如果字符串 s 有效，则返回 true；否则，返回 false。 示例 示例 1： 输入：s &#x3D; &quot;abcabcababcc&quot; 输出：true 示例 2： 输入：s &#x3D; &quot;abccba&quot; 输出：false 解法基本思路：模拟、栈 用string模拟栈，出栈用erase。 将源字符串逐个入栈，直到入一个c，会同时消去上两个入的a、b。 如果前两个不是a、b，说明这个c出现的顺序是有问题的，字符串是无效的，直接false了。 如果最后栈空了，说明都消去了，字符串有效。 代码class Solution &#123; public: bool isValid(string s) &#123; if(s.length() % 3 !&#x3D; 0) return false; string tmp &#x3D; &quot;&quot;; for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; tmp +&#x3D; s[i]; if(tmp.length() &gt; 2 &amp;&amp; s[i] &#x3D;&#x3D; &#39;c&#39;) if(tmp.substr(tmp.length() - 3, 3) &#x3D;&#x3D; &quot;abc&quot;) tmp.erase(tmp.end() - 3, tmp.end()); else return false; &#125; return tmp.empty(); &#125; &#125;; 2023.5.16232.用栈实现队列解法基本思路：模拟、栈 在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。 代码class MyQueue &#123; public: MyQueue() &#123;&#125; void push(int x) &#123; In.push(x); &#125; int pop() &#123; if(Out.empty())&#123; while(!In.empty())&#123; Out.push(In.top()); In.pop(); &#125; &#125; int res &#x3D; Out.top(); Out.pop(); return res; &#125; int peek() &#123; if(Out.empty())&#123; while(!In.empty())&#123; Out.push(In.top()); In.pop(); &#125; &#125; return Out.top(); &#125; bool empty() &#123; return In.empty() &amp;&amp; Out.empty(); &#125; private: stack&lt;int&gt; In; stack&lt;int&gt; Out; &#125;; 225.用队列实现栈解法基本思路：模拟、队列 一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。 代码class MyStack &#123; public: MyStack() &#123; &#125; void push(int x) &#123; Q.push(x); &#125; int pop() &#123; int len &#x3D; Q.size() - 1; while(len--)&#123; Q.push(Q.front()); Q.pop(); &#125; int res &#x3D; Q.front(); Q.pop(); return res; &#125; int top() &#123; return Q.back(); &#125; bool empty() &#123; return Q.empty(); &#125; private: queue&lt;int&gt; Q; &#125;; 20.有效的括号解法基本思路：栈 因为右括号消去的必然是一组中最后出现的左括号，因此本质就是后进先出的栈。 代码class Solution &#123; public: bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(st.empty()) st.push(c); else&#123; if(c - st.top() &#x3D;&#x3D; 1 || c - st.top() &#x3D;&#x3D; 2) st.pop(); else st.push(c); &#125; &#125; return st.empty(); &#125; &#125;; 2023.5.172446.判断两个事件是否存在冲突解法基本思路：字符串比较 不需要转换成int值，直接字符串比较即可。 代码class Solution &#123; public: bool haveConflict(vector&lt;string&gt;&amp; event1, vector&lt;string&gt;&amp; event2) &#123; return !(event1[0] &gt; event2[1] || event1[1] &lt; event2[0]); &#125; &#125;; 2023.5.181047.删除字符串中的所有相邻重复项解法基本思路：模拟、栈、字符串 依旧是模拟栈LIFO的模式，直接用字符串实现，节约空间和时间。 代码class Solution &#123; public: string removeDuplicates(string s) &#123; string res &#x3D; &quot;&quot;; for(char c : s)&#123; if(res.empty() || res.back() !&#x3D; c) res +&#x3D; c; else res.pop_back(); &#125; return res; &#125; &#125;; 2023.5.19150.逆波兰表达式求值题干给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。 注意： 有效的算符为 ‘+’、’-‘、’*’ 和 ‘/‘ 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 示例 示例 1： 输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;] 输出：6 示例 2： 输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;] 输出：22 解法基本思路：模拟、栈 逆波兰表达式（后缀表达式）转常用的中缀表达式，实际就是每找到一个计算符号就将其前两个字符取出来进行符号运算，体现在代码中就是从栈中连取两个数字出来。 代码class Solution &#123; public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; for(string s : tokens)&#123; if(s &#x3D;&#x3D; &quot;+&quot; || s &#x3D;&#x3D; &quot;-&quot; || s &#x3D;&#x3D; &quot;*&quot; || s &#x3D;&#x3D; &quot;&#x2F;&quot;)&#123; int sec &#x3D; st.top(); st.pop(); int fir &#x3D; st.top(); st.pop(); if(s &#x3D;&#x3D; &quot;+&quot;) st.push(sec + fir); else if (s &#x3D;&#x3D; &quot;-&quot;) st.push(fir - sec); else if (s &#x3D;&#x3D; &quot;*&quot;) st.push(fir * sec); else if (s &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(fir &#x2F; sec); &#125; else st.push(stoi(s)); &#125; return st.top(); &#125; &#125;; 后缀表达式对于计算机来说更友好，计算机可以利用栈来顺序处理，不需要考虑优先级、不用回退了。 2023.5.261091.二进制矩阵中的最短路径题干给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。 二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求： 路径途经的所有单元格的值都是 0 。 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。 畅通路径的长度 是该路径途经的单元格总数。 示例 示例 1： 输入：grid &#x3D; [[0,0,0],[1,1,0],[1,1,0]] 输出：4 示例 2： 输入：grid &#x3D; [[1,0,0],[1,1,0],[1,1,0]] 输出：-1 解法基本思路：广度优先遍历、队列 首先排除左上角是1的情况。 BFS通常使用队列和标记数组实现，本题中直接在原数组上修改值为1，那么可以同时作为已标记和路径为1 的判断处理。 首先将左上角置1并加入队列。 每轮搜索后，结果都会是路径长度+1（搜索轮数+1）。而使得路径长度+1的节点可能不止一个，也就是8邻域中有不止一个可通行节点，因此需要将这些节点均遍历一遍才能算完成一轮搜索；这些节点的数量就是本轮搜索开始时队列内的元素数。 每次取出队首节点后，若该节点为右下角，直接返回统计的轮数；若不是，则判断其8邻域：若未越界且值为0（可通行且未被标记），则将其加入队列并标记。 若循环结束仍未return，说明无法到达，返回-1。 代码class Solution &#123; public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid[0][0]) return -1; int n &#x3D; grid.size() - 1; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;0, 0&#125;); grid[0][0] &#x3D; 1; int res &#x3D; 1; while(!q.empty())&#123; for(int num &#x3D; q.size(); num; --num)&#123; &#x2F;&#x2F; 这一层 pair&lt;int, int&gt; item &#x3D; q.front(); int x &#x3D; item.first; int y &#x3D; item.second; q.pop(); if(x &#x3D;&#x3D; n &amp;&amp; y &#x3D;&#x3D; n) return res; for(int row &#x3D; x-1; row &lt;&#x3D; x+1; ++row)&#123; for(int col &#x3D; y-1; col &lt;&#x3D; y+1; ++col)&#123; if(row &lt; 0 || row &gt; n || col &lt; 0 || col &gt; n || grid[row][col]) continue; grid[row][col] &#x3D; 1; q.push(&#123;row, col&#125;); &#125; &#125; &#125; res++; &#125; return -1; &#125; &#125;; 打卡6月LeetCode2023.6.52460.对数组执行操作解法基本思路：模拟 代码class Solution &#123; public: vector&lt;int&gt; applyOperations(vector&lt;int&gt;&amp; nums) &#123; int n &#x3D; nums.size(); vector&lt;int&gt; res(n, 0); int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; n-1; ++i)&#123; if(nums[i] &#x3D;&#x3D; nums[i+1])&#123; nums[i] *&#x3D; 2; nums[i+1] &#x3D; 0; &#125; if(nums[i]) res[cnt++] &#x3D; nums[i]; &#125; res[cnt] &#x3D; nums[n - 1]; return res; &#125; &#125;; 239.滑动窗口最大值题干给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 示例 1： 输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3 输出：[3,3,5,5,6,7] 示例 2： 输入：nums &#x3D; [1], k &#x3D; 1 输出：[1] 解法基本思路：单调队列、双向队列 维护一个单调的从大到小的双向队列（可以同时操作队首和队尾），用于存储当次滑动窗口中可能是最大值的数的下标。 如何维护单调： 每当窗口右移，将新加入的数与队尾下标所在元素比较，更大则将队尾下标出队，继续跟队尾比较，直至队列空或满足单调性质为止，将其入队。 如何获取最大值： 判断队首下标是否在滑动窗口区间内（存储下标而不是值的原因，值可以通过nums数组获取），若不在则出队，继续下一个队首，找到在区间内的第一个队首下标所在值，即为最大值。 代码class Solution &#123; public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; deque&lt;int&gt; q; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; while(!q.empty() &amp;&amp; nums[i] &gt;&#x3D; nums[q.back()]) q.pop_back(); q.emplace_back(i); if(i &gt; k - 2)&#123; while(q.front() &lt;&#x3D; i - k) q.pop_front(); res.push_back(nums[q.front()]); &#125; &#125; return res; &#125; &#125;; 347.前K个高频元素题干给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 示例 示例 1： 输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2 输出: [1,2] 示例 2： 输入：nums &#x3D; [1], k &#x3D; 1 输出：[1] 解法基本思路：优先队列、堆、哈希 先用哈希表统计每个元素出现的数量，再用优先队列按照出现数从大到小排序，优先队列长度维持在 K （当有元素入队时，队首元素出队，这就要求优先队列为从小到大排序，即小顶堆），最后将队列中剩下的元素记入vector。 代码class Solution &#123; public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; struct cmp&#123; bool operator()(pair&lt;int, int&gt; a,pair&lt;int, int&gt; b)&#123; return a.second &gt; b.second; &#125; &#125;; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; q; unordered_map&lt;int, int&gt; cnt; vector&lt;int&gt; res; for(int n : nums) cnt[n]++; for(pair&lt;int, int&gt; p : cnt)&#123; q.push(p); if(q.size() &gt; k) q.pop(); &#125; while(!q.empty())&#123; res.push_back(q.top().first); q.pop(); &#125; return res; &#125; &#125;; 2023.6.72611.老鼠和奶酪题干有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。下标为 i 处的奶酪被吃掉的得分为： 如果第一只老鼠吃掉，则得分为 reward1[i] 。 如果第二只老鼠吃掉，则得分为 reward2[i] 。 给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。 示例 示例 1： 输入：reward1 &#x3D; [1,1,3,4], reward2 &#x3D; [4,4,1,1], k &#x3D; 2 输出：15 示例 2： 输入：reward1 &#x3D; [1,1], reward2 &#x3D; [1,1], k &#x3D; 2 输出：2 解法基本思路：贪心 因为要求第一只老鼠吃的数量，那么假设先全被第二只吃了，总得分为 **sum(reward2)**。 当把第 i 块奶酪分给鼠1时，可以发现得分的变化量为 **reward1[i] - reward2[i]**。这意味着要想得到最高得分，分给鼠1的k块奶酪产生的变化量都是越大越好。那么将 **reward1[i] - reward2[i]**按照从大到小排序，数组的前 k 个值加上 sum，就是最大值了。 注：sort排序中，若使用rbegin() 、rend()逆向迭代器，则为从大到小排序。 代码class Solution &#123; public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) &#123; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; reward1.size(); ++i)&#123; res +&#x3D; reward2[i]; reward1[i] -&#x3D; reward2[i]; &#125; sort(reward1.rbegin(), reward1.rend()); for(int i &#x3D; 0; i &lt; k; ++i) res +&#x3D; reward1[i]; return res; &#125; &#125;; 2023.6.13144.二叉树的前序遍历解法基本思路：递归、栈 代码递归：前、中、后序都差不多，无非是push_back的位置换了一下。 class Solution &#123; public: void travelsal(TreeNode* cur, vector&lt;int&gt;&amp; res) &#123; if(cur &#x3D;&#x3D; nullptr) return; res.push_back(cur-&gt;val); travelsal(cur-&gt;left, res); travelsal(cur-&gt;right, res); &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; travelsal(root, res); return res; &#125; &#125;; 迭代： class Solution &#123; public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; res; if(root &#x3D;&#x3D; nullptr) return res; st.push(root); while(!st.empty())&#123; TreeNode* node &#x3D; st.top(); st.pop(); res.push_back(node-&gt;val); if(node-&gt;right) st.push(node-&gt;right); if(node-&gt;left) st.push(node-&gt;left); &#125; return res; &#125; &#125;; 94.二叉树的中序遍历解法基本思路：迭代、栈 中序属于访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。 因为中序是左中右的顺序，所以需要先遍历到最左侧的左节点（没下一个左节点时），加入结果中。此时该节点为局部根节点（相当于中），然后就访问右节点。（右节点可能存在左节点和右节点，所以跟根节点的遍历一样处理）。 代码class Solution &#123; public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; st; TreeNode* cur &#x3D; root; if(root &#x3D;&#x3D; nullptr) return res; while(!st.empty() || cur)&#123; if(cur)&#123; st.push(cur); cur &#x3D; cur-&gt;left; &#125; else &#123; cur &#x3D; st.top(); st.pop(); res.push_back(cur-&gt;val); cur &#x3D; cur-&gt;right; &#125; &#125; return res; &#125; &#125;; 145.二叉树的后序遍历解法基本思路：迭代、栈 可以发现，前序是中左右，但是把前序先左后右的顺序反一下，就是中右左。后序是左右中，刚好反过来。 实现相比于中序更加简单。 代码class Solution &#123; public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; res; if(root &#x3D;&#x3D; nullptr) return res; st.push(root); while(!st.empty())&#123; TreeNode* node &#x3D; st.top(); st.pop(); res.push_back(node-&gt;val); if(node-&gt;left) st.push(node-&gt;left); if(node-&gt;right) st.push(node-&gt;right); &#125; reverse(res.begin(), res.end()); return res; &#125; &#125;; 102.二叉树的层序遍历107.二叉树的层序遍历Ⅱ题干1.给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 2.给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 示例 1： 输入：root &#x3D; [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2： 输入：root &#x3D; [] 输出：[] 解法基本思路：广度优先、队列 1.如下 2.返回前反转res数组即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root &#x3D;&#x3D; nullptr) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt; layer; int n &#x3D; q.size(); for(int i &#x3D; 0; i &lt; n; ++i)&#123; TreeNode* node &#x3D; q.front(); q.pop(); layer.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; res.push_back(layer); &#125; return res; &#125; &#125;; 2023.6.14226.翻转二叉树解法基本思路：迭代、栈、前序 只需要在前序的时候，先交换节点再往下压栈即可。 代码res.push_back(node-&gt;val); &#x2F;&#x2F; old swap(node-&gt;left, node-&gt;right); &#x2F;&#x2F; new 589.N叉树的前序遍历590.N叉树的后序遍历解法基本思路：迭代、栈、前序 2变N，顺序一样都是前序，那就是从左到右，所以遍历vector压栈时从后往前即可。 对于后序，跟二叉树一样，先把遍历顺序改为从右到左（也就是从前往后遍历vector），最后反转结果数组即可。 代码&#x2F;&#x2F; old if(node-&gt;right) st.push(node-&gt;right); if(node-&gt;left) st.push(node-&gt;left); &#x2F;&#x2F; new for(int i &#x3D; nd-&gt;children.size() - 1; i &gt;&#x3D; 0; --i) st.push(nd-&gt;children[i]); 199.二叉树的右视图题干给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 示例 1： 输入: [1,2,3,null,5,null,4] 输出: [1,3,4] 示例 2： 输入: [] 输出: [] 解法基本思路：迭代、队列、层序 在层序遍历的过程中，只将每一层最右边的节点（每层队列的队尾）加入结果数组即可。 代码layer.push_back(node-&gt;val); &#x2F;&#x2F; old if(i &#x3D;&#x3D; n - 1) res.push_back(node-&gt;val); &#x2F;&#x2F; new 637.二叉树的层平均值解法基本思路：迭代、队列、层序 用层序遍历，sum要注意越界问题。 代码double sum &#x3D; 0; sum +&#x3D; node-&gt;val; res.push_back(sum &#x2F; n); 429.N叉树的层序遍历代码&#x2F;&#x2F; old if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#x2F;&#x2F; new for(auto nd : node-&gt;children) q.push(nd); 515.在每个树行中找最大值解法基本思路：迭代、队列、层序 每层维护一个最大值即可。 代码int maxNum &#x3D; INT_MIN; if(maxNum &lt; node-&gt;val) maxNum &#x3D; node-&gt;val; 116.填充每个节点的下一个右侧节点指针117.填充每个节点的下一个右侧节点指针 Ⅱ题干给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node &#123; int val; Node *left; Node *right; Node *next; &#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 解法基本思路：迭代、队列、层序 在层序遍历中，维护一个Node*指针，指向每层上一个节点，将其next指针赋为当前指针。 每层n个节点，需要设置的为 [0, n - 2] ，因此可以用 [1, n - 1] 的节点来设置上一个。 两题一样的代码。 代码Node* pre &#x3D; NULL; if(pre) pre-&gt;next &#x3D; node; pre &#x3D; node; 104.二叉树的最大深度解法基本思路：迭代、队列、层序 计数层序遍历一共遍历了多少层即可。 111.二叉树的最小深度解法基本思路：迭代、队列、层序 计数层序遍历的层数。维护一个标志位，当某层出现叶子节点时，直接break循环返回计数值即可。 101.对称二叉树解法基本思路：迭代、队列；递归 迭代和递归的思路都是一样的，这里遍历不需要去考虑用前中后和层序哪种遍历，是独有的，但可以参考层序中队列的用法。 1.通过队列存储一对需要比较的节点（左子树和右子树的内侧、外侧）。因为存储的节点是对应的，那么它们的下一层采用相同的方式存储后，取出的两个节点依旧是对应的，这是循环的必要条件。 2.每次出队两个节点，设立判定条件： 若两个节点均为空，进入下一对节点判断 若只有一个空或都不空但不相等，直接return false 若循环结束了，那么就是遍历完了所有都没出问题，return true 递归也是一样的思路： 1.先确立递归函数的参数和返回值：左右子节点，bool。 2.确定中止条件：同上2 3.确定单层递归的逻辑：顺序也和迭代一样 先取一对节点（递归省略了这个过程） 判定条件（这里和迭代不同的点在于条件1直接返回了true，这是因为会调用多次递归函数，直接返回true表示这条路径走到头了都没有问题） 最后的总return要综合一对节点下的两对节点的判断情况（递归了）作为结果。 代码&#x2F;&#x2F; 迭代 class Solution &#123; public: bool isSymmetric(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root-&gt;left); q.push(root-&gt;right); while(!q.empty()) &#123; TreeNode* ln &#x3D; q.front(); q.pop(); TreeNode* rn &#x3D; q.front(); q.pop(); if(!ln &amp;&amp; !rn) continue; if(!ln || !rn || (ln-&gt;val !&#x3D; rn-&gt;val)) return false; q.push(ln-&gt;left); q.push(rn-&gt;right); q.push(ln-&gt;right); q.push(rn-&gt;left); &#125; return true; &#125; &#125;; &#x2F;&#x2F; 递归 class Solution &#123; public: bool recursion(TreeNode* left, TreeNode* right) &#123; if(!left &amp;&amp; !right) return true; if(!left || !right || (left-&gt;val !&#x3D; right-&gt;val)) return false; return recursion(left-&gt;left, right-&gt;right) &amp;&amp; recursion(left-&gt;right, right-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; return recursion(root-&gt;left, root-&gt;right); &#125; &#125;; 相似题目100.相同的树解法和上述相同，甚至题目本身提供的函数就是一个递归函数的样子，直接写递归即可。 572.另一个树的子树在100.相同的树的基础上，以自身为递归函数再实现一个dfs即可。 class Solution &#123; public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(!p &amp;&amp; !q) return true; if(!p || !q || (p-&gt;val !&#x3D; q-&gt;val)) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125; bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123; return root &amp;&amp; (isSameTree(root, subRoot) || isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot)); &#125; &#125;; 222.完全二叉树的节点个数题干给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 示例 示例 1： 输入：root &#x3D; [1,2,3,4,5,6] 输出：6 示例 2： 输入: [] 输出: 0 解法基本思路：后序（递归）、层序（迭代） 最容易想到的解法就是层序遍历，得到深度h后，前 h - 1 就是满二叉树直接计算节点数，再加上最后一层队列中的元素数量即可。 另一种简单的写法就是后续遍历，用迭代的方式遍历一遍。 最后就是利用完全二叉树叶子节点均靠左的特性，仅遍历部分节点即可：分别向左节点的左侧和右节点的右侧向下遍历，来判断当前子树是否为满二叉树，直至找到一个满二叉子树时，结束递归（依旧是方法2的思路），返回该子树的节点数（直接计算可得）。 代码方法2 class Solution &#123; public: int countNodes(TreeNode* root) &#123; if (root &#x3D;&#x3D; NULL) return 0; &#x2F;&#x2F; 这里求了左子树的节点数 + 右子树节点数 + 中间节点数（1），实际是一个后序遍历过程 return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125; &#125;; 方法3 class Solution &#123; public: int calcDepth(TreeNode* cur, bool isLeft) &#123; int cnt &#x3D; 0; while(cur) &#123; cur &#x3D; isLeft ? cur-&gt;left : cur-&gt;right; ++cnt; &#125; return cnt; &#125; int countNodes(TreeNode* root) &#123; if(root &#x3D;&#x3D; nullptr) return 0; int lchildDep &#x3D; calcDepth(root-&gt;left, true); int rchildDep &#x3D; calcDepth(root-&gt;right, false); if(lchildDep &#x3D;&#x3D; rchildDep) return (2 &lt;&lt; lchildDep) - 1; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1; &#125; &#125;; 110.平衡二叉树题干平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 解法基本思路：后序（递归） 凡是求高度的，都是后序遍历；求深度的，都是前序遍历。 理论上，层序遍历都可实现，但是效率较低，尤其涉及回溯问题，不如迭代效果好。 代码class Solution &#123; public: int treeHeight(TreeNode* cur) &#123; if(cur &#x3D;&#x3D; nullptr) return 0; int lheight &#x3D; treeHeight(cur-&gt;left); if(lheight &#x3D;&#x3D; -1) return -1; int rheight &#x3D; treeHeight(cur-&gt;right); if(rheight &#x3D;&#x3D; -1) return -1; return abs(lheight - rheight) &gt; 1 ? -1 : max(lheight, rheight) + 1; &#125; bool isBalanced(TreeNode* root) &#123; return treeHeight(root) !&#x3D; -1; &#125; &#125;; 257.二叉树的所有路径题干给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 示例 示例 1： 输入：root &#x3D; [1,2,3,null,5] 输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] 示例 2： 输入：root &#x3D; [1] 输出：[&quot;1&quot;] 解法基本思路：前序（递归）、回溯 从根节点到叶子节点，自然用到了前序遍历：中左右的顺序——递归中先判断当前节点的终止条件，再进入左右子节点递归。 递归参数：除了节点指针，最后记录完整路径的数组（res），还需要一个用于回溯的数组（path），记录从根节点到当前节点经过的节点（记录值方便加入res）。当到达叶子节点后，需要数组回退一位，拐入父节点的另一个子节点（如果存在）。 终止条件：遇到叶子节点（左右子节点均为空），将回溯数组中经过的节点打印为字符串，加入res。 单层逻辑：回溯数组的压入和弹出。 代码class Solution &#123; public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; res) &#123; path.push_back(cur-&gt;val); if(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123; string pth &#x3D; &quot;&quot;; for(int i &#x3D; 0; i &lt; path.size() - 1; ++i) pth +&#x3D; to_string(path[i]) + &quot;-&gt;&quot;; pth +&#x3D; to_string(path[path.size() - 1]); res.push_back(pth); return; &#125; if(cur-&gt;left) &#123; traversal(cur-&gt;left, path, res); path.pop_back(); &#125; if(cur-&gt;right) &#123; traversal(cur-&gt;right, path, res); path.pop_back(); &#125; &#125; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; vector&lt;int&gt; path; traversal(root, path, res); return res; &#125; &#125;; 2023.6.15404.左叶子之和解法基本思路：后序（递归） 因为遍历的是叶子节点，所以用后序。终止条件为左叶子节点（判定条件需要在父节点上进行）。 代码class Solution &#123; public: int sumOfLeftLeaves(TreeNode* root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return 0; &#x2F;&#x2F; 终止条件 int lLeaf &#x3D; sumOfLeftLeaves(root-&gt;left); &#x2F;&#x2F; 左 if(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#x2F;&#x2F; 返回值是0不能直接递归，要把值取出来 lLeaf &#x3D; root-&gt;left-&gt;val; return lLeaf + sumOfLeftLeaves(root-&gt;right); &#x2F;&#x2F; 右 -&gt; 中 &#125; &#125;; 513.找树左下角的值题干给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 解法基本思路：层序（迭代） 在计算深度的同时，找最左侧的节点，很容易想到层序的队列，更加方便。 代码res &#x3D; q.front()-&gt;val; &#x2F;&#x2F; 在每次进入下一层时取队首值即可 112.路径总和题干给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 示例 示例 1： 输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22 输出：true 示例 2： 输入：root &#x3D; [], targetSum &#x3D; 0 输出：false 解法基本思路：前序（递归）、回溯 参考257.二叉树的所有路径，在其基础上计算一个和。不同的是，用于回溯的数组可以直接用这个和来代替。 递归参数：节点指针，去掉当前节点后的目标和（计算求和并不好处理，需要额外开辟变量，可以用当前和减去当前值，直接利用输入参数处理） 终止条件：遇到叶子节点（左右子节点均为空），且 当前剩余目标和被减到0 时，返回 true 单层逻辑：分别向左右子节点递归，有一个返回true就是true。 回溯： 代码中的回溯表现不明显，实际上当我们使用 去掉当前节点后的目标和 时，回溯表现在：当前叶子节点不是正确路径时，需要退回父节点进入其另一个子节点，此时 targetSum需要回溯至上一个状态（加回当前节点值）。 而这里直接将 targetSum - root-&gt;val 输入递归函数，省去了这一加减过程，从一个节点退出来可以直接进入另一个。导致在递归中不能直接减去当前值 targetSum - root-&gt;val 后判断是否等于0，而是直接判断两者是否相等，更加省事儿。 代码class Solution &#123; public: bool hasPathSum(TreeNode* root, int targetSum) &#123; if(root &#x3D;&#x3D; nullptr) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; root-&gt;val) return true; return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val); &#125; &#125;; 113.路径总和 Ⅱ题干给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 示例 示例 1： 输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22 输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 输入：root &#x3D; [], targetSum &#x3D; 1 输出：[] 解法基本思路：前序（递归）、回溯 这题纯是257.二叉树的所有路径 和112.路径总和的结合体，因为要找到所有的路径而不是判断有没有，就不能只用sum作为回溯条件了，需要开数组存路径。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt; &gt; res; void dfs(TreeNode* cur, int sum, vector&lt;int&gt;&amp; path) &#123; if(!cur) return; path.emplace_back(cur-&gt;val); if(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; sum &#x3D;&#x3D; cur-&gt;val) res.emplace_back(path); dfs(cur-&gt;left, sum - cur-&gt;val, path); dfs(cur-&gt;right, sum - cur-&gt;val, path); path.pop_back(); &#125; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; if(!root) return &#123;&#125;; vector&lt;int&gt; path; dfs(root, targetSum, path); return res; &#125; &#125;; 106.从中序和后序遍历序列构造二叉树题干给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 示例 1： 输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2： 输入：inorder &#x3D; [-1], postorder &#x3D; [-1] 输出：[-1] 解法基本思路：递归 根据中序和后序来构造二叉树，分为如下几步： 第一步：如果数组大小为零的话，说明是空节点 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点 第四步：切割中序数组，切成中序左数组和中序右数组 第五步：切割后序数组，切成后序左数组和后序右数组（切割后的两个数组长度依旧和中序的相等） 第六步：递归处理左区间和右区间 确定参数：在代码随想录中，切割数组后新开辟了数组来存储子数组，但这样较为浪费空间，实际只需要传入原数组和每次分割时的下标即可。又因为任意子树的中序和后序数组长度均相等，最后仅需五个参数用于递归即可（后序采用尾部下标是为了便于取当前子树根节点的值） 终止条件：传入的数组长度为0（len == 0）说明节点为空；为1表示该节点是叶子节点，没有子节点了，直接返回。 单层逻辑：计算当前节点在中序数组中的位置，以此为凭分割中序数组（分割为两个子树），再分割后序数组，分别传入数组下标构造子树，开始递归。 在分割数组时，始终遵从左闭右开原则。 代码class Solution &#123; public: TreeNode* buildChild(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int inHead, int postTail, int len) &#123; if(len &#x3D;&#x3D; 0) return nullptr; TreeNode* node &#x3D; new TreeNode(postorder[postTail]); if(len &#x3D;&#x3D; 1) return node; int seg; for(seg &#x3D; inHead; seg &lt; inHead + len; ++seg) if(inorder[seg] &#x3D;&#x3D; node-&gt;val) break; int rightLen &#x3D; inHead + len - seg - 1; node-&gt;left &#x3D; buildChild(inorder, postorder, inHead, postTail - rightLen - 1, seg - inHead); node-&gt;right &#x3D; buildChild(inorder, postorder, seg + 1, postTail - 1, rightLen); return node; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return buildChild(inorder, postorder, 0, postorder.size() - 1, postorder.size()); &#125; &#125;; 相关题目105.从前序与中序遍历序列构造二叉树解法基本思路：递归 和106一样的，就是前序是从序列头部取值作为当前节点值。 654.最大二叉树题干给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。 示例 示例 1： 输入：nums &#x3D; [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 示例 2： 输入：nums &#x3D; [3,2,1] 输出：[3,null,2,null,1] 解法基本思路：递归 递归思路同上，但是简化了操作，仅从一个数组中构建，也就少了一个参数。 代码class Solution &#123; public: TreeNode* buildChild(vector&lt;int&gt;&amp; nums, int head, int len) &#123; if(len &#x3D;&#x3D; 0) return nullptr; int idx &#x3D; head + 1, maxIdx &#x3D; head; for(; idx &lt; head + len; ++idx) if(nums[idx] &gt; nums[maxIdx]) maxIdx &#x3D; idx; TreeNode* node &#x3D; new TreeNode(nums[maxIdx]); node-&gt;left &#x3D; buildChild(nums, head, maxIdx - head); node-&gt;right &#x3D; buildChild(nums, maxIdx + 1, len - (maxIdx - head) - 1); return node; &#125; TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123; return buildChild(nums, 0, nums.size()); &#125; &#125;; 2023.6.18617.合并二叉树解法基本思路：前序（递归） 遍历两棵树和一棵树都一样，哪种遍历应该都可以，例如前序就遵从中左右的方式。 确立终止条件：两个节点有一个为空就直接返回另一个（另一个也空正好返回nullptr）。 代码class Solution &#123; public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if(root1 &#x3D;&#x3D; nullptr) return root2; if(root2 &#x3D;&#x3D; nullptr) return root1; root1-&gt;val +&#x3D; root2-&gt;val; root1-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left); root1-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right); return root1; &#125; &#125;; 700.二叉搜索树中的搜索解法基本思路：递归、BST 类似二分查找，做一个递归即可。 代码class Solution &#123; public: TreeNode* searchBST(TreeNode* root, int val) &#123; if(root &#x3D;&#x3D; nullptr || root-&gt;val &#x3D;&#x3D; val) return root; else if(root-&gt;val &lt; val) return searchBST(root-&gt;right, val); else return searchBST(root-&gt;left, val); return nullptr; &#125; &#125;; 98.验证二叉搜索树题干给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 解法基本思路：中序、递归、BST 在BST中，通过中序遍历得到的数组必然是有序的，可以以此来判断。递归时记录上一个节点的指针，用于比较。 代码class Solution &#123; private: TreeNode* pre &#x3D; nullptr; public: bool isValidBST(TreeNode* root) &#123; if(root &#x3D;&#x3D; nullptr) return true; bool left &#x3D; isValidBST(root-&gt;left); if(pre &amp;&amp; pre-&gt;val &gt;&#x3D; root-&gt;val) return false; pre &#x3D; root; bool right &#x3D; isValidBST(root-&gt;right); return left &amp;&amp; right; &#125; &#125;; 530.二叉搜索树的最小绝对差题干给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小绝对差值 。 解法基本思路：中序、递归、BST 思路和上题98一致，只是比较大小改为了计算差值。 这里需要注意递归的第一步是确定递归参数，因为主函数要返回int，和void简单递归相比较为麻烦，因此不直接用主函数递归。 代码class Solution &#123; private: int minSub &#x3D; INT_MAX; TreeNode* pre &#x3D; nullptr; public: void traversal(TreeNode* cur) &#123; if(cur &#x3D;&#x3D; nullptr) return; traversal(cur-&gt;left); if(pre) minSub &#x3D; min(minSub, cur-&gt;val - pre-&gt;val); pre &#x3D; cur; traversal(cur-&gt;right); &#125; int getMinimumDifference(TreeNode* root) &#123; traversal(root); return minSub; &#125; &#125;; 501.二叉搜索树中的众数题干给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 解法基本思路：中序、递归、BST 依旧承接上两题98、530的思路，中间操作改为了维护众数数组。 代码class Solution &#123; private: TreeNode* pre &#x3D; nullptr; int cnt &#x3D; 0, maxNum &#x3D; 0; public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; res) &#123; if(cur &#x3D;&#x3D; nullptr) return; traversal(cur-&gt;left, res); if(pre &#x3D;&#x3D; nullptr) cnt &#x3D; 1; else if(pre-&gt;val &#x3D;&#x3D; cur-&gt;val) ++cnt; else cnt &#x3D; 1; pre &#x3D; cur; if(cnt &#x3D;&#x3D; maxNum) res.push_back(cur-&gt;val); else if (cnt &gt; maxNum) &#123; maxNum &#x3D; cnt; res.clear(); res.push_back(cur-&gt;val); &#125; traversal(cur-&gt;right, res); &#125; vector&lt;int&gt; findMode(TreeNode* root) &#123; vector&lt;int&gt; res; traversal(root, res); return res; &#125; &#125;; 236.二叉树的最近公共祖先题干最近公共祖先定义为：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。 解法基本思路：后序、递归 最大深度——&gt;高度尽可能低——&gt;从下往上（后序）。 确定递归参数：可以直接使用主函数。 确定终止条件：这里需要和单层逻辑一起思考，遇到p、q就返回的作用是什么？ 单层递归逻辑： 回溯的最开始就是深入到了最左叶子节点，此时递归往下时左右均为空，返回NULL（状态1）；那么该叶节点的父节点得到的左节点递归返回值就是NULL；同理右节点也是如此；也就是父节点也处于状态1，返回NULL；也就是说一路向上回溯时，只有找到p、q，返回值才不为空。 假设找到了 q，此时 q的父节点接到的其中一个子节点不为NULL了，又延伸出了两种情况： 另一个子节点是 p，那么最近公共祖先就是该节点，单层逻辑的第一步：左右都不空，直接返回当前递归中的root节点。 p还在上面，此时为单层逻辑的另一步：有一个子节点不空，就返回这个不空的节点。 注意这里返回只是传递给了上层递归的left和right。那么接着往下走，还是两种情况： 对于1，公共祖先已经找到了，那么对于整棵树的根节点，也就是第一层递归来说，拿到的必然是一个子节点空一个不空的递归结果，最后顺利返回不空的那个节点，就是一路传上来的root。 对于2，在往上的过程中，找到了 p，那么p的父节点此时得到了两个非空返回值，那么就等同于情况1了，返回当前这个root，也就是最近公共祖先了。 上述情况均为p、q在不同分支上时。若p、q在同一分支时，应取两者高度高的为最近公共祖先。这也是要把 当前节点 == p、q设为终止条件的原因：若处于同一分支，在找到的一开始可以跳过再往这个分支下遍历的动作，因为已经找到了祖先。那么回到第一层递归时，也只有一个分支返回非空，也就返回了正确的公共祖先。 代码class Solution &#123; public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root &#x3D;&#x3D; p || root &#x3D;&#x3D; q || root &#x3D;&#x3D; NULL) return root; TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q); if(left &amp;&amp; right) return root; if(left &#x3D;&#x3D; NULL) return right; return left; &#125; &#125;; 2023.6.19235.二叉搜索树的公共祖先解法基本思路：LCA（Lowest Common Ancestor）、BST 根据BST的性质，对于任意节点x，其左子树中的所有节点值都小于x的值，右子树中的所有节点值都大于x的值。因此，如果两个目标节点分别位于x的左右子树中，那么x就是它们的LCA。 代码class Solution &#123; public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); else return root; &#125; &#125;; 701.二叉搜索树的插入操作解法基本思路：递归、迭代、BST 根据BST性质，一直比较要插入节点的值与当前节点的值的大小，大了往右小了往左，直至碰到空节点，那就是该呆的地方了。 这里用递归的返回值实现父子节点赋值操作，正常情况，在进入分支时，该分支的返回值都是root，即子节点本身，不影响树结构，直至空节点时，才构建要插入的节点连上。 迭代则需要记录父节点的指针，才能完成插入操作。 代码class Solution &#123; public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(root &#x3D;&#x3D;nullptr) return new TreeNode(val); if(root-&gt;val &gt; val) root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val); else root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val); return root; &#125; &#125;; class Solution &#123; public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(root &#x3D;&#x3D; nullptr) return new TreeNode(val); TreeNode* cur &#x3D; root; TreeNode* parent &#x3D; root; while(cur) &#123; parent &#x3D; cur; if(cur-&gt;val &gt; val) cur &#x3D; cur-&gt;left; else cur &#x3D; cur-&gt;right; &#125; if(parent-&gt;val &gt; val) parent-&gt;left &#x3D; new TreeNode(val); else parent-&gt;right &#x3D; new TreeNode(val); return root; &#125; &#125;; 450.删除二叉搜索树的节点解法基本思路：递归、迭代、BST 递归思路和上题701相同，只是插入节点变为删除，涉及到了结构调整，情况复杂一些。 代码class Solution &#123; public: TreeNode* deleteNode(TreeNode* root, int key) &#123; if(root &#x3D;&#x3D; nullptr) return root; if(root-&gt;val &gt; key) root-&gt;left &#x3D; deleteNode(root-&gt;left, key); else if(root-&gt;val &lt; key) root-&gt;right &#x3D; deleteNode(root-&gt;right, key); else &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; &#x2F;&#x2F; 全空，叶子节点不用调整结构 delete root; return nullptr; &#125; if(!root-&gt;left) &#123; &#x2F;&#x2F; 只有右子树，把右子树挪上来 TreeNode* tmp &#x3D; root-&gt;right; delete root; return tmp; &#125; if(!root-&gt;right) &#123; &#x2F;&#x2F; 只有左子树，把左子树挪上来 TreeNode* tmp &#x3D; root-&gt;left; delete root; return tmp; &#125; else &#123; &#x2F;&#x2F; 左右子树均有，左子树归入右子树的最左侧叶子节点下，右子树上挪 TreeNode* cur &#x3D; root-&gt;right; while(cur-&gt;left) cur &#x3D; cur-&gt;left; cur-&gt;left &#x3D; root-&gt;left; TreeNode* tmp &#x3D; root-&gt;right; delete root; return tmp; &#125; &#125; return root; &#125; &#125;; 669.修剪二叉搜索树题干给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在**[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构** (即如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 解法基本思路：递归、迭代、BST 思路还是上两题701和450的思路，但其实比450操作要少很多，因为只保留范围内，意味着左边某个小于low的节点开始，只保留它的右子树，右边同理。那么只需把子树接到原本节点的位置即可。 迭代也是相同的思路，但是比递归要多处理一步，即先确定root节点在范围内。 代码class Solution &#123; public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; if(root &#x3D;&#x3D; nullptr) return root; if(root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high); if(root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high); root-&gt;left &#x3D; trimBST(root-&gt;left, low, high); root-&gt;right &#x3D; trimBST(root-&gt;right, low, high); return root; &#125; &#125;; class Solution &#123; public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; if(root &#x3D;&#x3D; nullptr) return nullptr; while(root &amp;&amp; (root-&gt;val &lt; low || root-&gt;val &gt; high)) &#123; if(root-&gt;val &lt; low) root &#x3D; root-&gt;right; else root &#x3D; root-&gt;left; &#125; TreeNode* cur &#x3D; root; while(cur) &#123; while(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; low) &#123; cur-&gt;left &#x3D; cur-&gt;left-&gt;right; &#125; cur &#x3D; cur-&gt;left; &#125; cur &#x3D; root; while(cur) &#123; while(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; high) &#123; cur-&gt;right &#x3D; cur-&gt;right-&gt;left; &#125; cur &#x3D; cur-&gt;right; &#125; return root; &#125; &#125;; 108.将有序数组转化为二叉搜索树题干给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 解法基本思路：递归、BST 类似于二分查找的递归的反向操作。取中间值为节点，然后分为两个子数组，继续在子数组中取中间值为子节点……直至为空。 这题用迭代法会较为麻烦，因为需要开辟多个队列存储数组下标和节点信息。 代码class Solution &#123; public: TreeNode* sortedArrayToSubBST(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if(l &gt; r) return nullptr; int mid &#x3D; l + (r - l) &#x2F; 2; TreeNode* nd &#x3D; new TreeNode(nums[mid]); nd-&gt;left &#x3D; sortedArrayToSubBST(nums, l, mid - 1); nd-&gt;right &#x3D; sortedArrayToSubBST(nums, mid + 1, r); return nd; &#125; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return sortedArrayToSubBST(nums, 0, nums.size() - 1); &#125; &#125;; 538.把二叉搜索树转换为累加树题干给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 解法基本思路：递归、BST、反中序 需要理解累加的顺序，BST是有序的，也就是最大的值（右下角）不用累加，之后是其父节点，再后是父节点的左子树的最右节点，都是在前面和的基础上加上自身值。可以发现遍历顺序为右——&gt;中——&gt;左，也就是中序的反过来，在递归中很好写，换下处理顺序即可。 迭代也是类似于中序的迭代写法，更换左右顺序，替换处理方式即可。 代码class Solution &#123; private: int preSum &#x3D; 0; public: void traversal(TreeNode* cur) &#123; if(cur &#x3D;&#x3D; nullptr) return; traversal(cur-&gt;right); preSum +&#x3D; cur-&gt;val; cur-&gt;val &#x3D; preSum; traversal(cur-&gt;left); &#125; TreeNode* convertBST(TreeNode* root) &#123; preSum &#x3D; 0; traversal(root); return root; &#125; &#125;; 2023.6.2077.组合题干给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。 解法基本思路：回溯、Lambda 组合问题，常用回溯算法解决，即递归暴力枚举。这里用的是Lambda函数的递归写法，注意这里的 ++idx 和普通函数中传参 idx + 1 的区别。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; auto backTracking &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123; if(path.size() &#x3D;&#x3D; k) &#123; res.push_back(path); return; &#125; for(int i &#x3D; idx; i &lt;&#x3D; n; ++i) &#123; path.push_back(i); self(self, ++idx); path.pop_back(); &#125; &#125; ]() &#123; circle(circle, 1); &#125;; backTracking(); return res; &#125; &#125;; 相关题目216.组合总和 Ⅲ解法基本思路：回溯、Lambda 跟77思路一样，无非是递归的终止条件改为： path 元素数为k时，该数组和为n。循环改为固定9。 17.电话号码的字母组合解法基本思路：回溯、Lambda 相比于上两题77和216，这题稍微复杂一些，因为是一个双层的循环，这里注意的是 idx++ 的位置，因为控制的是外层循环的下标（即递归函数看作外层循环），因此要加在for循环前。 代码class Solution &#123; public: const string numMap[8] &#x3D; &#123; &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot; &#125;; vector&lt;string&gt; letterCombinations(string digits) &#123; if(digits.length() &#x3D;&#x3D; 0) return &#123;&#125;; vector&lt;string&gt; res; string path; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123; if(path.length() &#x3D;&#x3D; digits.length()) &#123; res.push_back(path); return; &#125; string str &#x3D; numMap[digits[idx++] - &#39;2&#39;]; for(int i &#x3D; 0; i &lt; str.length(); ++i) &#123; path.push_back(str[i]); self(self, idx); path.pop_back(); &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTrack(); return res; &#125; &#125;; 39.组合总和题干给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 解法基本思路：回溯、Lambda 跟上面三题同样思路，区别仅在于递归参数的传入上，因为可以重复选取，就不用自加idx了。但是依旧要注意，当最外层使用第二个数时，后面的也只能从第二个开始往后找，因为第一个数的组合已经列完了，再列是重复的，所以以for循环的 i 作为 idx的输入来控制搜索范围。 若觉得 accumulate计算和会慢，也可以将 target加入回溯中，在 self前后自减自加即可，终止条件就只需要比较 == 0 和 &lt; 0 了。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; path; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123; if(accumulate(path.begin(), path.end(), 0) &gt; target) return; if(accumulate(path.begin(), path.end(), 0) &#x3D;&#x3D; target) &#123; res.push_back(path); return; &#125; for(int i &#x3D; idx; i &lt; candidates.size(); ++i) &#123; path.push_back(candidates[i]); self(self, i); path.pop_back(); &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTrack(); return res; &#125; &#125;; 40.组合总和 Ⅱ题干给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例 示例 1： 输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] 示例 2： 输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5, 输出: [ [1,2,2], [5] ] 解法基本思路：回溯、Lambda 这题有些绕，数组中有重复的数字，不同位置数字相同的元素是可以在一个组合内使用的，但是解集中不能有重复的组合。如示例1，有俩1，按照正常只往后遍历，可以有116，125，但也会出现215这种重复情况。因此需要去重。 针对乱序数组，又要下标又要数值判断过于麻烦，可以先对原数组排序。那么在只往后遍历的原则下，组合必然也是有序的，那么如果存在相同数字，在该数字开头的组合已经列完的情况下，后面相同的都直接跳过： candidates[i] == candidates[i - 1] 。但如果只有这一个条件，会发现，116这样的情况会被舍去，因此还需要加上限定条件，表明为同层使用（组合的同一个位置）而非同枝（即递归的深度中相同），也就是 i &gt; idx，说明是同一层的循环改变里跳过的。 但是一提交还是超时的，那就需要继续剪枝： 可以发现，当数组很大，但是和很小时，如果不在很早的地方结束递归，会出现非常多次无效递归，因此在循环中用 target &gt; 0 中止掉。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; sort(candidates.begin(), candidates.end()); auto backTracking &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123; if(0 &#x3D;&#x3D; target) &#123; res.push_back(path); return; &#125; for(int i &#x3D; idx; i &lt; candidates.size() &amp;&amp; target &gt; 0; ++i) &#123; if(i &gt; idx &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1]) continue; path.push_back(candidates[i]); target -&#x3D; candidates[i]; self(self, i + 1); target +&#x3D; candidates[i]; path.pop_back(); &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTracking(); return res; &#125; &#125;; 2023.6.21131.分割回文串题干给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 解法基本思路：分割、回溯、Lambda 分割问题和组合问题其实是一样的：对字符串aab，先分a出来，然后在ab中继续分；然后分ab出来，在a中继续分。。。相当于之前思路中的for循环对应第一层分割，即先分a、ab、aab，用idx控制，递归用于深层遍历。 判断回文串用双指针法，如果不是回文串直接跳过当层遍历，实现剪枝。 代码class Solution &#123; public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; path; auto isPalStr &#x3D; [](string str, int l, int r) -&gt; bool &#123; for(int i &#x3D; l, j &#x3D; r; i &lt; j; ++i, --j) if(str[i] !&#x3D; str[j]) return false; return true; &#125;; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123; if(idx &gt;&#x3D; s.size()) &#123; res.push_back(path); return; &#125; for(int i &#x3D; idx; i &lt; s.size(); ++i) &#123; if(isPalStr(s, idx, i)) path.push_back(s.substr(idx, i - idx + 1)); else continue; self(self, i + 1); path.pop_back(); &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTrack(); return res; &#125; &#125;; 93.复原IP地址题干有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 解法基本思路：分割、回溯、Lambda for循环用于控制层中遍历，即在字符串上遍历；维护一个计数器cnt，用于计算深度，作为终止条件（到第四层就应该结束了，此时 cnt == 3）。 每次选取子串时，都需要判断有效性，若当前子串无效，那么同层遍历当前子串和递归后续子串就都没必要了，直接break，继续遍历上一个子串。 判断有效性时，要对字符串首的0做出判断（长度不为1时）；以及当前三个子串就将字符串中的数字占满时，第四个子串为空，按照递归的传参来说，会出现 l == r + 1的情况，也需要排除避免越界。 最开头排除长度在4-12之外的字符串，算作剪枝。 代码class Solution &#123; public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; if(s.size() &lt; 4 || s.size() &gt; 12) return &#123;&#125;; vector&lt;string&gt; res; auto isValid &#x3D; [](string str, int l, int r) -&gt; bool &#123; if(l &gt; r) return false; if(str[l] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; l !&#x3D; r) return false; int num &#x3D; stoi(str.substr(l, r - l + 1)); return num &gt;&#x3D; 0 &amp;&amp; num &lt; 256; &#125;; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx, int cnt) -&gt; void &#123; if(cnt &#x3D;&#x3D; 3) &#123; if(isValid(s, idx, s.size() - 1)) res.push_back(s); return; &#125; for(int i &#x3D; idx; i &lt; s.size(); ++i) &#123; if(isValid(s, idx, i)) &#123; s.insert(s.begin() + i + 1, &#39;.&#39;); ++cnt; self(self, i + 2, cnt); --cnt; s.erase(s.begin() + i + 1); &#125; else break; &#125; &#125; ]() &#123; circle(circle, 0, 0); &#125;; backTrack(); return res; &#125; &#125;; 2023.6.2278.子集题干给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 解法基本思路：子集、回溯、Lambda 子集问题本质和组合分割是差不多的，都是for循环横向控制层中遍历，递归纵向控制深度遍历。 区别就在于子集不再是递归到叶子节点终止了才要将结果加入数组，而是合适的都要加，也就是处理部分放在for循环和终止条件外执行。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123; res.push_back(path); if(idx &gt; nums.size()) return; for(int i &#x3D; idx; i &lt; nums.size(); ++i) &#123; path.push_back(nums[i]); self(self, i + 1); path.pop_back(); &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTrack(); return res; &#125; &#125;; 相关题目90.子集 Ⅱ题干给你一个整数数组 nums ，其中可能包含重复元素 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 解法基本思路：子集、回溯、Lambda 这题类似于之前的40.组合 Ⅱ，都需要对重复数字去重。因此先对数组排序，之后在for循环中加入判断即可。 代码sort(nums.begin(), nums.end()); if(i &gt; idx &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; 491.递增子序列题干给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 解法基本思路：子集、回溯、Lambda 因为要找递增子序列，所以不能对原数组直接排序了，需要采用其他方式去重： 可以在递归开始前先做预处理——找到 **nums[i]**上一次出现的位置，记为 **pre[i]**。 那么在同层遍历中，只需要判断 nums[i] 是否在当前位置 i 和本层的起始位置 idx 之间出现过，即 idx &lt;= pre[i] &amp;&amp; pre[i] &lt; i。 代码 class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; int pre[15]; for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; pre[i] &#x3D; -1; for(int j &#x3D; i - 1; j &gt;&#x3D; 0; --j) &#123; if(nums[i] &#x3D;&#x3D; nums[j]) &#123; pre[i] &#x3D; j; break; &#125; &#125; &#125; auto isRepeat &#x3D; [pre](int l, int r) -&gt; bool &#123; return l &lt;&#x3D; pre[r] &amp;&amp; pre[r] &lt; r; &#125;; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123; if(path.size() &gt; 1) res.push_back(path); for(int i &#x3D; idx; i &lt; nums.size(); ++i) &#123; if(!path.empty() &amp;&amp; nums[i] &lt; path.back() || isRepeat(idx, i)) continue; path.push_back(nums[i]); self(self, i + 1); path.pop_back(); &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTrack(); return res; &#125; &#125;; 46.全排列题干给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 解法基本思路：排列、回溯、Lambda 排列会用到数组中所有元素，因此直到递归到最后一层才会得到返回结果——由此可以确立终止条件。 在同层遍历时，数组中位置在当前元素之前的元素同样会被用到——for循环从0开始，而不是维护idx。 在纵向递归时，上层已经加入结果的元素需要被标记，从而可以在当前层的for循环中被跳过。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;bool&gt; used(nums.size(), false); auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self) -&gt; void &#123; if(path.size() &#x3D;&#x3D; nums.size()) &#123; res.push_back(path); return; &#125; for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; if(used[i]) continue; used[i] &#x3D; true; path.push_back(nums[i]); self(self); path.pop_back(); used[i] &#x3D; false; &#125; &#125; ]() &#123; circle(circle); &#125;; backTrack(); return res; &#125; &#125;; 相关题目47.全排列 Ⅱ题干给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 解法基本思路：排列、回溯、Lambda 在包含重复数字的情况下，都需要去重。在46.全排列的基础上，先对数组排序以便于去重。 然后增加判定条件，注意在判断相同元素之外，前提是上一个元素是没被使用的情况下。 代码sort(nums.begin(), nums.end()); if(used[i] || i &gt; 0 &amp;&amp; !used[i - 1] &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; 332.重新安排行程题干给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。 例如，行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。 示例 &#x2F;&#x2F; 示例1： 输入：tickets &#x3D; [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]] 输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;] &#x2F;&#x2F; 示例2： 输入：tickets &#x3D; [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]] 输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;] 解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。 解法基本思路：排列、回溯、Lambda 代码随想录中，使用了 unordered_map 来记录映射关系，其中包含 map自动实现排序。但实际上可以更节省空间——直接按照目的地大小对输入数组进行排序，之后的操作可以看作是一个全排列过程，并且只需要找到第一个结果就一定是最佳结果，直接return就行。 首先将起始地 “JKF” 加入路径，之后遍历每张票，跳过已经使用过的或是出发地和路径末尾地点不符的，之后就是回溯流程了，路径直接添加目的地即可。直至找到第一个叶节点，就结束了。 终止条件：因为每张票都需要使用，因此一共 n 条路径，必然连接了 n + 1 个城市，因此 path.size() == tickets.size() + 1 。 代码class Solution &#123; public: vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123; sort(tickets.begin(), tickets.end(), [](vector&lt;string&gt;&amp; a, vector&lt;string&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125; ); vector&lt;string&gt; path; vector&lt;bool&gt; used(tickets.size(), false); path.push_back(&quot;JFK&quot;); auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self) -&gt; bool &#123; if(path.size() &#x3D;&#x3D; tickets.size() + 1) return true; for(int i &#x3D; 0; i &lt; tickets.size(); ++i) &#123; if(used[i] || tickets[i][0] !&#x3D; path.back()) continue; used[i] &#x3D; true; path.push_back(tickets[i][1]); if(self(self)) return true; path.pop_back(); used[i] &#x3D; false; &#125; return false; &#125; ]() &#123; circle(circle); &#125;; backTrack(); return path; &#125; &#125;; 51.N皇后题干按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例 &#x2F;&#x2F; 示例1： 输入：n &#x3D; 4 输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 &#x2F;&#x2F; 示例2： 输入：n &#x3D; 1 输出：[[&quot;Q&quot;]] 解法基本思路：排列、回溯、Lambda 依旧是排列的思想——for循环控制横向遍历，递归控制纵向递归。 因为每到下一行，四个位置都需要判断可能性，因此是排列，for循环 0 - n 。递归需要一个额外参数 row记录当前所在行。那么终止条件显然是n行都遍历完—— row == n（row从0开始，便于下标取值）。 每次都先进行有效判断（对正上方和左右45°上方判断有无q即可），有效才能进入下层递归。 代码class Solution &#123; public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; path(n, string(n, &#39;.&#39;)); auto isValid &#x3D; [&amp;path, n](int row, int col) -&gt; bool &#123; for(int i &#x3D; 0; i &lt; row; ++i) if(path[i][col] &#x3D;&#x3D; &#39;Q&#39;) return false; for(int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0; --i, --j) if(path[i][j] &#x3D;&#x3D; &#39;Q&#39;) return false; for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; --i, ++j) if(path[i][j] &#x3D;&#x3D; &#39;Q&#39;) return false; return true; &#125;; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self, int row) -&gt; void &#123; if(row &#x3D;&#x3D; n) &#123; res.push_back(path); return; &#125; for(int i &#x3D; 0; i &lt; n; ++i) &#123; if(isValid(row, i)) &#123; path[row][i] &#x3D; &#39;Q&#39;; self(self, row+1); path[row][i] &#x3D; &#39;.&#39;; &#125; &#125; &#125; ]() &#123; circle(circle, 0); &#125;; backTrack(); return res; &#125; &#125;; 37.解数独题干编写一个程序，通过填充空格来解决数独问题。数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 &#x2F;&#x2F; 示例1： 输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]] 解法基本思路：二维递归、回溯、Lambda 这题是回溯合集中最抽象的一题，跟之前的全都不在一个模式。之前的问题都是在一维数组上进行二维操作，在横向选择的基础上向纵向推进。例如排列，可以看作是从一维数组中选取一个数，放在一个相同长度的一维数组的第一位，然后再从剩下数中选取一个放在新数组第二位……以此类推，最后填满表示产生一个结果，然后回溯去生成其他结果。 本题实则为一种另类的二维操作：从 [1, 9] 的一维数组中选取一个数，放在一个二维数组的第一位，然后再九个数中选取一个放在二维数组第二位……以此类推，最后填满表示产生一个结果。 但因为在遍历过程中是会对填入数字进行有效判断的，因此产生的结果必然是正确的，就不需要接着回溯，直接return即可（最外层循环外的 return true），因此递归函数需要有 bool 返回值，用于一层层向上中断递归过程（递归函数判断的 return true）。因此本题递归也不需要终止条件，这就是终止条件了。 显然还存在一个问题，当某个格子9个数字都不是有效数字时，说明作为判断条件之一的前面某一格的数字填错了，需要回去改，那么直接 return false ，回溯修改之前的数字。 代码class Solution &#123; public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; auto isValid &#x3D; [&amp;](int row, int col, char num) -&gt; bool &#123; for(char c : board[row]) if(c &#x3D;&#x3D; num) return false; for(int i &#x3D; 0; i &lt; 9; ++i) if(board[i][col] &#x3D;&#x3D; num) return false; int idy &#x3D; row &#x2F; 3 * 3, idx &#x3D; col &#x2F; 3 * 3; for(int i &#x3D; idy; i &lt; idy + 3; ++i) for(int j &#x3D; idx; j &lt; idx + 3; ++j) if(board[i][j] &#x3D;&#x3D; num) return false; return true; &#125;; auto backTrack &#x3D; [ circle &#x3D; [&amp;](auto&amp;&amp; self) -&gt; bool &#123; for(int i &#x3D; 0; i &lt; 9; ++i) &#123; for(int j &#x3D; 0; j &lt; 9; ++j) &#123; if(board[i][j] !&#x3D; &#39;.&#39;) continue; for(char k &#x3D; &#39;1&#39;; k &lt;&#x3D; &#39;9&#39;; ++k) &#123; if(isValid(i, j, k)) &#123; board[i][j] &#x3D; k; if(self(self)) return true; board[i][j] &#x3D; &#39;.&#39;; &#125; &#125; return false; &#x2F;&#x2F; 核心 &#125; &#125; return true; &#125; ]() &#123; circle(circle); &#125;; backTrack(); &#125; &#125;; 2023.6.24455.分发饼干解法基本思路：贪心、双指针 贪心思路：小的饼干尽可能喂给最小胃口的孩子（局部），以达到喂最多小孩的目的（全局）。 代码class Solution &#123; public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int res &#x3D; 0; for(int i &#x3D; 0; i &lt; s.size(); ++i) if(res &lt; g.size() &amp;&amp; g[res] &lt;&#x3D; s[i]) ++res; return res; &#125; &#125;; 53.最大子数组和题干给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。 解法基本思路：贪心 贪心就贪在here这里。因为当此时的连续和为负数时，加上下一个数只会拉低总和，因此不如直接从下一个数开始重新累加，反而更大，这就是局部最优。 但这里要注意每一步都需要保存当前的连续和（在重置之前），因为存在最大和为负数的情况。 代码class Solution &#123; public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int res &#x3D; INT_MIN, cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123; cnt +&#x3D; nums[i]; if(cnt &gt; res) res &#x3D; cnt; if(cnt &lt; 0) cnt &#x3D; 0; &#x2F;&#x2F; here &#125; return res; &#125; &#125;; 2023.6.25122.买卖股票的最佳时机解法基本思路：贪心、数学 首先需要找到一个规律：如果第一天买，第三天卖，收益为 prices[2] - prices[0] = （prices[2] - prices[1]）+（prices[1] - prices[0]）。也就是说，无论哪天买卖，一次买卖的收益是持有期间的每日收益的总和。 贪心思路：负数会降低收益，因此只选每日收益为正的时间段持有，就是最高收益。 代码class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; prices.size() - 1; ++i) if(prices[i+1] - prices[i] &gt; 0) res +&#x3D; prices[i+1] - prices[i]; return res; &#125; &#125;; 55.跳跃游戏解法基本思路：贪心 贪心思路：将问题转化为判断移动范围能否覆盖至终点，循环每移动一个单位，就尝试更新最大的覆盖范围。 不用考虑如何到那个覆盖最大范围的点，只要知道最大范围是哪儿。在这个范围内就可以继续向后遍历。不用担心数组越界，当覆盖范围超过数组长度时，直接return。若因为0卡在原地不动，到 maxRange 直接就结束循环了。 代码class Solution &#123; public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int maxRange &#x3D; 0; for(int i &#x3D; 0; i &lt;&#x3D; maxRange; ++i) &#123; maxRange &#x3D; max(maxRange, nums[i] + i); if(maxRange &gt;&#x3D; nums.size() - 1) return true; &#125; return false; &#125; &#125;; 45.跳跃游戏 Ⅱ解法基本思路：贪心 贪心思路：同55，依旧是更新最大的覆盖范围。 区别在于要统计最小步数，也就是每一步要走的尽可能大——&gt;更新覆盖范围的最小次数。也就是在每一个覆盖范围内走的尽可能多（尽量走到范围边缘再更新）。 for循环是从头到尾的，max函数用于统计下一步的最优情况，当遍历到达本次边界时，再增加步数（可能不是在这个下标处跳的，但是没有区别不需要关心）。 代码class Solution &#123; public: int jump(vector&lt;int&gt;&amp; nums) &#123; int res &#x3D; 0, cur &#x3D; 0, next &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size() - 1; ++i) &#123; next &#x3D; max(next, nums[i] + i); if(i &#x3D;&#x3D; cur) &#123; cur &#x3D; next; ++res; &#125; &#125; return res; &#125; &#125;; 1005.K 次取反后最大化的数组和解法基本思路：贪心 贪心思路：存在两种情况的贪心。 若是 k &lt;= 负数的数量，那么每次取当前最大的负数变正； 若k大于负数数量，则每次取最小的非负数变负：这里存在优化，当变负了后，若k还大于0，此时应按照1的贪心来，将负数变正。那么可以得到结论——当剩余k值为偶数时，可以直接忽略，为奇数则将最小非负数变负。 我的代码相比代码随想录做了进一步优化：将求和和修改同步进行。那么若k最后剩余为奇数，只需要和减去最小非负数的两倍即可。 代码class Solution &#123; public: int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123; int res &#x3D; 0; sort(nums.begin(), nums.end(), [](int a, int b) &#123; return abs(a) &gt; abs(b); &#125;); for(int&amp; n : nums) &#123; if(n &lt; 0 &amp;&amp; k-- &gt; 0) n *&#x3D; -1; res +&#x3D; n; &#125; if(k % 2) res -&#x3D; nums[nums.size() - 1] * 2; return res; &#125; &#125;; 134.加油站解法基本思路：贪心 首先明确：只有总油量大于等于总消耗，才能跑完一圈；当前油量小于下一路程消耗油量时，跑不过去。 抽象为数学计算就是：设第 i站到 i+1站剩余油量 gas[i] - cost[i] ，只有所有的剩余油量和大于等于0才能跑完。从第0站作为出发点开始累加剩余油量的和，一旦到第 i+1站时和小于0了，说明从之前的任意站出发都是到不了这一站的（可证明）。那么就只能以第 i+1站重新作为出发点，重新累加和。 局部最优：每走一段，累加和一定大于等于0。 代码class Solution &#123; public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int res &#x3D; 0, sum &#x3D; 0, total &#x3D; 0; for(int i &#x3D; 0, n &#x3D; gas.size(); i &lt; n; ++i) &#123; sum +&#x3D; gas[i] - cost[i]; total +&#x3D; gas[i] - cost[i]; if(sum &lt; 0) &#123; res &#x3D; i + 1; sum &#x3D; 0; &#125; &#125; return total &lt; 0 ? -1 : res; &#125; &#125;; 135.分发糖果解法基本思路：贪心 先确定一边（假设左边） 局部最优：只要比左边的分数高，糖果数就为左边的+1。 再确定另一边（此时循环的方向必须反过来，因为数组中分数存在递增和递减两种情况，假设两遍都是左到右的循环，第二次当碰到递减段时，段中的前几个值都是不对的，因为都比右面的大，都会+1，而左边的已经遍历过了不能继续加了。遍历方向仅能解决递增段，要不出错就需要双向遍历。） 局部最优：此时糖果数已经比左边大了，取 糖果数 和 **右边糖果数+1 **中最大的，就一定比两边都大。 代码class Solution &#123; public: int candy(vector&lt;int&gt;&amp; ratings) &#123; vector&lt;int&gt; candy(ratings.size(), 1); for(int i &#x3D; 1; i &lt; ratings.size(); ++i) if(ratings[i] &gt; ratings[i - 1]) candy[i] +&#x3D; candy[i - 1]; for(int i &#x3D; ratings.size() - 2; i &gt;&#x3D; 0; --i) if(ratings[i] &gt; ratings[i + 1]) candy[i] &#x3D; max(candy[i], candy[i + 1] + 1); return accumulate(candy.begin(), candy.end(), 0); &#125; &#125;; 860.柠檬水找零解法基本思路：贪心、模拟 基本就是模拟判断，用到贪心的地方大概是20找零？ 局部最优：尽量用大面额的10去找，因为5还需要用于给10找零。 代码class Solution &#123; public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; int five &#x3D; 0, ten &#x3D; 0; for(int i &#x3D; 0; i &lt; bills.size(); ++i) &#123; if(bills[i] &#x3D;&#x3D; 5) ++five; else if(bills[i] &#x3D;&#x3D; 10) &#123; if(five &lt;&#x3D; 0) return false; --five; ++ten; &#125; else &#123; if(ten &gt; 0 &amp;&amp; five &gt; 0) &#123; --five; --ten; &#125; else if(five &gt; 2) five -&#x3D; 3; else return false; &#125; &#125; return true; &#125; &#125;; 406.根据身高重建队列解法基本思路：贪心、list 当存在两个维度需要处理时，先确定一个基本维度再处理另一个。这里显然是按照身高排序更合适，k排序结束依旧是不符合k条件的序列。那么首先按照身高从大到小排序，相等的k小的在前面。 局部最优：优先按身高更高的人的k来插入，后续的插入不会影响之前已完成的，因为都比已完成的更矮。 代码这里先用 list存而非 vector的原因在于 vector的插入操作是 O(n) 时间，而 list底层为链表，插入为 O(1) 。并且 vector在插入时，通过重新申请一个二倍空间大小的数组并将原数组拷贝过去实现扩容，这样会很慢。 注意 list的迭代器是双向迭代器，而不是随机访问迭代器，只支持指针逐一迭代寻址。 class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; sort(people.begin(), people.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; return a[0] &gt; b[0] || (a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1]); &#125;); list&lt;vector&lt;int&gt;&gt; res; for(int i &#x3D; 0; i &lt; people.size(); ++i) &#123; int pos &#x3D; people[i][1]; auto iter &#x3D; res.begin(); while(pos--) ++iter; res.insert(iter, people[i]); &#125; return vector&lt;vector&lt;int&gt;&gt;(res.begin(), res.end()); &#125; &#125;; 2023.6.26452.用最少数量的箭引爆气球解法基本思路：贪心 其实就是求有交集的范围的最小组合数。 局部最优：让尽可能多的范围处于同一组合中。即在按左边界升序排序的情况下，维护范围的最小右边界。 代码class Solution &#123; public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123; return a[0] &lt; b[0] || a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1]; &#125;); int res &#x3D; 1; for(int i &#x3D; 1; i &lt; points.size(); ++i) &#123; if(points[i][0] &gt; points[i - 1][1]) ++res; else points[i][1] &#x3D; min(points[i][1], points[i - 1][1]); &#125; return res; &#125; &#125;; 435.无重叠区间解法基本思路：贪心 同上452题的思路。在按左边界升序排序的情况下，只需维护右边界为较小值即可。 局部最优：每次都去掉较大的区间，尽可能保留小范围的区间。 代码class Solution &#123; public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123; return a[0] &lt; b[0] || a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1]; &#125;); int res &#x3D; 0; for(int i &#x3D; 1; i &lt; intervals.size(); ++i) &#123; if(intervals[i][0] &lt; intervals[i - 1][1]) &#123; ++res; intervals[i][1] &#x3D; min(intervals[i][1], intervals[i - 1][1]); &#125; &#125; return res; &#125; &#125;; 763.划分字母区间解法基本思路：模拟？ 先统计每个字母最后出现的位置。然后从第一个字母开始，在遍历到最后出现位置的过程中不断更新区间内所有字母最后出现位置中的最大值（即最大右边界），直至达到右边界时，说明这个区间内的字母没有在后面出现了，可以划分出来了。记录分割的位置，后面以此类推。 代码class Solution &#123; public: vector&lt;int&gt; partitionLabels(string s) &#123; int hash[26] &#x3D; &#123;0&#125;; for(int i &#x3D; 0; i &lt; s.length(); ++i) hash[s[i] - &#39;a&#39;] &#x3D; i; vector&lt;int&gt; res; int right &#x3D; 0, left &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length(); ++i) &#123; right &#x3D; max(right, hash[s[i] - &#39;a&#39;]); if(i &#x3D;&#x3D; right) &#123; res.push_back(i + 1 - left); left &#x3D; i + 1; &#125; &#125; return res; &#125; &#125;; 56.合并区间解法基本思路：贪心 和452、435一样的思路，左边界始终更新为最小的（最开始的），右边界取每次相邻区间右边界的最大值。一旦出现不重叠的区间，就将上一个区间加入结果集，最后将最后一个也加入即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123; return a[0] &lt; b[0] || a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1]; &#125;); vector&lt;vector&lt;int&gt;&gt; res; for(int i &#x3D; 1; i &lt; intervals.size(); ++i) &#123; if(intervals[i][0] &lt;&#x3D; intervals[i - 1][1]) &#123; intervals[i][0] &#x3D; intervals[i - 1][0]; intervals[i][1] &#x3D; max(intervals[i][1], intervals[i - 1][1]); &#125; else res.push_back(intervals[i - 1]); &#125; res.push_back(intervals[intervals.size() - 1]); return res; &#125; &#125;; 738.单调递增的数字解法基本思路：贪心 局部最优：当某一位不符合要求时，将自身变为9，高一位减一是最优解。 主要是选择遍历的方向，若是从高位往低位遍历，例如332，第二个3 &gt; 2，结果为329，但不符合要求。后面的比较会影响到之前已经确认了的顺序。而从低位开始遍历，不符合递增时会直接设为9，向高位遍历时不会影响到已经确立的低位（都是9）。 代码class Solution &#123; public: int monotoneIncreasingDigits(int n) &#123; string str &#x3D; to_string(n); int idx &#x3D; str.length(); for(int i &#x3D; str.length() - 1; i &gt; 0; --i) &#123; if(str[i] &lt; str[i - 1]) &#123; idx &#x3D; i; --str[i - 1]; &#125; &#125; for(; idx &lt; str.length(); ++idx) str[idx] &#x3D; &#39;9&#39;; return stoi(str); &#125; &#125;; 968.监控二叉树解法基本思路：二叉树、状态递归 二叉树结构为指数增长，因此摄像头不放在叶节点上，就是最少的放法。因此确立了后序遍历的顺序。 那如何确定当前节点放不放呢？需要依靠子节点返回的状态判断。因此需要先确立节点所有的状态： 未被摄像头覆盖，0（说明子节点属于被覆盖状态2） 有摄像头，1（说明子节点属于未被覆盖状态0） 已被覆盖，2（说明子节点有摄像头，或是空节点（因为叶节点不能放摄像头，所以状态必须为0，因此两个空子节点都设为2，即可完成递归逻辑）） 之后便是先递归左右子节点，然后根据子节点状态返回当前节点状态：有一个0就返回1，并计数；有一个1就返回2；全是2就返回0。最后结束递归后，根节点的状态是需要单独处理的（如果是状态0，就+1） 代码class Solution &#123; public: int res &#x3D; 0; int traversal(TreeNode* cur) &#123; if(cur &#x3D;&#x3D; nullptr) return 2; int left &#x3D; traversal(cur-&gt;left); int right &#x3D; traversal(cur-&gt;right); if(left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123; ++res; return 1; &#125; else if(left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) return 2; return 0; &#125; int minCameraCover(TreeNode* root) &#123; return traversal(root) &#x3D;&#x3D; 0 ? res + 1 : res; &#125; &#125;; 2023.6.27509.斐波那契数解法基本思路：动态规划 状态转移方程：F(n) = F(n - 1) - F(n - 2) 代码class Solution &#123; public: int fib(int n) &#123; if(n &lt; 2) return n; int one &#x3D; 0, two &#x3D; 1, cur; for(int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123; cur &#x3D; one + two; one &#x3D; two; two &#x3D; cur; &#125; return cur; &#125; &#125;; 70.爬楼梯解法基本思路：动态规划 第一道真正的动态规划题，上题状态转移方程算直接给出了。按照五部曲往下走： 1.确定dp数组及含义——dp[i]： 爬到第i层楼梯，有dp[i]种方法 2.确定递推公式 从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。 首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。 还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。 所以dp[i] = dp[i - 1] + dp[i - 2] 。 3.dp数组初始化 因为n取值&gt;=1，那么显然应该从1开始，即dp[1] = 1，dp[2] = 2，那么循环从3开始递推。 4.确定遍历顺序——从前向后，求dp[n]。 5.举例推导 最终发现写法和509基本是完全一致的。 代码class Solution &#123; public: int climbStairs(int n) &#123; if(n &lt;&#x3D; 2) return n; int one &#x3D; 1, two &#x3D; 2, cur; for(int i &#x3D; 3; i &lt;&#x3D; n; ++i) &#123; cur &#x3D; one + two; one &#x3D; two; two &#x3D; cur; &#125; return cur; &#125; &#125;; 746.使用最小花费爬楼梯解法基本思路：动态规划 1.确定dp数组及含义——dp[i]： 爬到第i层楼梯的最低消费 2.确定递推公式 从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。 首先是dp[i - 1]，在i-1层，花费cost[i - 1]到达 i。其次是dp[i - 2]，在i-2层，花费cost[i - 2]到达 i。 选最小值就是：dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) 。 3.dp数组初始化 初始可以在0或1层，即dp[0] = 0，dp[1] = 0，那么循环从2开始递推。 4.确定遍历顺序——从前向后，求dp[n]。 代码class Solution &#123; public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int one &#x3D; 0, two &#x3D; 0, cur; for(int i &#x3D; 2; i &lt;&#x3D; cost.size(); ++i) &#123; cur &#x3D; min(one + cost[i - 2], two + cost[i - 1]); one &#x3D; two; two &#x3D; cur; &#125; return cur; &#125; &#125;; 2023.6.2862.不同路径解法基本思路：动态规划 1.确定dp数组及含义——dp[i] [j]： 走到（i，j）有 dp[i] [j] 条路径。 2.确定递推公式——dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1] 3.dp数组初始化（重点）——在这个二维表格中，第一行和第一列都需要初始化为1。 4.确定遍历顺序——顺序遍历，求dp[m - 1] [n - 1]。 代码class Solution &#123; public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i &#x3D; 0; i &lt; m; ++i) dp[i][0] &#x3D; 1; for(int i &#x3D; 0; i &lt; n; ++i) dp[0][i] &#x3D; 1; for(int i &#x3D; 1; i &lt; m; ++i) for(int j &#x3D; 1; j &lt; n; ++j) dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; &#125; &#125;; 63.不同路径 Ⅱ解法基本思路：动态规划 版本1：重点依旧在于初始化上，在初始化第一行、列时，一旦遇到障碍物，后面都是0，直接停止循环。 版本2：优化空间——一维数组 可以发现递推公式 **dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]**，其中 **dp[i - 1] [j]**保存的是上一行同一列的状态，即可以理解为先 **dp[i] [j] = dp[i - 1] [j]**，再 dp[i] [j] = dp[i] [j] + dp[i] [j - 1].可以发现 i 的存在不必要了。dp数组可以简化为1维，递推公式 **dp[j] = dp[j] + dp[j - 1]**。在按序遍历的情况下，遍历到当前行 的j时，dp[j] 实际为上一行的路径数，只需加上 dp[j - 1]，效果就和版本1完全一致了。 代码版本1：时间复杂度：O(n × m)，空间复杂度：O(n × m) class Solution &#123; public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size(); if (obstacleGrid[0][0] &#x3D;&#x3D; 1 || obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1) return 0; vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i &#x3D; 0; i &lt; m; ++i) &#123; if(obstacleGrid[i][0] &#x3D;&#x3D; 1) break; dp[i][0] &#x3D; 1; &#125; for(int i &#x3D; 0; i &lt; n; ++i) &#123; if(obstacleGrid[0][i] &#x3D;&#x3D; 1) break; dp[0][i] &#x3D; 1; &#125; for(int i &#x3D; 1; i &lt; m; ++i) for(int j &#x3D; 1; j &lt; n; ++j) if(obstacleGrid[i][j] &#x3D;&#x3D; 0) dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; &#125; &#125;; 版本2：时间复杂度：O(n × m)，空间复杂度：O(m) class Solution &#123; public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size(); vector&lt;int&gt; dp(n, 0); for(int i &#x3D; 0; i &lt; n &amp;&amp; obstacleGrid[0][i] &#x3D;&#x3D; 0; ++i) dp[i] &#x3D; 1; for(int i &#x3D; 1; i &lt; m; ++i) &#123; for(int j &#x3D; 0; j &lt; n; ++j) &#123; if(obstacleGrid[i][j] &#x3D;&#x3D; 1) dp[j] &#x3D; 0; else if(j !&#x3D; 0) dp[j] &#x3D; dp[j] + dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125; &#125;; 343.整数拆分解法基本思路：动态规划 这题重点我认为首先是确定dp数组含义，有什么是可以由更小的相同类型的东西递推得到的？dp的值肯定表示为最大乘积，那么下标 i 表示的是什么呢？只能是 正整数 i 拆分后的最大乘积，也就是求 dp[n] 。 那么递推公式就容易解决了：dp[i] = dp[i - num] * num，因为拆出一个num后剩余的也是可以拆分的。但是dp表示的仅是拆分后的最大乘积，不一定比 i 本身大（例：2拆分后为1，小于本身），因此公式应修改为：**dp[i] = max( dp[i - num] * num, (i - num) * num )**。 num怎么取值呢？只能在 [1, i / 2] 范围内遍历取值。那么又出现了问题：dp[i] 每次都会被赋值一遍，要取其中的最大值才行，因此公式还应修改：**dp[i] = max(dp[i], max( dp[i - num] * num, (i - num) * num ))**。 代码class Solution &#123; public: int integerBreak(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[2] &#x3D; 1; for(int i &#x3D; 3; i &lt;&#x3D; n; ++i) for(int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; ++j) dp[i] &#x3D; max(dp[i], max(j * (i - j), j * dp[i - j])); return dp[n]; &#125; &#125;; 96.不同的二叉搜索树解法基本思路：动态规划 这题dp数组含义很好确定，就是 i 个不同节点组成的BST数量。难在递推公式上。 由此，推至n得递推公式：遍历[1, j]计算dp[i] += dp[j - 1] * dp[i - j] 代码class Solution &#123; public: int numTrees(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[0] &#x3D; 1; for(int i &#x3D; 1; i &lt;&#x3D; n; ++i) for(int j &#x3D; 1; j &lt;&#x3D; i; ++j) dp[i] +&#x3D; dp[j - 1] * dp[i - j]; return dp[n]; &#125; &#125;; 相关概念卡特兰数 这种递推公式实际为一种数学表达式，名为[卡特兰数](卡特兰数_百度百科 (baidu.com))。常用于解决以下问题： 凸多边形三角划分：输入凸多边形的边数n，求不同划分的方案数f(n)。此处f(2) = f(3) = 1。 给定n个节点组成不同的二叉搜索树 n对括号正确匹配数目 2023.6.29416.分割等和子集解法基本思路：动态规划、01背包 背包的体积为sum / 2 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值 背包如果正好装满（dp[target] == target），说明找到了总和为 sum / 2 的子集。 代码随想录的代码还可以优化一下空间，dp初始化大小由target决定 代码class Solution &#123; public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum &#x3D; accumulate(nums.begin(), nums.end(), 0); if(sum % 2) return false; int target &#x3D; sum &#x2F; 2; vector&lt;int&gt; dp(target + 1, 0); for(int i &#x3D; 0; i &lt; nums.size(); ++i) for(int j &#x3D; target; j &gt;&#x3D; nums[i]; --j) dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]); return dp[target] &#x3D;&#x3D; target; &#125; &#125;; 1049.最后一块石头的重量 Ⅱ解法基本思路：动态规划、01背包 和上题416的思路是一致的，返回最小重量就是尽可能均分为两堆重量相差最小的石头，即背包的体积为总重量的一半。商品的重量和价值均为 **stones[i]**。 最后得到的 dp[sum / 2] 就是能凑到的最接近的重量了，另一堆就是 sum - dp[sum / 2]，且因为 sum / 2 向下取整，前者必然小于等于后者，因此最终结果为后者 - 前者。 代码class Solution &#123; public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int sum &#x3D; accumulate(stones.begin(), stones.end(), 0); int target &#x3D; sum &#x2F; 2; vector&lt;int&gt; dp(target + 1, 0); for(int&amp; n : stones) for(int i &#x3D; target; i &gt;&#x3D; n; --i) dp[i] &#x3D; max(dp[i], dp[i - n] + n); return sum - dp[target] * 2; &#125; &#125;; 494.目标和解法基本思路：动态规划、01背包 模板都是差不多的，难点在于将具体问题转化为抽象的01背包模板上去。 假设加法部分总和为 x，那么减法部分总和为 sum - x，我们求的是：x - （sum - x）== target，于是我们可以得到加法部分的总和 x = （sum + target）/ 2。这就是背包的容量了，是可以直接算出来的。 那么 dp[i] 就表示装满容量为 i 的背包，有几种方法。 TODO：(target + sum) / 2 向下取整会产生影响，why？ 在组合问题中，递推公式通常不使用max等，而是用+=。 代码class Solution &#123; public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int sum &#x3D; accumulate(nums.begin(), nums.end(), 0); if(abs(target) &gt; sum || (target + sum) % 2) return 0; int size &#x3D; (target + sum) &#x2F; 2; vector&lt;int&gt; dp(size + 1, 0); dp[0] &#x3D; 1; for(int&amp; n : nums) for(int i &#x3D; size; i &gt;&#x3D; n; --i) dp[i] +&#x3D; dp[i - n]; return dp[size]; &#125; &#125;; 474.一和零解法基本思路：动态规划、01背包 这题和之前的01最大区别在于，背包的容量是二维的 m x n。也就是说之前模板中的内层循环变为了两层。 代码class Solution &#123; public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for(string&amp; s : strs) &#123; int one &#x3D; 0, zero &#x3D; 0; for(char c : s) c &#x3D;&#x3D; &#39;0&#39; ? ++zero : ++one; for(int i &#x3D; m; i &gt;&#x3D; zero; --i) for(int j &#x3D; n; j &gt;&#x3D; one; --j) dp[i][j] &#x3D; max(dp[i][j], dp[i - zero][j - one] + 1); &#125; return dp[m][n]; &#125; &#125;; 2023.6.30518.零钱兑换 Ⅱ解法基本思路：动态规划、完全背包 在01背包中，内层遍历背包容量顺序为倒序，是为了保证每个物品仅被使用一次。在完全背包中，每个物品都可无限使用，因此需要按正序遍历。求组合数则是按 += 方式计算。 代码class Solution &#123; public: int change(int amount, vector&lt;int&gt;&amp; coins) &#123; vector&lt;int&gt; dp(amount + 1, 0); dp[0] &#x3D; 1; for(int&amp; n : coins) for(int i &#x3D; n; i &lt;&#x3D; amount; ++i) dp[i] +&#x3D; dp[i - n]; return dp[amount]; &#125; &#125;; 377.组合总和 Ⅳ解法基本思路：动态规划、完全背包 不同于上题518，这里求的是排列。排列可能是一个组合的不同排列方式，因此需要将物品遍历置于内层，若是置于外层，比如本题中：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面。 背包容量放在外循环，将物品放在内循环，内循环从前到后遍历。注意加上 if 判断越界。 代码class Solution &#123; public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; dp(target + 1, 0); dp[0] &#x3D; 1; for(int i &#x3D; 0; i &lt;&#x3D; target; ++i) for(int n : nums) if(i - n &gt;&#x3D; 0 &amp;&amp; dp[i] &lt; INT_MAX - dp[i - n]) dp[i] +&#x3D; dp[i - n]; return dp[target]; &#125; &#125;; 322.零钱兑换解法基本思路：动态规划、完全背包 这题求的是最小值，因此不强调排列或是组合，即正常正序遍历，采用min函数即可。 注意初始化不为0，而是INT_MAX，因为要保留较小的值。dp[0] 需要初始化为0用于累加计算。 代码class Solution &#123; public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] &#x3D; 0; for(int&amp; n : coins) for(int i &#x3D; n; i &lt;&#x3D; amount; ++i) if(dp[i - n] !&#x3D; INT_MAX) dp[i] &#x3D; min(dp[i], dp[i - n] + 1); return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount]; &#125; &#125;; 279.完全平方数解法基本思路：动态规划、完全背包 这题思路喝上题322完全一致，更简单些。 代码class Solution &#123; public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] &#x3D; 0; for(int i &#x3D; 1; i * i &lt;&#x3D; n; ++i) for(int j &#x3D; i * i; j &lt;&#x3D; n; ++j) dp[j] &#x3D; min(dp[j], dp[j - i * i] + 1); return dp[n]; &#125; &#125;; 139.单词拆分解法基本思路：动态规划、完全背包 这题有些抽象。。需要些想象力。 dp含义：dp[i] : 字符串长度为 i 时，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。 递推公式：如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。所以递推公式是 if( [j, i] 这个区间的子串出现在数组中 &amp;&amp; dp[j]) dp[i] = true。 初始化：dp[0] 作为递推根基，需初始化为 true，否则后面都是false。 遍历顺序：本题实则求的是排列中的一种，因为多个单词拼成字符串，那么就会要求单词的前后顺序。所以先遍历背包（字符串长度），再遍历物品（数组）。 代码class Solution &#123; public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int size &#x3D; s.length(); vector&lt;bool&gt; dp(size + 1, false); dp[0] &#x3D; true; for(int i &#x3D; 1; i &lt;&#x3D; size; ++i) for(int j &#x3D; 0; j &lt; i; ++j) if(find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) !&#x3D; wordDict.end() &amp;&amp; dp[j]) dp[i] &#x3D; true; return dp[size]; &#125; &#125;;","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"}]},{"title":"LeetCode每日一题--3月及以前","slug":"LeetCode每日一题--3月及以前","date":"2022-11-04T06:33:06.000Z","updated":"2023-04-01T08:21:10.140Z","comments":true,"path":"原理/LeetCode每日一题--3月及以前/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--3%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/","excerpt":"记录每日一题2022.11.4754.到达终点数字题干在一根无限长的数轴上，你站在0的位置，终点在target的位置。 你可以做一些数量的移动 numMoves : 每次你可以选择向左或向右移动。 第 i 次移动（从 i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。 给定整数 target ，返回：到达目标所需的最小移动次数(即最小 numMoves）","text":"记录每日一题2022.11.4754.到达终点数字题干在一根无限长的数轴上，你站在0的位置，终点在target的位置。 你可以做一些数量的移动 numMoves : 每次你可以选择向左或向右移动。 第 i 次移动（从 i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。 给定整数 target ，返回：到达目标所需的最小移动次数(即最小 numMoves） 示例 输入: target &#x3D; 2 输出: 3 解释: 第一次移动，从 0 到 1; 第二次移动，从 1 到 -1; 第三次移动，从 -1 到 2 。 输入: target &#x3D; 3 输出: 2 解释: 第一次移动，从 0 到 1; 第二次移动，从 1 到 3 。 解法本题主要偏向于数学计算，代码性不强。 首先target关于0对称，因此正负与numMoves无关，为便于计算，将target统一为正数。 分析从最简单的情况开始： 向右走numMoves步 未达到target。那就继续走。 正好达到target。此时numMoves为最小值，return。 越过了target。 越过target后，到达dist。同有三种情况 dist与target差值为偶数，最好解决，只需要将某些步的方向变为左，一加变一减，就可以弥补差值，正好到达target。此时返回值不变，仍为 numMoves 。 差值为奇数，此时需要 numMoves++ ，多走一步，若差值变为偶数（此时差值为奇数，走的步长也为奇数，和就是偶数），则问题转化为上1，返回值为 numMoves + 1 。 多走一步，差值仍为奇数，此时再走一步，差值必然变为偶数（同上，走两步的步长必然是一奇一偶，奇数+奇数必是偶数），转化为上1，返回值为numMoves + 2。 以上，代码转化为判断numMoves当前的步长和是否越过了target，以及越过后与target的差值的奇偶。 代码int reachNumber(int target) &#123; target &#x3D; abs(target); int dist &#x3D; 0, numMoves &#x3D; 0; while(dist &lt; target || (dist - target) % 2)&#123; numMoves++; dist +&#x3D; numMoves; &#125; return numMoves; &#125; 优化 int reachNumber(int target) &#123; target &#x3D; abs(target); int n &#x3D; ceil((-1 + sqrt(8L * target + 1)) &#x2F; 2); &#x2F;&#x2F; 注意 8*target 会超过 int 范围 return (n * (n + 1) &#x2F; 2 - target) % 2 &#x3D;&#x3D; 0 ? n : n + 1 + n % 2; &#125; 2022.11.7816.模糊坐标题干我们有一些二维坐标，如 “(1, 3)” 或 “(2, 0.5)”，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。 原始的坐标表示法不会存在多余的零，所以不会出现类似于**”00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”**形式的数字。 最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。 示例 示例 1: 输入: &quot;(123)&quot; 输出: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;] 示例 2: 输入: &quot;(00011)&quot; 输出: [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;] 解释: 0.0, 00, 0001 或 00.01 是不被允许的。 示例 3: 输入: &quot;(100)&quot; 输出: [(10, 0)] 解释: 1.0 是不被允许的 解法本题实际是两次二分，先将字符串用 “, ” 分为两部分，再用 “.” 分别插入到这两部分中的每个位置，判断是否为一个符合要求的字符串。 最简单的暴力解法： for循环从每个位置将字符串分为A、B两部分； 对每个A、B，再次for循环从每个位置插入 “.” ，将符合要求的字符串分别存入vector； 最后用双for循环从两个vector中取值排列组合，存入返回值的vector中。 仅在插入 “.” 时，需要考虑以下异常情况： 若A、B为 “0” 或首位非0，则其整体为一个有效字符串存储。 for循环插入小数点时，若遇到首位为0时，仅允许在0后插入。 for循环插入小数点时，若遇到末位为0时，不允许插入。 有限状态机： 代码class Solution &#123; public: vector&lt;string&gt; classifyNumber(string s)&#123; vector&lt;string&gt; rst; if(s &#x3D;&#x3D; &quot;0&quot; || s[0] !&#x3D; &#39;0&#39;) rst.push_back(s); for(int i &#x3D; 1; i &lt; s.size(); ++i)&#123; if(i !&#x3D; 1 &amp;&amp; s[0] &#x3D;&#x3D; &#39;0&#39; || s.back() &#x3D;&#x3D; &#39;0&#39;) continue; rst.push_back(s.substr(0, i) + &quot;.&quot; + s.substr(i)); &#125; return rst; &#125; vector&lt;string&gt; ambiguousCoordinates(string s) &#123; vector&lt;string&gt; rst; s &#x3D; s.substr(1, s.size() - 2); for(int i &#x3D; 1; i &lt; s.size(); ++i)&#123; vector&lt;string&gt; lnum &#x3D; classifyNumber(s.substr(0, i)); if(lnum.empty()) continue; vector&lt;string&gt; rnum &#x3D; classifyNumber(s.substr(i)); if(rnum.empty()) continue; for(int i &#x3D; 0; i &lt; lnum.size(); i++)&#123; for(int j &#x3D; 0; j &lt; rnum.size(); j++)&#123; rst.push_back(&quot;(&quot; + lnum[i] + &quot;, &quot; + rnum[j] + &quot;)&quot;); &#125; &#125; &#125; return rst; &#125; &#125;; for循环中，相比于**++i，i++需要多开辟一个临时变量来存储i自加后的值**，因此前者性能更好。 2022.11.81684.统一一致字符串的数目题干给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。 请你返回 words 数组中 一致字符串 的数目。 示例 示例 1: 输入：allowed &#x3D; &quot;ab&quot;, words &#x3D; [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;] 输出：2 解释：字符串 &quot;aaab&quot; 和 &quot;baa&quot; 都是一致字符串，因为它们只包含字符 &#39;a&#39; 和 &#39;b&#39; 。 示例 2: 输入：allowed &#x3D; &quot;abc&quot;, words &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;] 输出：7 解释：所有字符串都是一致的。 示例 3: 输入：allowed &#x3D; &quot;cad&quot;, words &#x3D; [&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;] 输出：4 解释：字符串 &quot;cc&quot;，&quot;acd&quot;，&quot;ac&quot; 和 &quot;d&quot; 是一致字符串。 解法本题实际是如何判断一个字符串中的每个字符是否都在另一个字符串中出现过的问题。 最简单的暴力解法就是循环words中字符串的每个字符与allowed中的每个字符进行比较，看是否都能匹配上，全匹配上了计数加一。有无法匹配到的跳出循环，判断该字符串为不一致。 解法2：位运算 定义一个32位的int变量，26个字符，各占一位，占据低26位；通过将字符与 ‘a’ 作差计算相应字符需要向左移位多少。某一位为1，表示该位对应的字符存在。 计算出allowed字符串对应的int值standard，和words中的每个字符串对应的值作或运算，若仍为standard原值，说明该字符串的字符均在allowed中，计数num++。 相比于暴力循环，在内存消耗差不多的情况下，提高了1/3速度。 代码class Solution &#123; public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) &#123; int num &#x3D; 0; auto convert &#x3D; [](string&amp; str)&#123; int rst &#x3D; 0; for(int i &#x3D; 0; i &lt; str.length(); ++i)&#123; rst |&#x3D; 1 &lt;&lt; (str[i] - &#39;a&#39;); &#125; return rst; &#125;; int standard &#x3D; convert(allowed); for(int i &#x3D; 0; i &lt; words.size(); ++i)&#123; if (standard &#x3D;&#x3D; (standard | convert(words[i]))) num++; &#125; return num; &#125; &#125;; 这里使用了匿名函数的方式来封装统一的转换方法。好处是可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。 2022.11.9764.最大加号标志题干在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。**mines[i] = [xi, yi]**表示 grid[xi][yi] == 0 返回 grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。 一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。 示例 示例 1: 输入: n &#x3D; 5, mines &#x3D; [[4, 2]] 输出: 2 解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。 示例 2: 输入: n &#x3D; 1, mines &#x3D; [[0, 0]] 输出: 0 解释: 没有加号标志，返回 0 。 解法本题实际是一个动态规划问题。动态规划的核心思想就是——拆分子问题，记住过往，减少重复计算 题中要求十字的最大阶数，但实际上最大阶数是由中心到四个方向上的连续1数量中的最小值决定的。那么问题转变为了：先求每个点为中心到四个方向上的连续1数量中的最小值，再从中取最大值。 如何求四个方向的最小值？假设简化一下，只求左方向的值怎么求？只需要计算每个点左边最长的连续1的格子数，那么十字就是上述的四次重复。初始化时先假设每个点连续1的数量均为网格的宽度n（即最大值），维护一个自加变量left记录连续1的数量。当在一行中从左向右遍历时，如果遇到0，自加变量清零，否则left++。每次自加后与原先该点记录的值取最小值，更新该点的值。 在重复时，同一个点都会经过四个方向的遍历，但只会保留到四个方向里面的最小值了。遍历结束后，得到一个二维的记录每个点最大十字阶数的向量，取里面的最大值即可。 代码class Solution &#123; public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) &#123; &#x2F;&#x2F; 初始化矩阵 vector&lt;vector&lt;int&gt; &gt; grid(n, vector&lt;int&gt;(n, n)); for(int i &#x3D; 0; i &lt; mines.size(); ++i) grid[mines[i][0]][mines[i][1]] &#x3D; 0; &#x2F;&#x2F; 遍历 int left, right, top, bottom; for(int i &#x3D; 0; i &lt; n; ++i)&#123; left &#x3D; 0; right &#x3D; 0; top &#x3D; 0; bottom &#x3D; 0; for(int j &#x3D; 0, k &#x3D; n - 1; j &lt; n; ++j, --k)&#123; left &#x3D; grid[i][j] ? left + 1 : 0; right &#x3D; grid[i][k] ? right + 1 : 0; top &#x3D; grid[j][i] ? top + 1 : 0; bottom &#x3D; grid[k][i] ? bottom + 1 : 0; grid[i][j] &#x3D; left &lt; grid[i][j] ? left : grid[i][j]; grid[i][k] &#x3D; right &lt; grid[i][k] ? right : grid[i][k]; grid[j][i] &#x3D; top &lt; grid[j][i] ? top : grid[j][i]; grid[k][i] &#x3D; bottom &lt; grid[k][i] ? bottom : grid[k][i]; &#125; &#125; int max &#x3D; 0; for(int i &#x3D; 0; i &lt; n; ++i)&#123; for(int j &#x3D; 0; j &lt; n; ++j)&#123; if (max &lt; grid[i][j]) max &#x3D; grid[i][j]; &#125; &#125; return max; &#125; &#125;; 注：vector的初始化方式。 vector采用 for(auto&amp; item : vector) 的形式遍历较为方便，但是速度较普通for循环更慢，但是不用担心越界问题。 2022.11.111704.判断字符串的两半是否相似题干给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。 两个字符串 相似 的前提是它们都含有相同数目的元音（**’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s** 可能同时含有大写和小写字母。 如果 a 和 b 相似，返回 true ；否则，返回 false 。 示例 示例 1: 输入：s &#x3D; &quot;book&quot; 输出：true 解释：a &#x3D; &quot;bo&quot; 且 b &#x3D; &quot;ok&quot; 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。 示例 2: 输入：s &#x3D; &quot;textbook&quot; 输出：false 解释：a &#x3D; &quot;text&quot; 且 b &#x3D; &quot;book&quot; 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。 解法本题实际就是一次for循环，对字符串s的每个字符判断一次是否为元音即可，中间记录下前后半的元音个数。 可优化的点在于 1.不必for循环整个字符串，由于a、b长度相同，可以只for循环前一半（类似双指针？）。 2.只需维护一个变量记录元音数量即可，左加右减，节约内存。 代码class Solution &#123; public: bool halvesAreAlike(string s) &#123; auto isVowel &#x3D; [](char c)&#123; int val &#x3D; c - &#39;A&#39;; if (val &#x3D;&#x3D; 0 || val &#x3D;&#x3D; 4 || val &#x3D;&#x3D; 8 || val &#x3D;&#x3D; 14 || val &#x3D;&#x3D; 20 || val &#x3D;&#x3D; 32 || val &#x3D;&#x3D; 36 || val &#x3D;&#x3D; 40 || val &#x3D;&#x3D; 46 || val &#x3D;&#x3D; 52 ) return true; else return false; &#125;; int cnt &#x3D; 0; int len &#x3D; s.length() &#x2F; 2; for(int i &#x3D; 0; i &lt; len; ++i)&#123; cnt +&#x3D; isVowel(s[i]) ? 1 : 0; cnt -&#x3D; isVowel(s[i + len]) ? 1 : 0; &#125; return cnt &#x3D;&#x3D; 0; &#125; &#125;; 我这里直接写了个匿名函数通过ASCII的差值判断是否为元音，还可以用集合。 unordered_set&lt;char&gt; vowels &#x3D; &#123;&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;, &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;&#125;; cnt +&#x3D; vowels.count(s[i]); 2022.12.61805.字符串中不同整数的数目题干给你一个字符串 word ，该字符串由数字和小写英文字母组成。 请你用空格替换每个不是数字的字符。例如，**”a123bc34d8ef34”** 将会变成 “ 123 34 8 34” 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：**”123”、”34”、”8”** 和 “34” 。 返回对 word 完成替换后形成的 不同 整数的数目。 只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。 示例 示例 1: 输入：word &#x3D; &quot;a123bc34d8ef34&quot; 输出：3 解释：不同的整数有 &quot;123&quot;、&quot;34&quot; 和 &quot;8&quot; 。注意，&quot;34&quot; 只计数一次。 示例 2: 输入：word &#x3D; &quot;leet1234code234&quot; 输出：2 示例 3: 输入：word &#x3D; &quot;a1b01c001&quot; 输出：1 解释：&quot;1&quot;、&quot;01&quot; 和 &quot;001&quot; 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。 解法本题解法就是双指针和C++集合不能有重复项特点的应用。 先用一个头指针 i ，for循环遍历字符串的每一项，判断是否为数字（ASCII码值小于58，09是4857），如果为数字，进行三步操作： 1.使用另一个指针 j ，从 i 处开始向后扫，直到扫到非数字字符。 2.移动 i ，从该串数字的最高位开始判断有无0，有前导0的位全部去掉。 3.将过滤后的字符串加入集合Set中。 代码class Solution &#123; public: int numDifferentIntegers(string word) &#123; set&lt;string&gt; nums; int j, len &#x3D; word.length(); for(int i &#x3D; 0; i &lt; len; i++)&#123; if(word[i] &lt; 58)&#123; j &#x3D; i; while(word[j] &lt; 58 &amp;&amp; j &lt; len) j++; while(word[i] &#x3D;&#x3D; 48 &amp;&amp; j - i &gt; 1) i++; nums.insert(word.substr(i, j - i)); i &#x3D; j; &#125; &#125; return nums.size(); &#125; &#125;; 2022.12.71775.通过最少操作次数使数组的和相等题干给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。 请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。 示例 示例 1: 输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [1,1,2,2,2,2] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums2[0] 变为 6 。 nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [6,1,2,2,2,2] 。 - 将 nums1[5] 变为 1 。 nums1 &#x3D; [1,2,3,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。 - 将 nums1[2] 变为 2 。 nums1 &#x3D; [1,2,2,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。 示例 2: 输入：nums1 &#x3D; [1,1,1,1,1,1,1], nums2 &#x3D; [6] 输出：-1 解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。 示例 3: 输入：nums1 &#x3D; [6,6], nums2 &#x3D; [1] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums1[0] 变为 2 。 nums1 &#x3D; [2,6], nums2 &#x3D; [1] 。 - 将 nums1[1] 变为 2 。 nums1 &#x3D; [2,2], nums2 &#x3D; [1] 。 - 将 nums2[0] 变为 4 。 nums1 &#x3D; [2,2], nums2 &#x3D; [4] 。 解法本题用到了贪心思想，即一个问题拆解成多个步骤，每个步骤采用最优的解法。 在本题中，要让两个数组以最少步骤达到和相同，就代表每一步缩小的差距越大越好，也就是**优先把和小的数组里的 1 变成 6 ，把和大的数组中的 6 变成 1.**以此类推，接下来是5、2；4、3······当走到其中一步时差距缩小为非正数时，说明该步就是最后一步了。 并且1变6和6变1的意义是相同的，都是缩小了5的差距，因此从节约空间的角度考虑，可以只维护一个长度为6的1维数组，记录操作的分布情况（缩小543210的差距）。 代码class Solution &#123; public: int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int diff &#x3D; accumulate(nums1.begin(), nums1.end(), 0) - accumulate(nums2.begin(), nums2.end(), 0); if (diff &lt; 0) return minOperations(nums2, nums1); if (diff &#x3D;&#x3D; 0) return 0; int cnt[6] &#x3D; &#123;0&#125;; int i &#x3D; 0, count &#x3D; 0; for(;i &lt; nums1.size();++i) ++cnt[nums1[i] - 1]; for(i &#x3D; 0;i &lt; nums2.size();++i) ++cnt[6 - nums2[i]]; for(i &#x3D; 5;i &gt; 0; --i)&#123; while(cnt[i] &gt; 0 &amp;&amp; diff &gt; 0)&#123; diff -&#x3D; i; --cnt[i]; count++; &#125; &#125; return diff &gt; 0 ? -1 : count; &#125; &#125;; accumulate属于numeric头文件，作用是计算数组或C++容器指定地址范围内的成员的和。 参数1、2分别为 容器 / 数组 指向要计算的第一个元素和最后一个元素的 迭代器 / 首地址 ，参数3为累加的初始值。 这里为了下面for循环存储操作的分布情况，固定了nums1的和要大于nums2；若是小于，就调换输入顺序重新执行函数（这里测试过，相比于swap调换两个vector，这种方式要快一些）。这里心机的把 diff == 0 的情况放在了 diff &lt; 0 下面，大部分情况下应该都是不相等的，这样可以少点计算量（dog）。 2022.12.91780.判断一个数字是否可以表示成三的幂的和题干给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。 对于一个整数 y ，如果存在整数 x 满足 y == 3^x ，我们称这个整数 y 是三的幂。 示例 示例 1: 输入：n &#x3D; 12 输出：true 解释：12 &#x3D; 3^1 + 3^2 示例 2: 输入：n &#x3D; 91 输出：true 解释：91 &#x3D; 3^0 + 3^2 + 3^4 示例 3: 输入：n &#x3D; 21 输出：false 解法基本思路： 看示例1可知，满足条件的数为3的不同次幂的和，那么必然能被3整除，看示例2可知另一情况，3^0为1，也就是除以3余数为1，但是也满足条件。当示例1中除以3，得到4，又变成了示例2的情况，即3^0 + 3的幂。 于是得到满足条件的整数一定具有以下性质： 除以3以后余数必为1或0； 性质1得到的商依旧满足性质1，直至商为0。 代码class Solution &#123; public: bool checkPowersOfThree(int n) &#123; while(n)&#123; if (n % 3 &#x3D;&#x3D; 2) return false; n &#x2F;&#x3D; 3; &#125; return true; &#125; &#125;; 2023.2.81233.删除子文件夹（未完结）题干你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：**’/‘** 后跟一个或者多个小写英文字母。 例如，”/leetcode“ 和 “/leetcode/problems“ 都是有效的路径，而空字符串和 “/“ 不是。 示例 示例 1: 输入：folder &#x3D; [&quot;&#x2F;a&quot;,&quot;&#x2F;a&#x2F;b&quot;,&quot;&#x2F;c&#x2F;d&quot;,&quot;&#x2F;c&#x2F;d&#x2F;e&quot;,&quot;&#x2F;c&#x2F;f&quot;] 输出：[&quot;&#x2F;a&quot;,&quot;&#x2F;c&#x2F;d&quot;,&quot;&#x2F;c&#x2F;f&quot;] 解释：&quot;&#x2F;a&#x2F;b&quot; 是 &quot;&#x2F;a&quot; 的子文件夹，而 &quot;&#x2F;c&#x2F;d&#x2F;e&quot; 是 &quot;&#x2F;c&#x2F;d&quot; 的子文件夹。 示例 2: 输入：folder &#x3D; [&quot;&#x2F;a&quot;,&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;] 输出：[&quot;&#x2F;a&quot;] 解释：文件夹 &quot;&#x2F;a&#x2F;b&#x2F;c&quot; 和 &quot;&#x2F;a&#x2F;b&#x2F;d&quot; 都会被删除，因为它们都是 &quot;&#x2F;a&quot; 的子文件夹。 示例 3: 输入: folder &#x3D; [&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;ca&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;] 输出: [&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;ca&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;] 解法基本思路： 先按照字典序排序（/a，/a/b，/a/b/c，/b），这样在遍历时只需要和上一个被加入的非子文件夹比较（因为相同根文件夹情况下先短后长排序），便于排除。 将第一个文件夹加入输出，遍历folder中的剩余文件夹，作如下判断： 1.当前字符串长度比上一个被加入的字符串短的，必然是根文件夹名改变了，是非子文件夹，加入。 2.当前字符串的前n个字符与上一个被加入的字符串完全相同且第n+1个字符为 ‘/’ 的，必然是子文件夹，排除。 解法2：字典树 代码class Solution &#123; public: vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) &#123; sort(folder.begin(), folder.end()); vector&lt;string&gt; rst &#x3D; &#123;folder[0]&#125;; for(int i &#x3D; 1; i &lt; folder.size(); ++i)&#123; int ori_len &#x3D; rst.back().size(); int cur_len &#x3D; folder[i].size(); if (ori_len &gt;&#x3D; cur_len || !(rst.back() &#x3D;&#x3D; folder[i].substr(0, ori_len) &amp;&amp; folder[i][ori_len] &#x3D;&#x3D; &#39;&#x2F;&#39;)) rst.push_back(folder[i]); &#125; return rst; &#125; &#125;; 2023.2.91797.设计一个验证系统题干你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类： AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。 如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 所有 generate 函数的调用都会包含独一无二的 tokenId 值。 所有函数调用中，currentTime 的值 严格递增 。 所有函数的调用次数总共不超过 2000 次。 示例 输入： [&quot;AuthenticationManager&quot;, &quot;renew&quot;, &quot;generate&quot;, &quot;countUnexpiredTokens&quot;, &quot;generate&quot;, &quot;renew&quot;, &quot;renew&quot;, &quot;countUnexpiredTokens&quot;] [[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]] 输出： [null, null, null, 1, null, null, null, 0] 解释： AuthenticationManager authenticationManager &#x3D; new AuthenticationManager(5); &#x2F;&#x2F; 构造 AuthenticationManager ，设置 timeToLive &#x3D; 5 秒。 authenticationManager.renew(&quot;aaa&quot;, 1); &#x2F;&#x2F; 时刻 1 时，没有验证码的 tokenId 为 &quot;aaa&quot; ，没有验证码被更新。 authenticationManager.generate(&quot;aaa&quot;, 2); &#x2F;&#x2F; 时刻 2 时，生成一个 tokenId 为 &quot;aaa&quot; 的新验证码。 authenticationManager.countUnexpiredTokens(6); &#x2F;&#x2F; 时刻 6 时，只有 tokenId 为 &quot;aaa&quot; 的验证码未过期，所以返回 1 。 authenticationManager.generate(&quot;bbb&quot;, 7); &#x2F;&#x2F; 时刻 7 时，生成一个 tokenId 为 &quot;bbb&quot; 的新验证码。 authenticationManager.renew(&quot;aaa&quot;, 8); &#x2F;&#x2F; tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，且 8 &gt;&#x3D; 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。 authenticationManager.renew(&quot;bbb&quot;, 10); &#x2F;&#x2F; tokenId 为 &quot;bbb&quot; 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。 authenticationManager.countUnexpiredTokens(15); &#x2F;&#x2F; tokenId 为 &quot;bbb&quot; 的验证码在时刻 15 过期，tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。 解法基本思路： 采用哈希表存储 [tokenId，过期时间点] 这一键值对，保存信息。 因为提到了currentTime是严格递增的，因此在存储id时可以不用队列，直接用顺序表存储。 因为函数总调用次数不超过2000次，因此甚至不需要对表进行维护（即删除过期id）。 代码class AuthenticationManager &#123; public: AuthenticationManager(int timeToLive) &#123; liveTime &#x3D; timeToLive; &#125; void generate(string tokenId, int currentTime) &#123; liveIds[tokenId] &#x3D; currentTime + liveTime; &#125; void renew(string tokenId, int currentTime) &#123; if (liveIds[tokenId] &gt; currentTime) generate(tokenId, currentTime); &#125; int countUnexpiredTokens(int currentTime) &#123; int cnt &#x3D; 0; for (auto iter &#x3D; liveIds.begin(); iter !&#x3D; liveIds.end(); ++iter) &#123; if (iter-&gt;second &gt; currentTime) cnt++; &#125; return cnt; &#125; private: int liveTime; unordered_map&lt;string, int&gt; liveIds; &#125;; &#x2F;** * Your AuthenticationManager object will be instantiated and called as such: * AuthenticationManager* obj &#x3D; new AuthenticationManager(timeToLive); * obj-&gt;generate(tokenId,currentTime); * obj-&gt;renew(tokenId,currentTime); * int param_3 &#x3D; obj-&gt;countUnexpiredTokens(currentTime); *&#x2F; 2023.2.112335.装满杯子所需的最短总时长题干现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。 示例 示例 1: 输入：amount &#x3D; [1,4,2] 输出：4 解释：下面给出一种方案： 第 1 秒：装满一杯冷水和一杯温水。 第 2 秒：装满一杯温水和一杯热水。 第 3 秒：装满一杯温水和一杯热水。 第 4 秒：装满一杯温水。 可以证明最少需要 4 秒才能装满所有杯子。 示例 2: 输入：amount &#x3D; [5,4,4] 输出：7 示例 3: 输入：amount &#x3D; [5,0,0] 输出：5 解法基本思路： 简单的贪心算法。每次循环先排序，取较大的两个各减一，直至全为0. 代码class Solution &#123; public: int fillCups(vector&lt;int&gt;&amp; amount) &#123; int turns &#x3D; 0; while(amount[0] + amount[1] + amount[2]) &#123; sort(amount.begin(), amount.end()); turns++; amount[2]--; if (amount[1] &gt; 0) amount[1]--; &#125; return turns; &#125; &#125;; 2023.2.131234.替换子串得到平衡字符串题干有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。 假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。 给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。 你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。 请返回待替换子串的最小可能长度。 如果原字符串自身就是一个平衡字符串，则返回 0。 示例 示例 1: 输入：s &#x3D; &quot;QWER&quot; 输出：0 解释：s 已经是平衡的了。 示例 2: 输入：s &#x3D; &quot;QQWE&quot; 输出：1 解释：我们需要把一个 &#39;Q&#39; 替换成 &#39;R&#39;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。 示例 3: 输入：s &#x3D; &quot;QQQQ&quot; 输出：3 解释：我们可以替换后 3 个 &#39;Q&#39;，使 s &#x3D; &quot;QWER&quot;。 解法基本思路： 最终目标是四个字符的数量都达到 n/4 个时，改动字符串的长度怎么取最短。很容易想到双指针来控制应该改动的部分的首尾。 因为替换字符串内的字符都可以任选，那么只要保证该子串外的字符数达标即可。那么判断条件就是子串外的四个字符数均小于等于 n/4 个。 先统计一遍原字符串中的四个字符数。 移动右指针时将子串外对应字符数-1，移动左指针+1。 以右指针为基准进行for循环，通过左指针右移压缩改动字符串的长度，找出符合标准的最小值即可。 代码class Solution &#123; public: int balancedString(string s) &#123; int len &#x3D; s.length(); int num &#x3D; len &#x2F; 4, cnt[&#39;X&#39;] &#x3D; &#123;0&#125;; for (char&amp; c : s) &#123; cnt[c]++; &#125; if (cnt[&#39;Q&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;W&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;E&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;R&#39;] &#x3D;&#x3D; num) return 0; int res &#x3D; len, left &#x3D; 0; for (int right &#x3D; 0; right &lt; len; ++right) &#123; cnt[s[right]]--; while (left &lt;&#x3D; right &amp;&amp; cnt[&#39;Q&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;W&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;E&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;R&#39;] &lt;&#x3D; num) &#123; res &#x3D; min(res, right - left + 1); cnt[s[left++]]++; &#125; &#125; return res; &#125; &#125;; 2023.2.181237.找出给定方程的正整数解题干给你一个函数 f(x, y) 和一个目标结果 z，函数公式未知，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。满足条件的结果数对可以按任意顺序返回。 尽管函数的具体式子未知，但它是单调递增函数，也就是说： f(x, y) &lt; f(x + 1, y)f(x, y) &lt; f(x, y + 1) 函数接口定义如下： interface CustomFunction &#123; public: &#x2F;&#x2F; Returns some positive integer f(x, y) for two positive integers x and y based on a formula. int f(int x, int y); &#125;; 你的解决方案将按如下规则进行评判： 判题程序有一个由 CustomFunction 的 9 种实现组成的列表，以及一种为特定的 z 生成所有有效数对的答案的方法。 判题程序接受两个输入：function_id（决定使用哪种实现测试你的代码）以及目标结果 z 。 判题程序将会调用你实现的 findSolution 并将你的结果与答案进行比较。 如果你的结果与答案相符，那么解决方案将被视作正确答案，即 Accepted 。 示例 示例 1: 输入：function_id &#x3D; 1, z &#x3D; 5 输出：[[1,4],[2,3],[3,2],[4,1]] 解释：function_id &#x3D; 1 暗含的函数式子为 f(x, y) &#x3D; x + y 以下 x 和 y 满足 f(x, y) 等于 5： x&#x3D;1, y&#x3D;4 -&gt; f(1, 4) &#x3D; 1 + 4 &#x3D; 5 x&#x3D;2, y&#x3D;3 -&gt; f(2, 3) &#x3D; 2 + 3 &#x3D; 5 x&#x3D;3, y&#x3D;2 -&gt; f(3, 2) &#x3D; 3 + 2 &#x3D; 5 x&#x3D;4, y&#x3D;1 -&gt; f(4, 1) &#x3D; 4 + 1 &#x3D; 5 示例 2: 输入：function_id &#x3D; 2, z &#x3D; 5 输出：[[1,5],[5,1]] 解释：function_id &#x3D; 2 暗含的函数式子为 f(x, y) &#x3D; x * y 以下 x 和 y 满足 f(x, y) 等于 5： x&#x3D;1, y&#x3D;5 -&gt; f(1, 5) &#x3D; 1 * 5 &#x3D; 5 x&#x3D;5, y&#x3D;1 -&gt; f(5, 1) &#x3D; 5 * 1 &#x3D; 5 提示： 1 &lt;= function_id &lt;= 9 1 &lt;= z &lt;= 100 题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。 在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。 解法基本思路： 这个题目我觉得题干有非常多的无效信息，因为f（x，y）是具体实现不可见的函数。 实际有效的信息只有两条： f（x，y）是单调递增函数 x，y的取值范围均为 [1, 1000] 那么我们可以采用枚举的方式（遍历），分别将x，y的值设为区间的两端（原因后面可以体会到） x初始为1最小，y初始为1000最大（即x只能递增，y只能递减），计算f（x，y）有三种结果 当f（x，y）&lt; z 时，由单调性可知，f（x，y-1）同样小于z，而我们的目标是等于z，此时唯一的动作就是x++； 当f（x，y）&gt; z 时，同理，只能y–； 当f（x，y）== z 时，存储这一对x，y，同时x++，y–（两个同时增减，因为只变动一个没有意义，必然不可能等于z）。 代码&#x2F;* * &#x2F;&#x2F; This is the custom function interface. * &#x2F;&#x2F; You should not implement it, or speculate about its implementation * class CustomFunction &#123; * public: * &#x2F;&#x2F; Returns f(x, y) for any given positive integers x and y. * &#x2F;&#x2F; Note that f(x, y) is increasing with respect to both x and y. * &#x2F;&#x2F; i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1) * int f(int x, int y); * &#125;; *&#x2F; class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) &#123; vector&lt;vector&lt;int&gt;&gt; res; int x &#x3D; 1, y &#x3D; 1000; while(x &lt;&#x3D; 1000 &amp;&amp; y) &#123; int rst &#x3D; customfunction.f(x, y); if (rst &lt; z) x++; else if (rst &gt; z) y--; else res.push_back(&#123;x++, y--&#125;); &#125; return res; &#125; &#125;; 2023.2.202347.最好的扑克手牌题干给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。 下述是从好到坏你可能持有的 手牌类型 ： “Flush“：同花，五张相同花色的扑克牌。 “Three of a Kind“：三条，有 3 张大小相同的扑克牌。 “Pair“：对子，两张大小一样的扑克牌。 “High Card“：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。 示例 示例 1: 输入：ranks &#x3D; [13,2,3,1,9], suits &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;] 输出：&quot;Flush&quot; 示例 2: 输入：ranks &#x3D; [4,4,2,4,4], suits &#x3D; [&quot;d&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 输出：&quot;Three of a Kind&quot; 示例 3: 输入：ranks &#x3D; [10,10,2,12,9], suits &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;d&quot;] 输出：&quot;Pair&quot; 解法基本思路： 简单题，没啥说的，翻译一下就是： 先判断suits里的元素是否均相同； 再判断ranks里是否存在三个/两个/不存在相同的元素； 代码class Solution &#123; public: string bestHand(vector&lt;int&gt;&amp; ranks, vector&lt;char&gt;&amp; suits) &#123; if (equal(suits.begin()+1, suits.end(), suits.begin())) return &quot;Flush&quot;; int cnt[14] &#x3D; &#123;0&#125;; bool isPair &#x3D; false; for(int i &#x3D; 0; i &lt; ranks.size(); ++i)&#123; if(++cnt[ranks[i]] &#x3D;&#x3D; 3) return &quot;Three of a Kind&quot;; isPair |&#x3D; cnt[ranks[i]] &#x3D;&#x3D; 2; &#125; return isPair ? &quot;Pair&quot; : &quot;High Card&quot;; &#125; &#125;; 2023.2.242357.使数组中所有元素都等于0题干给你一个非负整数数组 nums 。在一步操作中，你必须： 选出一个正整数 x ，x 需要小于或等于 nums 中 最小 的 非零 元素。 nums 中的每个正整数都减去 x。 返回使 nums 中所有元素都等于 0 需要的 最少 操作数。 示例 示例 1: 输入：nums &#x3D; [1,5,0,3,5] 输出：3 解释： 第一步操作：选出 x &#x3D; 1 ，之后 nums &#x3D; [0,4,0,2,4] 。 第二步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,2,0,0,2] 。 第三步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,0,0,0,0] 。 示例 2: 输入：nums &#x3D; [0] 输出：0 解法基本思路： 简单题，没啥说的，每一步都找一个最小的正整数减掉，直到全为0。 不必要真去减，如示例1，第一步减1后3变成2，正好是第二步减的数，也就是说只需要记录之前减的总数（上一个需要被减的数本身）就行。 代码class Solution &#123; public: int minimumOperations(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int lastNum &#x3D; 0, cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if (nums[i] - lastNum &gt; 0) &#123; lastNum &#x3D; nums[i]; cnt++; &#125; &#125; return cnt; &#125; &#125;; 2023.2.251247.交换字符使得字符串相同题干有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x“ 和 “y“，你需要通过「交换字符」的方式使这两个字符串相同。 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 **s1[i] 和 s2[j]**，但不能交换 **s1[i] 和 s1[j]**。 最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。 示例 示例 1: 输入：s1 &#x3D; &quot;xx&quot;, s2 &#x3D; &quot;yy&quot; 输出：1 解释：交换 s1[0] 和 s2[1]，得到 s1 &#x3D; &quot;yx&quot;，s2 &#x3D; &quot;yx&quot;。 示例 2: 输入：s1 &#x3D; &quot;xy&quot;, s2 &#x3D; &quot;yx&quot; 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 &#x3D; &quot;yy&quot;，s2 &#x3D; &quot;xx&quot; 。 交换 s1[0] 和 s2[1]，得到 s1 &#x3D; &quot;xy&quot;，s2 &#x3D; &quot;xy&quot; 。 示例 3: 输入：s1 &#x3D; &quot;xx&quot;, s2 &#x3D; &quot;xy&quot; 输出：-1 解法基本思路： 首先统计两个字符串同一位置下的字符不同的数量，因为交换只会发生在不同处。 不同有两种情况，xy和yx。 根据上述三个示例可以得出结论，对于每2对不同的字符： 若为同一形式（均为xy），只需要对角交换1次即可相同； 若为不同形式（xy和yx），需要先同位置交换1次变为示例1，再对角交换一次； 若仅有一对不同，无法交换至相同。 可以得出结论： xy、yx和为奇数，无法相同，返回-1； 若和为偶数，分为两种情况，xy、yx均为偶数或奇数； 若均为偶数，按照每两对1次的情况，只需要 xy / 2 + yx / 2 次 若均为奇数，则在除去每两对一次的情况下，会留存一对示例2情况； 结合3、4可得共 xy / 2 + yx / 2 + xy % 2 + yx % 2 次。 代码class Solution &#123; public: int minimumSwap(string s1, string s2) &#123; int xy &#x3D; 0, yx &#x3D; 0; for(int i &#x3D; 0; i &lt; s1.length(); ++i)&#123; xy +&#x3D; s1[i] &lt; s2[i]; yx +&#x3D; s1[i] &gt; s2[i]; &#125; if ((xy + yx) % 2) return -1; return xy &#x2F; 2 + yx &#x2F; 2 + xy % 2 + yx % 2; &#125; &#125;; 2023.2.271144.递减元素使数组成锯齿状题干给你一个整数数组 nums，每次操作会从中选择一个元素并将该元素的值减少 1。 如果符合下列情况之一，则数组 A 就是 锯齿数组： 每个偶数索引对应的元素都大于相邻的元素，即 A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; … 每个奇数索引对应的元素都大于相邻的元素，即 A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; … 返回将数组 nums 转换为锯齿数组所需的最小操作次数。 示例 示例 1: 输入：nums &#x3D; [1,2,3] 输出：2 解释：我们可以把 2 递减到 0，或把 3 递减到 1。 示例 2: 输入：nums &#x3D; [9,6,1,6,2] 输出：4 解法基本思路： 枚举呗。 奇数和偶数下标各遍历一遍，每次都判断和两边的差值，记录最大值求和即可。 排除掉当元素处于数组边界时越界的问题，最后比较两种哪种小。 代码class Solution &#123; public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) &#123; int cnt[2] &#x3D; &#123;0&#125;; for(int i &#x3D; 0; i &lt; 2; ++i)&#123; for(int j &#x3D; i; j &lt; nums.size(); ++j, ++j)&#123; int step &#x3D; 0; if(j) step &#x3D; max(step, nums[j] - nums[j - 1] + 1); if(j &lt; nums.size()-1) step &#x3D; max(step, nums[j] - nums[j + 1] + 1); cnt[i] +&#x3D; step; &#125; &#125; return min(cnt[0], cnt[1]); &#125; &#125;; 面试题16.07.最大数值题干编写一个方法，找出两个数字 a 和 b 中最大的那一个。不得使用if-else或其他比较运算符。 示例 示例 1: 输入： a &#x3D; 1, b &#x3D; 2 输出： 2 解法基本思路： 首先考虑到的就是不用比较符号如何出现控制输出a还是b呢？ 想到了类似门电路，用0和1控制就行，也就是 a * (condition ^ 1) + b * condition ; 那么什么运算结果是0和1呢，很容易想到通过位运算获取符号位。 于是得到以下代码： class Solution &#123; public: int maximum(int a, int b) &#123; &#x2F;&#x2F; 注意当值为负数时，右移高位是会补1的，因此需要把计算结果转为无符号 int signSub &#x3D; static_cast&lt;unsigned&gt;(a - b) &gt;&gt; 31; return a * (signSub ^ 1) + b * signSub; &#125; &#125;; 提交时出现了问题 signed integer overflow: 2147483647 - -2147483648 cannot be represented in type &#39;int&#39; 忘记考虑了溢出的问题，在 a - b 时就溢出了。当a和b同号时，不存在溢出问题，可以直接用上述方法，只有当ab异号时需要考虑溢出问题。 可以发现，当a和b异号时，若a为负数，符号位1，需要输出b，也就是signSub = 1；a为正数，符号位0，输出a，signSub = 0. 可以得到此时的处理方法，signSub = a符号位 ^ b符号位 ^ b符号位。 在不使用比较运算符的情况下，可以用 &amp;&amp; 作为if判断使用。 代码 class Solution &#123; public: int maximum(int a, int b) &#123; int signA &#x3D; static_cast&lt;unsigned&gt;(a) &gt;&gt; 31; int signB &#x3D; static_cast&lt;unsigned&gt;(b) &gt;&gt; 31; int signSub &#x3D; signA ^ signB ^ signB; int temp &#x3D; (signA ^ signB ^ 1) &amp;&amp; (signSub &#x3D; static_cast&lt;unsigned&gt;(a - b) &gt;&gt; 31); return a * (signSub ^ 1) + b * signSub; &#125; &#125;; 2023.2.282363.合并相似的物品题干给你两个二维整数数组 items1 和 items2 ，表示两个物品集合。每个数组 items 有以下特质： items[i] = [valuei, weighti] 其中 valuei 表示第 i 件物品的 价值 ，weighti 表示第 i 件物品的 重量 。 items 中每件物品的价值都是 唯一 的 。 请你返回一个二维数组 ret，其中 **ret[i] = [valuei, weighti]**， weighti 是所有价值为 valuei 物品的 重量之和 。 注意： ret 应该按价值 升序 排序后返回。 1 &lt;= valuei, weighti &lt;= 1000 示例 示例 1: 输入：items1 &#x3D; [[1,1],[4,5],[3,8]], items2 &#x3D; [[3,1],[1,5]] 输出：[[1,6],[3,9],[4,5]] 示例 2: 输入：items1 &#x3D; [[1,1],[3,2],[2,3]], items2 &#x3D; [[2,1],[3,2],[1,3]] 输出：[[1,4],[2,4],[3,4]] 示例 3: 输入：items1 &#x3D; [[1,3],[2,2]], items2 &#x3D; [[7,1],[2,2],[1,4]] 输出：[[1,7],[2,4],[7,1]] 解法基本思路： 就是求出现过的每种价值的总重量，价值不重复，自然想到了哈希，开一个 cnt[1001] ，下标表示价值。 刚好，需要按照价值升序排序，从小到大遍历cnt即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int cnt[1001] &#x3D; &#123;0&#125;; for(int i &#x3D; 0; i &lt; items1.size(); ++i)&#123; cnt[items1[i][0]] +&#x3D; items1[i][1]; &#125; for(int i &#x3D; 0; i &lt; items2.size(); ++i)&#123; cnt[items2[i][0]] +&#x3D; items2[i][1]; &#125; for(int i &#x3D; 0; i &lt; 1001; ++i)&#123; if(cnt[i]) ret.push_back(&#123;i, cnt[i]&#125;); &#125; return ret; &#125; &#125;; 191.位1的个数题干编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示：输入必须是长度为 32 的 二进制串 。 示例 示例 1: 输入：n &#x3D; 00000000000000000000000000001011 输出：3 示例 2: 输入：n &#x3D; 11111111111111111111111111111101 输出：31 解法基本思路： 位运算，每位都和1与一下就行。 尝试了一下发现，1移位和n与 ，比 n移位和1与 速度快。 代码class Solution &#123; public: int hammingWeight(uint32_t n) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; 32; ++i)&#123; if ((n &amp; (1 &lt;&lt; i)) &gt; 0) cnt++; &#125; return cnt; &#125; &#125;; 2023.3.12373.矩阵中的局部最大值题干给你一个大小为 n x n 的整数矩阵 grid 。 生成一个大小为 (n - 2) x (n - 2) 的整数矩阵 maxLocal ，并满足： maxLocal[i] [j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。 返回生成的矩阵 示例 示例 1: 输入：grid &#x3D; [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] 输出：[[9,9],[8,6]] 示例 2: 输入：grid &#x3D; [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] 输出：[[2,2,2],[2,2,2],[2,2,2]] 解法基本思路： 暴力for循环。。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; largestLocal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int size &#x3D; grid.size(); vector&lt;vector&lt;int&gt;&gt; res(size - 2, vector&lt;int&gt;(size - 2)); for(int i &#x3D; 0; i &lt; size - 2; ++i)&#123; for(int j &#x3D; 0; j &lt; size - 2; ++j)&#123; for(int x &#x3D; i; x &lt; i + 3; ++x)&#123; for(int y &#x3D; j; y &lt; j + 3; ++y)&#123; res[i][j] &#x3D; max(res[i][j], grid[x][y]); &#125; &#125; &#125; &#125; return res; &#125; &#125;; 2023.3.2面试题05.02.二进制数转字符串题干二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。 如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。 提示： 32位包括输出中的 &quot;0.&quot; 这两位。 题目保证输入用例的小数位数最多只有 6 位 示例 示例 1: 输入：0.625 输出：&quot;0.101&quot; 示例 2: 输入：0.1 输出：&quot;ERROR&quot; 提示：0.1无法被二进制准确表示 解法基本思路： double小数的二进制转化方法，以0.625为例： 0.625 * 2 = 1.25，取整数位1作为小数点后第一位； （1.25 - 1）* 2 = 0.5，取整数位0作为小数点后第二位； 0.5 * 2 = 1，取整数位1作为小数点后第三位； 此时剩余数1 - 1 = 0，不再继续。 解法2： 一种数学证明过程。 代码class Solution &#123; public: string printBin(double num) &#123; string res &#x3D; &quot;0.&quot;; while(res.size() &lt; 32 &amp;&amp; num)&#123; num *&#x3D; 2; if (num &lt; 1) res +&#x3D; &quot;0&quot;; else &#123; res +&#x3D; &quot;1&quot;; --num; &#125; &#125; return num ? &quot;ERROR&quot; : res; &#125; &#125;; 2023.3.31487.保证文件名唯一题干给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。 由于两个文件不能共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。 返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。 示例 示例 1: 输入：names &#x3D; [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;] 输出：[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;] 示例 2: 输入：names &#x3D; [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;] 输出：[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;] 示例 3: 输入：names &#x3D; [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;] 输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;] 解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。 解法基本思路： 看到 “ 唯一 ” ，马上就想到了哈希表。key为实际文件名，value记录当前文件名加上后缀时当前存在的最大值。 直接使用输入的names，用哈希表判断是否有重名，只对重名的元素进行修改并记录在哈希表中，节约空间。 执行用时只击败了18%用户，，，不知时间上还可以怎么缩减。 代码class Solution &#123; public: vector&lt;string&gt; getFolderNames(vector&lt;string&gt;&amp; names) &#123; unordered_map&lt;string, int&gt; hash; for(int i &#x3D; 0; i &lt; names.size(); ++i)&#123; if(hash[names[i]])&#123; int cnt &#x3D; hash[names[i]] - 1; while(hash[names[i] + &quot;(&quot; + to_string(++cnt) + &quot;)&quot;]); hash[names[i]] &#x3D; cnt; names[i] +&#x3D; &quot;(&quot; + to_string(cnt) + &quot;)&quot;; &#125; hash[names[i]] &#x3D; 1; &#125; return names; &#125; &#125;; 1967.作为子字符串出现在单词中的字符串数目题干给你一个字符串数组 patterns 和一个字符串 word ，统计 patterns 中有多少个字符串是 word 的子字符串。返回字符串数目。 子字符串 是字符串中的一个连续字符序列。 示例 示例 1: 输入：patterns &#x3D; [&quot;a&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;d&quot;], word &#x3D; &quot;abc&quot; 输出：3 示例 2: 输入：patterns &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], word &#x3D; &quot;aaaaabbbbb&quot; 输出：2 示例 3: 输入：patterns &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;], word &#x3D; &quot;ab&quot; 输出：3 解法一开始看到字符串匹配，第一反应就是经典的KMP算法。(印象深刻，考研那会儿在k = next[k];上卡了好久hhh) 然而在实际场景中，需要匹配的字符串都是较短且无序随机的，初始化的时间开销、额外的空间开销反而会更消耗资源，在字符串搜索中并不实用。因此提交代码后发现执行用时和内存消耗都不低。 查询了一下，在例如Java的String.indexOf中，使用的是暴力方法进行字符串匹配。在glibc中的strstr函数，则采用的是Two-Way算法。 这些库函数均未使用KMP算法，原因在于： KMP需要对字符串预处理，这个需要花时间，如果做多次查找的话，这部分预处理的时间可以分摊到多次查找里面，平摊后时间较短，但是如果只做一次查找，这部分时间是不能忽略的。 KMP的核心思想是跳跃遍历(而不是逐个字节遍历)但是跳跃遍历破坏了CPU对内存的预取且不能进行SIMD优化。 代码class Solution &#123; public: vector&lt;int&gt; getNextArr(string p)&#123; vector&lt;int&gt; next(p.length()); next[0] &#x3D; -1; int k &#x3D; -1, j &#x3D; 0; while(j &lt; p.length() - 1)&#123; if(k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) next[++j] &#x3D; ++k; else k &#x3D; next[k]; &#125; return next; &#125; int kmp(string pattern, string word)&#123; int i &#x3D; 0, j &#x3D; 0; int pLen &#x3D; pattern.length(), wLen &#x3D; word.length(); vector&lt;int&gt; next &#x3D; getNextArr(pattern); while(i &lt; wLen &amp;&amp; j &lt; pLen)&#123; if(j &#x3D;&#x3D; -1 || word[i] &#x3D;&#x3D; pattern[j])&#123; ++i; ++j; &#125; else&#123; j &#x3D; next[j]; &#125; &#125; return j &#x3D;&#x3D; pattern.length() ? 1 : 0; &#125; int numOfStrings(vector&lt;string&gt;&amp; patterns, string word) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; patterns.size(); ++i) cnt +&#x3D; kmp(patterns[i], word); return cnt; &#125; &#125;; 2023.3.51599.经营摩天轮的最大利润题干你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。 给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。 你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。 返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。 示例 示例 1: 输入：customers &#x3D; [8,3], boardingCost &#x3D; 5, runningCost &#x3D; 6 输出：3 解释：座舱上标注的数字是该座舱的当前游客数。 1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 &#x3D; $14 。 2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 &#x3D; $28 。 3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 &#x3D; $37 。 轮转 3 次得到最大利润，最大利润为 $37 。 示例 2: 输入：customers &#x3D; [10,9,6], boardingCost &#x3D; 6, runningCost &#x3D; 4 输出：7 解释： 1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 &#x3D; $20 。 2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 &#x3D; $40 。 3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 &#x3D; $60 。 4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 &#x3D; $80 。 5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 &#x3D; $100 。 6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 &#x3D; $120 。 7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 &#x3D; $122 。 轮转 7 次得到最大利润，最大利润为$122 。 示例 3: 输入：customers &#x3D; [3,4,0,5,1], boardingCost &#x3D; 1, runningCost &#x3D; 92 输出：-1 解释： 1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 &#x3D; -$89 。 2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 &#x3D; -$177 。 3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 &#x3D; -$269 。 4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 &#x3D; -$356 。 5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 &#x3D; -$447 。 利润永不为正，所以返回 -1 。 解法基本思路： 最开始直接排除掉哪怕坐满（4个游客）都不盈利的情况。 之后一遍for循环肯定是要的，得到在没有新游客来时，轮转的最大收益及所在轮次。 这时计算出每次轮转盈利时需要的最小游客数。 对剩下排队的人数进行判断，如果剩下的人数超过了最小值，则按照4个一轮的最大收益方案计算，一定为最大收益。轮次数加上剩余人数 / 4的商，若余数依旧大于最小值，再加一。 需要注意的是，存在之前for循环中前面的轮次的盈利额与后面轮次的盈利额相同时不更新轮次数的情况，因此有多余人数的情况下，需要先更新轮次数至n。 （总感觉逻辑有哪里不完善。。） 代码class Solution &#123; public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) &#123; if(4 * boardingCost - runningCost &lt;&#x3D; 0) return -1; int curP &#x3D; 0, leftP &#x3D; 0, curVal &#x3D; 0, maxVal &#x3D; 0; int turns &#x3D; -1; for(int i &#x3D; 0; i &lt; customers.size(); ++i)&#123; leftP +&#x3D; customers[i]; curP &#x3D; min(4, leftP); curVal +&#x3D; curP * boardingCost - runningCost; leftP -&#x3D; curP; if(curVal &gt; maxVal)&#123; turns &#x3D; i + 1; maxVal &#x3D; curVal; &#125; &#125; int minP &#x3D; runningCost &#x2F; boardingCost + 1; if (leftP &gt;&#x3D; minP)&#123; if(turns &lt; customers.size()) turns &#x3D; customers.size(); turns +&#x3D; leftP &#x2F; 4 + (leftP % 4 &gt;&#x3D; minP ? 1 : 0); &#125; return turns; &#125; &#125;; 2023.3.61653.使字符串平衡的最少删除次数题干给你一个字符串 s ，它仅包含字符 ‘a’ 和 ‘b’ 。 你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i &lt; j ，且 s[i] = ‘b’ 的同时 s[j]= ‘a’ ，此时认为 s 是 平衡 的。 请你返回使 s 平衡 的 最少 删除次数。 示例 示例 1: 输入：s &#x3D; &quot;aababbab&quot; 输出：2 解释：你可以选择以下任意一种方案： 下标从 0 开始，删除第 2 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aaabbb&quot;）， 下标从 0 开始，删除第 3 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aabbbb&quot;）。 示例 2: 输入：s &#x3D; &quot;bbaaaaabb&quot; 输出：2 解释：唯一的最优解是删除最前面两个字符。 解法基本思路： 存在这么一条分割线，使得通过最少次改动让线左边的字母全是a，右边全是b。 那么把s中每个字符后的位置分别作为分割线，计算需要修改的值，记录其中最小的即可。 如果再对分割线左右进行遍历，双重循环比较浪费时间，可以采用前缀和的方式。 先记录整个 s 中 a 的个数，分割线共有 s.length + 1 个位置，在 s[0] 左边时，意味着整个s中的a都需要修改，把a的个数作为修改次数。 此后分割线每往右移动一格，判断移动时跨过的字符是否为a，如果为a，需要将之前统计的次数 -1 ，若为b，则还需要再 + 1 。 最后返回每个位置中的最小值即可。 代码class Solution &#123; public: int minimumDeletions(string s) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length(); ++i) cnt +&#x3D; &#39;b&#39; - s[i]; int res &#x3D; cnt; for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; cnt -&#x3D; &#39;b&#39; - s[i] ? 1 : -1; res &#x3D; min(res, cnt); &#125; return res; &#125; &#125;; 优化动态规划 将问题拆分，考虑s的最后一个字符： 为 b ，无需删除，问题规模缩小为：使 s 的前 n − 1 个字符平衡的最少删除次数； 为 a ，两种情况，1.删除，问题规模缩小为： 使 s 的前 n − 1 个字符平衡的最少删除次数 + 1；2.保留，需要删除前面的所有 b 。选择其中次数最少的。 定义一个 f[i] 表示：使 s 的前 i 个字符平衡的最少删除次数，可以得到： 为 b ，f[i] = f[i - 1]； 为 a ，min(f[i - 1] + 1, b的数量) 最终答案为 f[n] 。 推理这个公式时，实际是上述思路的逆过程，拆分时从后开始由大到小，计算时从前开始由小到大。 class Solution &#123; public: int minimumDeletions(string s) &#123; int f &#x3D; 0, cnt_b &#x3D; 0; for (char c : s) if (c &#x3D;&#x3D; &#39;b&#39;) ++cnt_b; else f &#x3D; min(f + 1, cnt_b); return f; &#125; &#125;; 2023.3.71422.分割字符串的最大得分题干给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。 「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 示例 示例 1: 输入：s &#x3D; &quot;011101&quot; 输出：5 示例 2: 输入：s &#x3D; &quot;1111&quot; 输出：3 解法基本思路： 和昨天那题一模一样的思路。 代码class Solution &#123; public: int maxScore(string s) &#123; int cnt1 &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123; cnt1 +&#x3D; s[i] - &#39;0&#39;; &#125; int maxVal &#x3D; 0; for(int i &#x3D; 0; i &lt; s.length() - 1; ++i)&#123; cnt1 +&#x3D; s[i] - &#39;0&#39; ? -1 : 1; maxVal &#x3D; max(maxVal, cnt1); &#125; return maxVal; &#125; &#125;; 2023.3.8剑指offer47.礼物的最大价值题干在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 示例 1: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 解法基本思路： 从其中一格到它的右下角只有两种拿法，往下往右或者往右往下，取决于两个里选哪个。第一反应就是动态规划。 如示例1，22处的最大值取决于11的最大值加上12和21中的最大值 ——&gt; 11的最大值取决于00的最大值加上01和10中的最大值. 设 res{i}{j} 为该处的最大值，则有 res{i}{j} = max(res{i - 1}{j}，res{i}{j - 1}) + grid{i - 1}{j - 1}， 结果为res{m}{n} 代码class Solution &#123; public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m &#x3D; grid.size(), n &#x3D; grid[0].size(); vector&lt;vector&lt;int&gt;&gt; res(m+1, vector&lt;int&gt;(n+1)); for(int i &#x3D; 1; i &lt;&#x3D; m; ++i)&#123; for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123; res[i][j] &#x3D; max(res[i - 1][j], res[i][j - 1]) + grid[i - 1][j - 1]; &#125; &#125; return res[m][n]; &#125; &#125;; 剑指offer Ⅱ 060.出现频率最高的k个数字题干给定一个整数数组 nums 和一个整数 k ，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。 进阶：所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 示例 示例 1: 输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2 输出: [1,2] 示例 2: 输入: nums &#x3D; [1], k &#x3D; 1 输出: [1] 解法基本思路： 第一遍for循环遍历，用哈希表存储每个数字出现的次数。 使用优先队列（底层是堆实现），自定义比较方式为从小到大（小根堆），这样堆顶元素是最小的，便于排除。 第二遍for循环将前k个数字出现的次数加入队列，之后的数字若出现次数更多，替换堆顶元素。 代码class Solution &#123; public: struct cmp &#123; bool operator()(pair&lt;int,int&gt; &amp;m,pair&lt;int,int&gt; &amp;n) &#123; return m.second&gt;n.second; &#125; &#125;; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; cnt; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; cnt[nums[i]]++; &#125; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,cmp&gt; q; for(auto x : cnt)&#123; if(q.size() &#x3D;&#x3D; k)&#123; if(x.second &gt; q.top().second)&#123; q.pop(); q.push(x); &#125; &#125; else q.push(x); &#125; vector&lt;int&gt; res; while(!q.empty())&#123; res.push_back(q.top().first); q.pop(); &#125; return res; &#125; &#125;; 2023.3.92379.得到K个黑块的最少涂色次数题干给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 ‘W‘ 要么是 ‘B‘ ，表示第 i 块的颜色。字符 ‘W‘ 和 ‘B‘ 分别表示白色和黑色。 给你一个整数 k ，表示想要 连续 黑色块的数目。每一次操作中，你可以选择一个白色块将它 涂成 黑色块。 请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。 示例 示例 1: 输入：blocks &#x3D; &quot;WBBWWBBWBW&quot;, k &#x3D; 7 输出：3 解释：一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。得到 blocks &#x3D; &quot;BBBBBBBWBW&quot; 。 可以证明无法用少于 3 次操作得到 7 个连续的黑块。所以我们返回 3 。 示例 2: 输入：blocks &#x3D; &quot;WBWBBBW&quot;, k &#x3D; 2 输出：0 解释：不需要任何操作，因为已经有 2 个连续的黑块。所以我们返回 0 。 解法基本思路： 把白色变成黑色的最少操作次数，其实就是求长为k的滑动窗口内白色的数量。 维护双指针增减白色的数量，取最小值即可。 代码class Solution &#123; public: int minimumRecolors(string blocks, int k) &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; k; ++i)&#123; if(blocks[i] - &#39;B&#39;) ++cnt; &#125; int res &#x3D; cnt; for(int i &#x3D; k; i &lt; blocks.length(); ++i)&#123; if(blocks[i] - &#39;B&#39;) ++cnt; if(blocks[i - k] - &#39;B&#39;) --cnt; res &#x3D; min(res, cnt); &#125; return res; &#125; &#125;; 1753.移除石子的最大得分题干你正在玩一个单人游戏，面前放置着大小分别为 a、b 和 c 的 三堆 石子。 每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。 给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。 示例 示例 1: 输入：a &#x3D; 2, b &#x3D; 4, c &#x3D; 6 输出：6 解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是： - 从第一和第三堆取，石子状态现在是 (1, 4, 5) - 从第一和第三堆取，石子状态现在是 (0, 4, 4) - 从第二和第三堆取，石子状态现在是 (0, 3, 3) - 从第二和第三堆取，石子状态现在是 (0, 2, 2) - 从第二和第三堆取，石子状态现在是 (0, 1, 1) - 从第二和第三堆取，石子状态现在是 (0, 0, 0) 总分：6 分 。 示例 2: 输入：a &#x3D; 4, b &#x3D; 4, c &#x3D; 6 输出：7 解法基本思路： 同2335. 代码class Solution &#123; public: int maximumScore(int a, int b, int c) &#123; int res &#x3D; 0; vector&lt;int&gt; arr &#x3D; &#123;a, b, c&#125;; sort(arr.begin(), arr.end()); while(arr[1] !&#x3D; 0)&#123; arr[1]--; arr[2]--; res++; sort(arr.begin(), arr.end()); &#125; return res; &#125; &#125;; 优化 class Solution &#123; public: int maximumScore(int a, int b, int c) &#123; int d &#x3D; max(max(a, b), c), ab &#x3D; a + b + c - d; return ab &lt; d ? ab : (a + b + c) &#x2F; 2; &#125; &#125;; 2023.3.101590.使数组和能被P整除题干给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。 请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。 子数组 定义为原数组中连续的一组元素。 示例 示例 1: 输入：nums &#x3D; [3,1,4,2], p &#x3D; 6 输出：1 解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。 示例 2: 输入：nums &#x3D; [1,2,3], p &#x3D; 3 输出：0 示例 3: 输入：nums &#x3D; [1,2,3], p &#x3D; 7 输出：-1 解法基本思路： **tips1: ** 哨兵思想的应用，处理当前缀和求余等于0时的情况，此时 i 作为下标，表示的位置为第 i + 1 个，因此设为-1。 tips2: 存在前缀和的余数小于总和余数的情况，因此需要 + p ，保证为正数。 tips3: 一开始用的 if(hash[target]) 进行判断，调试时发现这样会产生 hash[target] = 0 的初始化操作，影响后续判断计算，因此改用成员函数count。 代码class Solution &#123; public: int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123; int mod &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i) mod &#x3D; (mod + nums[i]) % p; if(mod &#x3D;&#x3D; 0) return 0; int cur &#x3D; 0, target &#x3D; 0, res &#x3D; nums.size(); unordered_map&lt;int, int&gt; hash; &#x2F;&#x2F; tips1 hash[0] &#x3D; -1; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; cur &#x3D; (cur + nums[i]) % p; &#x2F;&#x2F; tips2 target &#x3D; (cur - mod + p) % p; &#x2F;&#x2F; tips3 if(hash.count(target)) res &#x3D; min(res, i - hash[target]); hash[cur] &#x3D; i; &#125; return res &#x3D;&#x3D; nums.size() ? -1 : res; &#125; &#125;; 2023.3.132383.赢得比赛需要的最少训练时长题干你正在参加一场比赛，给你两个 正 整数 initialEnergy 和 initialExperience 分别表示你的初始精力和初始经验。 另给你两个下标从 0 开始的整数数组 energy 和 experience，长度均为 n 。 你将会 依次 对上 n 个对手。第 i 个对手的精力和经验分别用 energy[i] 和 experience[i] 表示。当你对上对手时，需要在经验和精力上都 严格 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。 击败第 i 个对手会使你的经验 增加 experience[i]，但会将你的精力 减少 energy[i] 。 在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 或者 将精力增加 1 。 返回击败全部 n 个对手需要训练的 最少 小时数目。 示例 示例 1: 输入：initialEnergy &#x3D; 5, initialExperience &#x3D; 3, energy &#x3D; [1,4,3,2], experience &#x3D; [2,6,3,1] 输出：8 示例 2: 输入：initialEnergy &#x3D; 2, initialExperience &#x3D; 4, energy &#x3D; [1], experience &#x3D; [3] 输出：0 解法基本思路： 自身的精力要加到比energy数组的和多1，自身的经验只要每次比当前比较的数多1即可。 代码class Solution &#123; public: int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) &#123; int sumE &#x3D; 0, addEx, minH; for(int i &#x3D; 0; i &lt; energy.size(); ++i) sumE +&#x3D; energy[i]; minH &#x3D; sumE &lt; initialEnergy ? 0 : sumE - initialEnergy + 1; for(int i &#x3D; 0; i &lt; experience.size(); ++i)&#123; addEx &#x3D; initialExperience &gt; experience[i] ? 0 : experience[i] - initialExperience + 1; minH +&#x3D; addEx; initialExperience +&#x3D; experience[i] + addEx; &#125; return minH; &#125; &#125;; 2023.3.141605.给定行和列的和求可行矩阵题干给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。 请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。 请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。 示例 示例 1: 输入：rowSum &#x3D; [3,8], colSum &#x3D; [4,7] 输出：[[3,0], [1,7]] 示例 2: 输入：rowSum &#x3D; [5,7,10], colSum &#x3D; [8,6,8] 输出：[[0,5,0], [6,1,0], [2,0,8]] 示例 3: 输入：rowSum &#x3D; [0], colSum &#x3D; [0] 输出：[[0]] 解法基本思路： 由于保证存在解，直接用贪心即可。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; restoreMatrix(vector&lt;int&gt;&amp; rowSum, vector&lt;int&gt;&amp; colSum) &#123; int row &#x3D; rowSum.size(), col &#x3D; colSum.size(); vector&lt;vector&lt;int&gt;&gt; res(row, vector&lt;int&gt;(col)); for(int i &#x3D; 0; i &lt; row; ++i)&#123; for(int j &#x3D; 0; j &lt; col; ++j)&#123; res[i][j] &#x3D; min(rowSum[i], colSum[j]); rowSum[i] -&#x3D; res[i][j]; colSum[j] -&#x3D; res[i][j]; &#125; &#125; return res; &#125; &#125;; 2023.3.151615.最大网络秩题干n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。 两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。 整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。 示例 示例 1: 输入：n &#x3D; 4, roads &#x3D; [[0,1],[0,3],[1,2],[1,3]] 输出：4 解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。 示例 2: 输入：n &#x3D; 5, roads &#x3D; [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] 输出：5 解释：共有 5 条道路与城市 1 或 2 相连。 示例 3: 输入：n &#x3D; 8, roads &#x3D; [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] 输出：5 解释：2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。 解法基本思路： 暴力解法。统计与每个城市相连的道路数cnt，统计每对城市间是否存在道路，可计算得城市对a、b的最大网络秩为 **cnt[a] + cnt[b] - connected[a] [b]**。 遍历所有不重复的城市对即可。 代码class Solution &#123; public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; vector&lt;int&gt; cnt(n); vector&lt;vector&lt;int&gt;&gt; connected(n, vector&lt;int&gt;(n)); for(auto pair : roads)&#123; cnt[pair[0]]++; cnt[pair[1]]++; connected[pair[0]][pair[1]] &#x3D; 1; connected[pair[1]][pair[0]] &#x3D; 1; &#125; int maxRank &#x3D; 0, rank; for(int i &#x3D; 0; i &lt; n ; ++i)&#123; for(int j &#x3D; i + 1; j &lt; n ; ++j)&#123; rank &#x3D; cnt[i] + cnt[j] - connected[i][j]; maxRank &#x3D; max(maxRank, rank); &#125; &#125; return maxRank; &#125; &#125;; 441.排列硬币题干你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。 示例 示例 1: 输入：n &#x3D; 5 输出：2 示例 2: 输入：n &#x3D; 8 输出：3 解法 解方程 二分查找 代码1.因为n取值很大，乘以常数后可能超出int取值范围，因此需转化为long long型。 class Solution &#123; public: int arrangeCoins(int n) &#123; return static_cast&lt;int&gt;((sqrt(8 * (long long)n + 1) - 1) &#x2F; 2); &#125; &#125;; 2.一开始使用了暴力for循环，太慢了，就想到了二分进行优化。 class Solution &#123; public: int arrangeCoins(int n) &#123; int l &#x3D; 1, r &#x3D; n; while(l &lt; r)&#123; int mid &#x3D; l + (r - l + 1) &#x2F; 2; if((long long)mid * (mid + 1) &lt;&#x3D; (long long)2 * n) l &#x3D; mid; else r &#x3D; mid - 1; &#125; return l; &#125; &#125;; LCP 02.分式简化题干有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？ 连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。 输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组**[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1**。 示例 示例 1: 输入：cont &#x3D; [3, 2, 0, 2] 输出：[13, 4] 解释：原连分数等价于3 + (1 &#x2F; (2 + (1 &#x2F; (0 + 1 &#x2F; 2))))。注意[26, 8], [-13, -4]都不是正确答案。 示例 2: 输入：cont &#x3D; [0, 0, 3] 输出：[3, 1] 解释：如果答案是整数，令分母为1即可。 解法数学 代码class Solution &#123; public: vector&lt;int&gt; fraction(vector&lt;int&gt;&amp; cont) &#123; int m &#x3D; 1, n &#x3D; 0; for(int i &#x3D; cont.size() - 1; i &gt; 0; --i)&#123; int temp &#x3D; m; m &#x3D; cont[i] * m + n; n &#x3D; temp; &#125; return &#123;cont[0] * m + n, m&#125;; &#125; &#125;; 2023.3.172389.和有限的最长子序列题干给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。 返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和 小于等于 queries[i] 的 子序列 的 最大 长度 。 子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。 示例 示例 1: 输入：nums &#x3D; [4,5,2,1], queries &#x3D; [3,10,21] 输出：[2,3,4] 示例 2: 输入：nums &#x3D; [2,3,4,5], queries &#x3D; [1] 输出：[0] 解法基本思路： 先给nums排个序，然后for循环比较queries每个元素最大比前几个nums的元素和大就行。 自己的方法是直接暴力求和一个个比较过去； 题解采用了前缀和统计+二分查找的方法来优化比较的起始位置，但是实际提交发现在给定的测试用例中好像并没有比暴力快。 哦，我就看了个标题，代码里用的 upper_bound() 库函数，难怪比我自己实现的快。 代码class Solution &#123; public: &#x2F;&#x2F; 我的方案 vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; queries.size(); ++i)&#123; int sum &#x3D; 0, cnt &#x3D; 0; while(queries[i] &gt;&#x3D; sum &amp;&amp; cnt &lt; nums.size()) sum +&#x3D; nums[cnt++]; if(sum &gt; queries[i]) cnt--; queries[i] &#x3D; cnt; &#125; return queries; &#125; &#125;; class Solution &#123; public: &#x2F;&#x2F; 题解方法：前缀和+二分查找 int binarySearch(vector&lt;int&gt;&amp; nums, int num)&#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt; r)&#123; int mid &#x3D; (r - l + 1) &#x2F; 2 + l; if (nums[mid] &lt;&#x3D; num) l &#x3D; mid; else r &#x3D; mid - 1; &#125; return l; &#125; vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123; vector&lt;int&gt; sums(nums.size()); sort(nums.begin(), nums.end()); sums[0] &#x3D; nums[0]; for(int i &#x3D; 1; i &lt; nums.size(); ++i)&#123; sums[i] &#x3D; nums[i] + sums[i - 1]; &#125; for(int i &#x3D; 0; i &lt; queries.size(); ++i)&#123; int idx &#x3D; binarySearch(nums, queries[i]); while(queries[i] &lt; sums[idx] &amp;&amp; idx &gt;&#x3D; 0)&#123; if(--idx &lt; 0) break; &#125; queries[i] &#x3D; idx + 1; &#125; return queries; &#125; &#125;; 1254.统计封闭岛屿的数目题干二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。 请返回 封闭岛屿 的数目。 示例 示例 1: 输入：grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] 输出：2 示例 2: 输入：grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] 输出：1 解法基本思路： 可以发现封闭岛屿必然不会出现在矩阵的边缘，因为需要被1全包裹。 也就是说可以先统计全部的岛屿数量，然后去除在边缘的岛屿就是答案。 可以用DFS，向四个方向搜索来找到一个连通域（想到了图像处理里的找连通域，简化版）。但是不方便在DFS函数中去统计总数，所以想到了标记（覆盖 / 污染）。 DFS的作用为标记一整个连通域为1. 那么只要先把边缘的连通域都标记为1，之后剩下的连通域每标记一个，就cnt++就行。 代码class Solution &#123; public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y)&#123; int m &#x3D; grid.size(), n &#x3D; grid[0].size(); if(x &lt; 0 || x &gt;&#x3D; m || y &lt; 0 || y &gt;&#x3D; n) return; if(grid[x][y]) return; grid[x][y] &#x3D; 2; dfs(grid, x, y + 1); dfs(grid, x + 1, y); dfs(grid, x, y - 1); dfs(grid, x - 1, y); &#125; int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m &#x3D; grid.size(), n &#x3D; grid[0].size(); for(int i &#x3D; 0; i &lt; m; ++i)&#123; dfs(grid, i, 0); dfs(grid, i, n - 1); &#125; for(int i &#x3D; 0; i &lt; n; ++i)&#123; dfs(grid, 0, i); dfs(grid, m - 1, i); &#125; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; m; ++i)&#123; for(int j &#x3D; 0; j &lt; n; ++j)&#123; if(!grid[i][j])&#123; cnt++; dfs(grid, i, j); &#125; &#125; &#125; return cnt; &#125; &#125;; 2023.3.181616.分割两个字符串得到回文串题干给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。 当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。 注意， x + y 表示连接字符串 x 和 y 。 示例 示例 1: 输入：a &#x3D; &quot;x&quot;, b &#x3D; &quot;y&quot; 输出：true 示例 2: 输入：a &#x3D; &quot;abdef&quot;, b &#x3D; &quot;fecab&quot; 输出：true 解法基本思路： 双指针。 回文串其实是分为两部分对应的。第一部分是a的头和b的尾（可能为空），第二部分是ab任一的中部（也可能为空）。 那么只需要维护两个指针，分别从a头b尾向中间扫描对比，遇到不同的字符就跳转到第二部分，a和b中间部分（区间 [l, r]）若是回文串，则返回ture。否则再从b头a尾开始重复一遍。 写法可能有点问题，和一个题解思路相同但是速度慢了一些。 代码class Solution &#123; public: bool isPalindrome(string s, int l, int r)&#123; while(s[l] &#x3D;&#x3D; s[r])&#123; if(r - l &gt; 2)&#123; l++; r--; &#125; else return true; &#125; return false; &#125; bool checkPalindromeFormation(string a, string b) &#123; int l &#x3D; 0, r &#x3D; b.length() - 1; while(a[l] &#x3D;&#x3D; b[r])&#123; if(r - l &gt; 2)&#123; l++; r--; &#125; else return true; &#125; if(isPalindrome(a, l, r) || isPalindrome(b, l, r)) return true; l &#x3D; 0; r &#x3D; a.length() - 1; while(b[l] &#x3D;&#x3D; a[r])&#123; if(r - l &gt; 2)&#123; l++; r--; &#125; else return true; &#125; if(isPalindrome(b, l, r) || isPalindrome(a, l, r)) return true; return false; &#125; &#125;; 2032.至少在两个数组中出现的值题干给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 元素各不相同的 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。 示例 示例 1: 输入：nums1 &#x3D; [1,1,3,2], nums2 &#x3D; [2,3], nums3 &#x3D; [3] 输出：[3,2] 示例 2: 输入：nums1 &#x3D; [1,2,2], nums2 &#x3D; [4,3,3], nums3 &#x3D; [5] 输出：[] 解法基本思路：枚举。 代码class Solution &#123; public: vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) &#123; vector&lt;int&gt; res; int cnt1[101] &#x3D; &#123;0&#125;; int cnt2[101] &#x3D; &#123;0&#125;; int cnt3[101] &#x3D; &#123;0&#125;; for(auto x : nums1) cnt1[x] &#x3D; 1; for(auto x : nums2) cnt2[x] &#x3D; 1; for(auto x : nums3) cnt3[x] &#x3D; 1; for(int i &#x3D; 1; i &lt; 101; ++i)&#123; if(cnt1[i] + cnt2[i] + cnt3[i] &gt; 1) res.push_back(i); &#125; return res; &#125; &#125;; 1984.学生分数的最小差值题干给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。 从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。 返回可能的 最小差值 。 示例 示例 1: 输入：nums &#x3D; [90], k &#x3D; 1 输出：0 示例 2: 输入：nums &#x3D; [9,4,1,7], k &#x3D; 2 输出：2 解法基本思路： 先给nums排序，然后遍历找长度为k的子数组的最大差值中的最小值。 代码class Solution &#123; public: int minimumDifference(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int minSub &#x3D; nums.back() - nums[0]; for(int i &#x3D; 0; i &lt; nums.size() - k + 1; ++i) minSub &#x3D; min(minSub, nums[i + k - 1] - nums[i]); return minSub; &#125; &#125;; 2465.不同的平均值数目题干给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。 只要 nums 不是 空数组，你就重复执行以下步骤： 找到 nums 中的最小值，并删除它。 找到 nums 中的最大值，并删除它。 计算删除两数的平均值。 比方说，2 和 3 的平均值是 (2 + 3) / 2 = 2.5 。返回上述过程能得到的 不同 平均值的数目。 注意 ，如果最小值或者最大值有重复元素，可以删除任意一个。 示例 示例 1: 输入：nums &#x3D; [4,1,4,0,3,5] 输出：2 示例 2: 输入：nums &#x3D; [1,100] 输出：1 解法基本思路： 先给nums排序，然后双指针每次分别从头尾各取一个值计算平均值加入哈希表，最后返回哈希表中的键值对数。 代码class Solution &#123; public: int distinctAverages(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;double, int&gt; res; sort(nums.begin(), nums.end()); for(int i &#x3D; 0, j &#x3D; nums.size() - 1; i &lt; nums.size() &#x2F; 2; ++i, --j) res[(nums[i] + nums[j]) &#x2F; 2.0] &#x3D; 1; return res.size(); &#125; &#125;; 8.字符串转换整数题干实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例 示例 1: 输入：s &#x3D; &quot;42&quot; 输出：42 示例 2: 输入：s &#x3D; &quot; -42&quot; 输出：-42 示例 3： 输入：s &#x3D; &quot;4193 with words&quot; 输出：4193 解法基本思路： 简单的if判断。 结果可能超出int，因此用long long存储； 用sign为1 或 -1表示符号位方便计算； 宏定义 INT_MAX 和 INT_MIN 。 代码class Solution &#123; public: int myAtoi(string s) &#123; int sign &#x3D; 1; bool isPre &#x3D; true; long long res &#x3D; 0; for(auto x : s)&#123; if(isPre)&#123; if(x &#x3D;&#x3D; &#39; &#39;) continue; else if(x &#x3D;&#x3D; &#39;+&#39;) isPre &#x3D; false; else if(x &#x3D;&#x3D; &#39;-&#39;)&#123; isPre &#x3D; false; sign &#x3D; -1; &#125; else if(x &gt;&#x3D; &#39;0&#39; &amp;&amp; x &lt;&#x3D; &#39;9&#39;)&#123; isPre &#x3D; false; res &#x3D; x - &#39;0&#39;; &#125; else return 0; &#125; else&#123; if(x &gt;&#x3D; &#39;0&#39; &amp;&amp; x &lt;&#x3D; &#39;9&#39;)&#123; res &#x3D; res * 10 + x - &#39;0&#39;; if(res * sign &gt; INT_MAX) return INT_MAX; if(res * sign &lt; INT_MIN) return INT_MIN; &#125; else return res * sign; &#125; &#125; return res * sign; &#125; &#125;; 2023.3.212469.温度转换题干给你一个四舍五入到两位小数的非负浮点数 celsius 来表示温度，以 摄氏度（Celsius）为单位。 你需要将摄氏度转换为 开氏度（Kelvin）和 华氏度（Fahrenheit），并以数组 ans = [kelvin, fahrenheit] 的形式返回结果。 返回数组 ans 。与实际答案误差不超过 10e-5 的会视为正确答案。 开氏度 = 摄氏度 + 273.15 华氏度 = 摄氏度 * 1.80 + 32.00 示例 示例 1: 输入：celsius &#x3D; 36.50 输出：[309.65000,97.70000] 示例 2: 输入：celsius &#x3D; 122.11 输出：[395.26000,251.79800] 解法基本思路：。。。 代码class Solution &#123; public: vector&lt;double&gt; convertTemperature(double celsius) &#123; return &#123;celsius + 273.15, celsius * 1.8 + 32&#125;; &#125; &#125;; 2023.3.262395.和相等的子数组题干给你一个下标从 0 开始的整数数组 nums ，判断是否存在 两个 长度为 2 的子数组且它们的 和 相等。注意，这两个子数组起始位置的下标不相同 。如果这样的子数组存在，请返回 true，否则返回 false 。 子数组 是一个数组中一段连续非空的元素组成的序列。 示例 示例 1: 输入：nums &#x3D; [4,2,4] 输出：true 示例 2: 输入：nums &#x3D; [0,0,0] 输出：true 解法基本思路：哈希表的唯一性作为判断依据。 代码class Solution &#123; public: bool findSubarrays(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; sums; for(int i &#x3D; 1; i &lt; nums.size(); ++i)&#123; int sum &#x3D; nums[i-1] + nums[i]; if(sums.count(sum)) return true; sums.emplace(sum); &#125; return false; &#125; &#125;; 215.数组中的第K个最大元素题干给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 示例 1: 输入: [3,2,1,5,6,4], k &#x3D; 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6], k &#x3D; 4 输出: 4 解法基本思路： 要求时间复杂度为 O(n) 。快排和堆排的时间复杂度均为O(nlogn) ，本题实际用到了其中的一部分：快排的单趟排序和堆排的建堆，都是 O(n) 的时间复杂度。 以快排从大到小为例， 每次单趟排序把一个数放到正确的位置上。此时该位置左边的数都大于该值，右边都小于。该值所在位置和 k - 1 进行比较即可判断在该值的哪一边。然后缩小排序范围，仅在其中一边的范围内再次进行单趟排序，直至位置为 k - 1 为止。 代码class Solution &#123; public: int quickSingleSort(vector&lt;int&gt;&amp; nums, int l, int r)&#123; int pivot &#x3D; l; while(l &lt; r)&#123; while(l &lt; r &amp;&amp; nums[pivot] &gt;&#x3D; nums[r]) r--; while(l &lt; r &amp;&amp; nums[pivot] &lt;&#x3D; nums[l]) l++; if(l &lt; r) swap(nums[l], nums[r]); &#125; swap(nums[pivot], nums[l]); return l; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(1)&#123; int idx &#x3D; quickSingleSort(nums, l, r); if(idx &#x3D;&#x3D; k - 1) return nums[idx]; else if(idx &lt; k - 1) l &#x3D; idx + 1; else r &#x3D; idx - 1; &#125; &#125; &#125;; 1588.所有奇数长度子数组的和题干给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 进阶：你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？ 示例 示例 1: 输入：arr &#x3D; [1,4,2,5,3] 输出：58 示例 2: 输入：arr &#x3D; [1,2] 输出：3 解法基本思路：问题转化为数学题了属于是。 转化为：统计数组中每个元素出现在所有不同子数组中的次数。 可以发现，在一个奇数长度子数组中，除去一个指定元素外，剩余元素数量必然为偶数，那么可以得到：该元素左右两侧的元素数量的奇偶性相同。 以示例1为例，1的左侧数量0，右侧数量4，那么左侧奇数可选组合为0，偶数可选组合为1（只有一个0）；右侧奇数可选组合数为2（1、3），偶数可选3（0、2、4），那么1可能的所有组合数为：0 * 2 + 1 * 3 = 3。可以得到：元素总出现次数 = 左侧偶数选择 * 右侧偶数选择 + 左侧奇数选择 * 右侧奇数选择。 根据2中规律，只需for循环一次即可，也就是 O(n) 时间复杂度。 代码class Solution &#123; public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int n &#x3D; arr.size(); int res &#x3D; 0; for(int i &#x3D; 0; i &lt; n; ++i)&#123; int lEven &#x3D; i &#x2F; 2 + 1; int rEven &#x3D; (n - i - 1) &#x2F; 2 + 1; int lOdd &#x3D; (i + 1) &#x2F; 2; int rOdd &#x3D; (n - i) &#x2F; 2; int num &#x3D; lEven * rEven + lOdd * rOdd; res +&#x3D; num * arr[i]; &#125; return res; &#125; &#125;; 2023.3.271638.统计只差一个字符的子串数目题干给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。 比方说， “computer” and “computation” 只有一个字符不同： ‘e’/‘a’ ，所以这一对子字符串会给答案加 1 。 请你返回满足上述条件的不同子字符串对数目。 示例 示例 1: 输入：s &#x3D; &quot;aba&quot;, t &#x3D; &quot;baba&quot; 输出：6 示例 2: 输入：s &#x3D; &quot;ab&quot;, t &#x3D; &quot;bb&quot; 输出：3 解法基本思路：枚举。 双层for循环，枚举 s 和 t 中的每个 i 、j ，当这两个字符不同时，子串的其余字符均相同。 此时对这两个字符分别向左和右扩散比较，相同则计数（l、r）+1，不同则停止。可以发现这样的不同子串有 （1 + l）*（1 + r）个。对枚举的每个字符进行这样的操作，统计总子串数即可。 代码class Solution &#123; public: int countSubstrings(string s, string t) &#123; int m &#x3D; s.length(), n &#x3D; t.length(); int res &#x3D; 0; for(int i &#x3D; 0; i &lt; m; ++i)&#123; for(int j &#x3D; 0; j &lt; n; ++j)&#123; if(s[i] !&#x3D; t[j])&#123; int l &#x3D; 1, r &#x3D; 1; int p &#x3D; i - 1, q &#x3D; j - 1; while(p &gt;&#x3D; 0 &amp;&amp; q &gt;&#x3D; 0 &amp;&amp; s[p--] &#x3D;&#x3D; t[q--]) l++; p &#x3D; i + 1, q &#x3D; j + 1; while(p &lt; m &amp;&amp; q &lt; n &amp;&amp; s[p++] &#x3D;&#x3D; t[q++]) r++; res +&#x3D; l * r; &#125; &#125; &#125; return res; &#125; &#125;; 1438.绝对差不超过限制的最长连续子数组题干给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 。 示例 示例 1: 输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4 输出：2 示例 2: 输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0 输出：3 解法基本思路：双指针滑动窗口。 右指针r主动移动，左指针l被动移动（超出limit时）。需要一个数据结构来维护子数组有序（顺序容器中的map和set），由于存在重复数字，采用multiset。 注： begin() == rend() 均指向第一个元素，rbegin() 指向最后一个元素，end() 指向最后一个元素的下一个。 在multiset中，erase(elem) 擦除的是值等于elem的所有元素。 代码class Solution &#123; public: int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) &#123; multiset&lt;int&gt; sub; int l &#x3D; 0, r &#x3D; 0; int res &#x3D; 0; while(r &lt; nums.size())&#123; sub.emplace(nums[r]); while(*sub.rbegin() - *sub.begin() &gt; limit) sub.erase(sub.find(nums[l++])); res &#x3D; max(res, r - l + 1); r++; &#125; return res; &#125; &#125;; 424.替换后的最长重复字符题干给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。 在执行上述操作后，返回包含相同字母的最长子字符串的长度。 示例 示例 1: 输入：s &#x3D; &quot;ABAB&quot;, k &#x3D; 2 输出：4 示例 2: 输入：s &#x3D; &quot;AABABBA&quot;, k &#x3D; 1 输出：4 解法基本思路：双指针滑动窗口。 和上题（1438）思路类似的滑动窗口双指针，统计需要修改的字符数是否超过k。因为不确定最后的子串是哪个字符，因此先将所有不同字符加入集合，全循环一遍。 代码class Solution &#123; public: int characterReplacement(string s, int k) &#123; unordered_set&lt;char&gt; letter; for(char c : s) letter.emplace(c); int res &#x3D; 0; for(char c : letter)&#123; int l &#x3D; 0, r &#x3D; 0; int cnt &#x3D; 0; while(r &lt; s.length())&#123; if(s[r] !&#x3D; c) cnt++; while(cnt &gt; k)&#123; if(s[l] !&#x3D; c) cnt--; l++; &#125; res &#x3D; max(res, r - l + 1); r++; &#125; &#125; return res; &#125; &#125;; 2023.3.281092.最短公共超序列（未完结）题干给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。 （如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列） 示例 示例 1: 输入：str1 &#x3D; &quot;abac&quot;, str2 &#x3D; &quot;cab&quot; 输出：&quot;cabac&quot; 解释： str1 &#x3D; &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。 str2 &#x3D; &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。 最终我们给出的答案是满足上述属性的最短字符串。 解法基本思路：动态规划+双指针。 我们要找的目的字符串由三部分组成：两个字符串的最长公共子序列LCS + 第一个字符串除去LCS之后的序列 + 第二个字符串除去LCS之后的序列。同一个字符串中的字符的相对顺序不可改变，所以我们可以用字符串与LCS比较来确定字符的相对位置。 此题转化为了先求解LCS，再去构建目的字符串。 LCS部分： 定义 f [i] [j] ** 表示考虑 str1 的前 i 个字符、str2** 的前 j 的字符所形成的最长公共子序列长度。 可得状态转移方程： 在代码中为了计算方便，在两个string前添加一个空格，令下标从1开始。 构建目的字符串部分： 采用双指针 p、q 分别指向两个string的尾部。 当 p 或 q 走完（p == 0 || q == 0），直接将另一字符串剩余部分加入结果中。 当指向的两个字符相同时，该字符为LCS中的字符，加入结果，双指针同时自减。 根据第一部分得到的状态数组f，判断： **f [p] [q] == f [p - 1] [q] **时，str1[p] 加入结果，p–。 **f [p] [q] == f [p] [q - 1] **时，str2[q] 加入结果，q–。 最后，由于是从尾部向前构造，与实际答案相反，因此需要翻转。 代码class Solution &#123; public: string shortestCommonSupersequence(string str1, string str2) &#123; int m &#x3D; str1.length(), n &#x3D; str2.length(); str1 &#x3D; &quot; &quot; + str1; str2 &#x3D; &quot; &quot; + str2; vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1)); for(int i &#x3D; 1; i &lt;&#x3D; m; ++i)&#123; for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123; if(str1[i] &#x3D;&#x3D; str2[j]) f[i][j] &#x3D; f[i-1][j-1] + 1; else f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]); &#125; &#125; int p &#x3D; m, q &#x3D; n; string res; while(p &gt; 0 || q &gt; 0)&#123; if(p &#x3D;&#x3D; 0) res +&#x3D; str2[q--]; else if(q &#x3D;&#x3D; 0) res +&#x3D; str1[p--]; else&#123; if(str1[p] &#x3D;&#x3D; str2[q])&#123; res +&#x3D; str1[p--]; q--; &#125; else if(f[p][q] &#x3D;&#x3D; f[p-1][q]) res +&#x3D; str1[p--]; else res +&#x3D; str2[q--]; &#125; &#125; return string(res.rbegin(), res.rend()); &#125; &#125;; 1550.存在连续三个奇数的数组题干给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。 示例 示例 1: 输入：arr &#x3D; [2,6,4,1] 输出：false 示例 2: 输入：arr &#x3D; [1,2,34,3,4,5,7,23,12] 输出：true 解法基本思路：简单的if判断。 代码class Solution &#123; public: bool threeConsecutiveOdds(vector&lt;int&gt;&amp; arr) &#123; int limit &#x3D; 0; for(int num : arr)&#123; if(num % 2) limit++; else limit &#x3D; 0; if(limit &gt; 2) return true; &#125; return false; &#125; &#125;; 1991.找到数组的中间位置题干给你一个下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （也就是所有可能中间位置下标最小的一个）。 中间位置 middleIndex 是满足 nums[0] + nums[1] + … + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + … + nums[nums.length-1] 的数组下标。如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ，右边部分的和定义为 0 。 请你返回满足上述条件 最左边 的 middleIndex ，如果不存在这样的中间位置，请你返回 -1 。 示例 示例 1: 输入：nums &#x3D; [2,3,-1,8,4] 输出：3 示例 2: 输入：nums &#x3D; [1,-1,4] 输出：2 解法基本思路：前缀和。 在比较的过程中计算局部前缀和，调用库函数accumulate，相对节约时间和空间一点。 代码class Solution &#123; public: int findMiddleIndex(vector&lt;int&gt;&amp; nums) &#123; int sum &#x3D; accumulate(nums.begin(), nums.end(), 0); int preSum &#x3D; 0; for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if(sum - nums[i] &#x3D;&#x3D; 2 * preSum) return i; preSum +&#x3D; nums[i]; &#125; return -1; &#125; &#125;; 2023.3.291641.统计字典序元音字符串的数目题干给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。 字符串 s 按字典序排列需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。 示例 示例 1: 输入：n &#x3D; 1 输出：5 示例 2: 输入：n &#x3D; 2 输出：15 解法基本思路：动态规划。 代码class Solution &#123; public: int countVowelStrings(int n) &#123; vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(5)); for(int i &#x3D; 0; i &lt; 5; ++i) f[0][i] &#x3D; 1; for(int i &#x3D; 1; i &lt; n; ++i) for(int j &#x3D; 0; j &lt; 5; ++j) for(int k &#x3D; 0; k &lt;&#x3D; j; ++k) f[i][j] +&#x3D; f[i - 1][k]; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; 5; ++i) res +&#x3D; f[n - 1][i]; return res; &#125; &#125;; 优化空间优化：二维数组 ——&gt; 一维数组。 因为最终要求的实际是 n - 1 处的前缀和，过程中的值并不需要，因此可以省略二维数组中的第一维（i），通过直接修改的的方式不断更新一维数组的值直到 n - 1。 class Solution &#123; public: int countVowelStrings(int n) &#123; int f[5] &#x3D; &#123;1, 1, 1, 1, 1&#125;; for(int i &#x3D; 0; i &lt; n - 1; ++i)&#123; int sum &#x3D; 0; for(int j &#x3D; 0; j &lt; 5; ++j)&#123; sum +&#x3D; f[j]; f[j] &#x3D; sum; &#125; &#125; int res &#x3D; 0; for(int i &#x3D; 0; i &lt; 5; ++i) res +&#x3D; f[i]; return res; &#125; &#125;; 15.三数之和题干给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。 请你返回所有和为 0 且不重复的三元组。 注意，输出的顺序和三元组的顺序并不重要。 示例 示例 1: 输入：nums &#x3D; [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2: 输入：nums &#x3D; [0,1,1] 输出：[] 解法基本思路：排序 + 双指针。 考虑到和为0，三数之中必有正负或全0，且顺序不重要，那么先排个序肯定方便计算。 三个数，考虑用三个指针，其中for循环指针指定最左侧的数，从左往右遍历，那么剩下双指针只需要考虑该数右侧的部分即可（避免重复）。 双指针指向该数右侧子数组的两端，分别向中间移动判断。 需要注意的去重情况有： 当最左侧数大于0时，右侧两数也大于0，sum必大于0，直接结束循环。 当最左侧数 nums [i] == nums [i - 1] 时，此时双指针移动得到的三元组是一样的，跳过。 同上，当左指针 nums[l] == nums[l + 1] 时，三元组重复，跳过，l++。 当右指针 nums[r] == nums[r + 1] 时，三元组重复，跳过，r–。 去重后，根据sum的值大于或小于0判断移动右指针还是左指针。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int l &#x3D; i + 1, r &#x3D; nums.size() - 1; if(nums[i] &gt; 0) break; if(i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; while(l &lt; r)&#123; int sum &#x3D; nums[i] + nums[l] + nums[r]; if(sum &#x3D;&#x3D; 0)&#123; while(l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l + 1]) l++; while(l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r - 1]) r--; res.push_back(&#123;nums[i], nums[l++], nums[r--]&#125;); &#125; else if(sum &gt; 0) r--; else l++; &#125; &#125; return res; &#125; &#125;; 16.最接近的三数之和题干给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。 假定每组输入只存在恰好一个解。 示例 示例 1: 输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1 输出：2 示例 2: 输入：nums &#x3D; [0,0,0], target &#x3D; 1 输出：0 解法基本思路：排序 + 双指针。 同15题思路：排序肯定方便计算。三个数三个指针，其中for循环指针指定最左侧的数，从左往右遍历，那么剩下双指针只需要考虑该数右侧的部分即可（避免重复）。双指针指向该数右侧子数组的两端，分别向中间移动判断。 不需要去重，只用计算和与target比较，根据大小判断移动哪个指针； 维护结果变量res，如果 和与target的差值 小于 res与target的差值，就更新res为本次的和。 代码class Solution &#123; public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int res &#x3D; nums[0] + nums[1] + nums[2]; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int l &#x3D; i + 1, r &#x3D; nums.size() - 1; while(l &lt; r)&#123; int sum &#x3D; nums[i] + nums[l] + nums[r]; if(abs(target - sum) &lt; abs(target - res)) res &#x3D; sum; if(sum &gt; target) r--; else if(sum &lt; target) l++; else return res; &#125; &#125; return res; &#125; &#125;; 18.四数之和题干给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 示例 1: 输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2: 输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8 输出：[[2,2,2,2]] 解法基本思路：排序 + 双指针。 思路同15.三数之和，无非外面多加了层循环。 需要注意的去重情况有： 当最左侧数 nums [i] == nums [i - 1] 时，此时双指针移动得到的四元组是一样的，跳过。 当左侧第二个数 nums [j] == nums [j - 1] 时，此时双指针移动得到的四元组是一样的，跳过。 同上，当左指针 nums[l] == nums[l + 1] 时，四元组重复，跳过，l++。 当右指针 nums[r] == nums[r + 1] 时，四元组重复，跳过，r–。 去重后，根据sum的值大于或小于0判断移动右指针还是左指针。 注意越界问题，sum使用 long 记录。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; if(i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; for(int j &#x3D; i + 1; j &lt; nums.size(); ++j)&#123; int l &#x3D; j + 1, r &#x3D; nums.size() - 1; if(j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue; while(l &lt; r)&#123; long sum &#x3D; (long)nums[i] + nums[j] + nums[l] + nums[r]; if(sum &#x3D;&#x3D; target)&#123; while(l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l + 1]) l++; while(l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r - 1]) r--; res.push_back(&#123;nums[i], nums[j], nums[l++], nums[r--]&#125;); &#125; else if(sum &gt; target) r--; else l++; &#125; &#125; &#125; return res; &#125; &#125;; 2023.3.301637.两点之间不包含任何点的最宽垂直区域题干给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直区域 的宽度。垂直区域 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直区域 为宽度最大的一个垂直区域。 请注意，垂直区域 边上 的点 不在 区域内。 示例 示例 1: 输入：points &#x3D; [[8,7],[9,9],[7,4],[9,7]] 输出：1 示例 2: 输入：points &#x3D; [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]] 输出：3 解法基本思路：排序。 其实就是求所有点 x 坐标之间的最大差值。按第一位排序，然后求最大差值即可。 代码class Solution &#123; public: int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(points.begin(), points.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125;); int res &#x3D; 0; for(int i &#x3D; 1; i &lt; points.size(); ++i) res &#x3D; max(res, points[i][0] - points[i-1][0]); return res; &#125; &#125;; 优化 class Solution &#123; public: int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int n &#x3D; points.size(); vector&lt;int&gt; nums; for (auto&amp; p : points) &#123; nums.push_back(p[0]); &#125; const int inf &#x3D; 1 &lt;&lt; 30; int mi &#x3D; inf, mx &#x3D; -inf; for (int v : nums) &#123; mi &#x3D; min(mi, v); mx &#x3D; max(mx, v); &#125; int bucketSize &#x3D; max(1, (mx - mi) &#x2F; (n - 1)); int bucketCount &#x3D; (mx - mi) &#x2F; bucketSize + 1; vector&lt;pair&lt;int, int&gt;&gt; buckets(bucketCount, &#123;inf, -inf&#125;); for (int v : nums) &#123; int i &#x3D; (v - mi) &#x2F; bucketSize; buckets[i].first &#x3D; min(buckets[i].first, v); buckets[i].second &#x3D; max(buckets[i].second, v); &#125; int ans &#x3D; 0; int prev &#x3D; inf; for (auto [curmin, curmax] : buckets) &#123; if (curmin &gt; curmax) continue; ans &#x3D; max(ans, curmin - prev); prev &#x3D; curmax; &#125; return ans; &#125; &#125;; 704.二分查找题干给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 示例 1: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9 输出: 4 示例 2: 输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出: -1 解法基本思路：二分查找。 当二分查找的双指针是闭区间 [ l, r ] 时while中判断是 &lt;= ；当左闭右开时，while中使用 &lt; ，**r = num.size()**。 代码class Solution &#123; public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if(nums[mid] &#x3D;&#x3D; target) return mid; else if(nums[mid] &gt; target) r &#x3D; mid - 1; else l &#x3D; mid + 1; &#125; return -1; &#125; &#125;; 35.搜索插入位置题干给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。 示例 示例 1: 输入: nums &#x3D; [1,3,5,6], target &#x3D; 5 输出: 2 示例 2: 输入: nums &#x3D; [1,3,5,6], target &#x3D; 7 输出: 4 解法基本思路：二分查找。 和704.二分查找一样，最后return的值改成双指针相遇的位置，就是应该插入的位置。 代码class Solution &#123; public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if(nums[mid] &lt; target) l &#x3D; mid + 1; else if(nums[mid] &gt; target) r &#x3D; mid - 1; else return mid; &#125; return l; &#125; &#125;; 34.在排序数组中查找元素的第一个和最后一个位置题干给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 **[-1, -1]**。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 示例 1: 输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8 输出：[3,4] 示例 2: 输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6 输出：[-1,-1] 解法基本思路：二分查找。 需要两次二分查找，找左边的就不断将右指针向左压缩，找到target后继续压缩直至左右指针重合，找右边同理。 代码class Solution &#123; public: int findRange(vector&lt;int&gt;&amp; nums, int target, bool isLeft)&#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; int res &#x3D; -1; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if(nums[mid] &lt; target) l &#x3D; mid + 1; else if(nums[mid] &gt; target) r &#x3D; mid - 1; else&#123; res &#x3D; mid; if(isLeft) r &#x3D; mid - 1; else l &#x3D; mid + 1; &#125; &#125; return res; &#125; vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; return &#123;findRange(nums, target, true), findRange(nums, target, false)&#125;; &#125; &#125;; 69.x的平方根 、367.有效的完全平方数题干给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 示例 示例 1: 输入：x &#x3D; 4 输出：2 示例 2: 输入：x &#x3D; 8 输出：2 解法基本思路：二分查找。 小数部分舍去，因此结果的平方必然 小于等于 x，因此在该处记录mid值，等到 l 和 r 重合后的mid即为结果。 注意用 long long 存储平方结果。 代码class Solution &#123; public: int mySqrt(int x) &#123; int l &#x3D; 0, r &#x3D; x, res; while(l &lt;&#x3D; r)&#123; int mid &#x3D; (l + r) &#x2F; 2; if((long long)mid * mid &lt;&#x3D; x)&#123; l &#x3D; mid + 1; res &#x3D; mid; &#125; else r &#x3D; mid - 1; &#125; return res; &#125; &#125;; 27.移除元素、26.删除有序数组中的重复项解法基本思路：双指针。 利用了题意只打印前返回值个数的元素且不在意顺序，因此不需要真删，最后返回头指针的位置即可。 代码&#x2F;&#x2F; 27 class Solution &#123; public: &#x2F;&#x2F; 双指针 int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int l &#x3D; 0, r &#x3D; nums.size() - 1; while(l &lt;&#x3D; r)&#123; if(nums[l] &#x3D;&#x3D; val) nums[l] &#x3D; nums[r--]; else l++; &#125; return l; &#125; &#x2F;&#x2F; vector方法操作 int removeElement2(vector&lt;int&gt;&amp; nums, int val) &#123; if(nums.empty()) return 0; vector&lt;int&gt;::iterator it &#x3D; nums.begin(); while(it !&#x3D; nums.end())&#123; if(*it &#x3D;&#x3D; val) nums.erase(it); else it++; &#125; return nums.size(); &#125; &#125;; &#x2F;&#x2F; 26 class Solution &#123; public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int l &#x3D; 0; for(int r &#x3D; 0; r &lt; nums.size(); ++r)&#123; if(nums[l] !&#x3D; nums[r]) nums[++l] &#x3D; nums[r]; &#125; return l + 1; &#125; &#125;; 283.移动0解法基本思路：双指针。 确保 r指针 的左边均为非0值，l指针 用于遍历一遍，将所有非0值与 r 所在位置交换。 代码class Solution &#123; public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int r &#x3D; 0; for(int l &#x3D; 0; l &lt; nums.size(); ++l) if(nums[l]) swap(nums[l], nums[r++]); &#125; &#125;; 844.比较含退格的字符串解法基本思路：双指针。 慢指针维护真实的字符串，始终指向真实字符串的后一位（相当于真实字符串的长度）。 快指针用于遍历。非 ‘#’ 时，将快指针指向的字符赋给慢指针位置，慢指针右移；当为 ‘#’ 时，不赋值并慢指针后退。最后慢指针用于截取字符串（前slow个字符）。 代码class Solution &#123; public: string strBack(string s)&#123; int slow &#x3D; 0; for(int fast &#x3D; 0; fast &lt; s.length(); ++fast) if(s[fast] !&#x3D; &#39;#&#39;) s[slow++] &#x3D; s[fast]; else if(slow &gt; 0) slow--; return s.substr(0, slow); &#125; bool backspaceCompare(string s, string t) &#123; return strBack(s) &#x3D;&#x3D; strBack(t); &#125; &#125;; 977.有序数组的平方解法基本思路：双指针。 其实是三指针。 维护一个指针truth指向结果数组的尾部。另外双指针分别指向头尾，将两者中平方更大的数加入结果数组（同时truth指针左移，因为从大到小插入），指针向中间移动。 代码class Solution &#123; public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int truth &#x3D; nums.size() - 1; vector&lt;int&gt; res(nums.size()); for(int i &#x3D; 0, j &#x3D; nums.size() - 1; i &lt;&#x3D; j;)&#123; if(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123; res[truth--] &#x3D; nums[j] * nums[j]; j--; &#125; else&#123; res[truth--] &#x3D; nums[i] * nums[i]; i++; &#125; &#125; return res; &#125; &#125;; 2023.3.312367.算术三元组的数目解法基本思路：哈希表。 因为严格递增，可以用哈希表存储整个数组，然后遍历找另外两个值是否在哈希表中。 代码class Solution &#123; public: int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123; unordered_set&lt;int&gt; res; int cnt &#x3D; 0; for(int c : nums) res.emplace(c); for(int c : nums)&#123; if(res.find(c + diff) !&#x3D; res.end() &amp;&amp; res.find(c + diff * 2) !&#x3D; res.end()) cnt++; &#125; return cnt; &#125; &#125;; 209.长度最小的子数组题干给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 示例 1: 输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 示例 2: 输入：target &#x3D; 4, nums &#x3D; [1,4,4] 输出：1 解法基本思路：双指针、滑动窗口。 依旧是快慢指针，快指针完成一次数组遍历，并累加和至sum中。 每次累加后判断sum与target，若 ≥ ，则记录此时长度，同时慢指针移动，sum减去值，直至小于target。 代码class Solution &#123; public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int slow &#x3D; 0, fast &#x3D; 0; int res &#x3D; INT_MAX, sum &#x3D; 0; for(; fast &lt; nums.size(); ++fast)&#123; sum +&#x3D; nums[fast]; while(sum &gt;&#x3D; target)&#123; res &#x3D; min(res, fast - slow + 1); sum -&#x3D; nums[slow++]; &#125; &#125; return res &#x3D;&#x3D; INT_MAX ? 0 : res; &#125; &#125;; 904.水果成篮题干你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 示例 1: 输入：fruits &#x3D; [1,2,3,2,2] 输出：4 示例 2: 输入：fruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解法基本思路：双指针、滑动窗口、哈希表。 依旧是快慢指针，快指针完成一次数组遍历，用哈希表记录已采摘的每种水果的数量。 当种类数大于2时，将慢指针所指种类的水果数量减1（减至0时将该种类从哈希表中删除），并移动慢指针。 更新每次移动快指针后的最大长度。 代码class Solution &#123; public: int totalFruit(vector&lt;int&gt;&amp; fruits) &#123; unordered_map&lt;int, int&gt; types; int res &#x3D; 0; int slow &#x3D; 0, fast &#x3D; 0; for(;fast &lt; fruits.size(); ++fast)&#123; types[fruits[fast]]++; while(types.size() &gt; 2)&#123; int ex &#x3D; fruits[slow++]; if(--types[ex] &#x3D;&#x3D; 0) types.erase(ex); &#125; res &#x3D; max(res, fast - slow + 1); &#125; return res; &#125; &#125;; 76.最小覆盖子串题干给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 示例 1: 输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot; 输出：&quot;BANC&quot; 示例 2: 输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot; 输出：&quot;a&quot; 解法基本思路：双指针、滑动窗口、哈希表。 典型的滑动窗口思路，窗口扩展时寻找可行解，窗口收缩时优化可行解。 先用哈希表存储 t 串中每种字符的数量，设立双指针。 不断右移快指针，增大滑动窗口，直至包含 t 中所有字符。 右移慢指针，去除不需要的元素，直至遇到一个必须包含的字符，记录最小长度和起始位置。 慢指针右移一位，此时条件不满足，从步骤2继续执行，直至快指针超出 s 的范围。 以上思路遇到的问题： 如何判断窗口内包含了 t 中所有字符？ 步骤1的哈希表，每当快指针增加一个所需字符时，哈希表对应数量减1，慢指针加1。存在负数的情况，因为当添加某个字符数量超过需求时，若窗口压缩时去除了多余的该字符依旧是符合要求的。当哈希表中所有键对应的值均≤ 0 时，表示包含了全部所需字符。 每次判断都要遍历哈希表？ 维护一个变量 needChar 表示所需元素的总数，窗口每次添加所需字符时，哈希表中对应的值和 needChar 同时减1。当 needChar == 0 时，已达标可以进行缩减了。 没有符合要求的子串和全部字符才符合要求这两种情况的区分？ 一开始 minLen 初值设置为 s.length()，发现无法区分这两种情况。修改为 INT_MAX 即可，return时根据 minLen 是否被修改过作出选择。 关于unordered_map 有个注意的点是，当执行 sub[c] &gt; 0 时若map中不存在键c，会生成一个 **sub[c] = 0 **的键值对，因此我通过 在该判断前先判断是否存在该键 来解决，不知是否有更简便的方法TODO。 代码class Solution &#123; public: string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; sub; for(char c: t) sub[c]++; int slow &#x3D; 0, fast &#x3D; 0; int minLen &#x3D; INT_MAX, minLoc &#x3D; 0, needChar &#x3D; t.length(); for(; fast &lt; s.length(); ++fast)&#123; int c &#x3D; s[fast]; if(sub.count(c) &amp;&amp; sub[c]-- &gt; 0) needChar--; if(needChar &#x3D;&#x3D; 0)&#123; while(sub.count(s[slow]) &#x3D;&#x3D; 0 || sub[s[slow]] &lt; 0)&#123; if(sub.count(s[slow])) sub[s[slow]]++; slow++; &#125; if(minLen &gt; fast - slow + 1)&#123; minLen &#x3D; fast - slow + 1; minLoc &#x3D; slow; &#125; sub[s[slow++]]++; needChar++; &#125; &#125; return minLen &gt; s.length() ? &quot;&quot; : s.substr(minLoc, minLen); &#125; &#125;; 59.螺旋矩阵 Ⅱ题干给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 示例 1: 输入：n &#x3D; 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2: 输入：n &#x3D; 1 输出：[[1]] 解法基本思路：模拟过程。 因为是正方形，因此会规律很多。每轮循环计算一圈边界，无论横纵都遵循左闭右开的走法，如下图，即可避免重复。 若 n 为奇数，最中间的值需要单独补充。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n)); int loop &#x3D; n &#x2F; 2; int sx &#x3D; 0, sy &#x3D; 0; int num &#x3D; 0, cnt &#x3D; 1; int i, j; while(loop--)&#123; for(j &#x3D; sy; j &lt; n - cnt; ++j) mat[sy][j] &#x3D; ++num; for(i &#x3D; sx; i &lt; n - cnt; ++i) mat[i][j] &#x3D; ++num; for(; j &gt; sy; --j) mat[i][j] &#x3D; ++num; for(; i &gt; sx; --i) mat[i][j] &#x3D; ++num; sx++; sy++; cnt++; &#125; if(n % 2) mat[n &#x2F; 2][n &#x2F; 2] &#x3D; n * n; return mat; &#125; &#125;;","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"}]},{"title":"关于js跨源请求的解决方案","slug":"关于js跨源请求的解决方案","date":"2022-04-17T15:32:36.000Z","updated":"2022-12-07T15:49:33.233Z","comments":true,"path":"原理/关于js跨源请求的解决方案/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Ejs%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"前言起因是出现了卜算子统计的访问量和访客数一致的bug，于是想换个访客信息统计的API，于是换了百度统计。 一切都很顺利，直至在用XMLHttpRequest向api发送请求的时候，出现了跨源请求问题。 请求是正常发出去的，数据也正常从服务端返回了，但是被浏览器拦截了。 跨源请求相关知识一个 URL 大概包含的部分：scheme://host:port/path?#hash 比如一个 URL 为 http://www.xxx.com:8888/school/student.html，","text":"前言起因是出现了卜算子统计的访问量和访客数一致的bug，于是想换个访客信息统计的API，于是换了百度统计。 一切都很顺利，直至在用XMLHttpRequest向api发送请求的时候，出现了跨源请求问题。 请求是正常发出去的，数据也正常从服务端返回了，但是被浏览器拦截了。 跨源请求相关知识一个 URL 大概包含的部分：scheme://host:port/path?#hash 比如一个 URL 为 http://www.xxx.com:8888/school/student.html， 那么 http 就是 scheme，www.xxx.com 就是 host，8888 就是 port 什么是同源？如果两个 URL 的 scheme://host:port 内容一样，就叫同源。 什么是跨源访问？如果两个 URL 的 scheme、host、port 有任何一个不一样，就不同源。这时候，一个 URL 的脚本从另一个 URL 获取数据，就叫跨源访问。 针对跨源访问，W3C 提出了一个方案叫做 CORS（Cross-Origin Resource Sharing），只有现代浏览器支持此方案。 CORS 的工作方式 浏览器中当前页面的脚本请求另外一个服务器的数据时，浏览器在发起连接的数据报头中附加一个 Origin 报头，表明当前页面的来源，然后向另外一个服务器发起连接 目标服务器接收到浏览器的连接请求后，如果接受请求，则在响应数据流的报头中添加一个Access-Control-Allow-Origin 报头，并给这个报头赋一个值，值为浏览器发过来的 Origin 报头值，或者为 “*”（表示此服务器运行任何跨站请求）。如果不接受请求，则不包含 Access-Control-Allow-Origin 报头。 浏览器接受到返回来的数据包进行解析，如果不包含 Access-Control-Allow-Origin 报头，则丢弃响应数据包。 问题的解决Debug（失败）直接请求后端，可以正常获取到数据。 查看百度统计API允许的域名，是 “ * ” 。 但一旦通过前端js发送请求，就会失败。 怀疑是百度后端的问题=_= 解决上网又搜了一轮，看到有博客说，百度api允许用jsonp动态创建script，通过callback获取数据 于是修改代码如下： 用script的src属性去访问数据端口，然后通过callback回调函数传值回来，这样可以解决问题，但是只能用于GET。 时隔了大半年，才想起来这儿还有个坑。。。","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://www.hanhan0223.cn/tags/javascript/"}]},{"title":"基于STM32F103的实时操作系统","slug":"基于STM32F103的实时操作系统","date":"2022-04-08T05:41:30.000Z","updated":"2023-09-02T16:17:41.080Z","comments":true,"path":"原理/基于STM32F103的实时操作系统/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%9F%BA%E4%BA%8ESTM32F103%E7%9A%84%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"仿照U-COS II写的一个抢占式实时操作系统——Easy OS。目前只实现了任务的简单调度，功能比较单一，后续会不断完善更新。 底层架构STM32硬件支持Cortex-M3内核提供了以下异常： 编号大于15的均属于外部中断。 异常是可以打断正常执行流的事件，这是实现实时操作系统的关键，本文中将会使用——PendSV可悬起异常和SysTick滴答定时器。","text":"仿照U-COS II写的一个抢占式实时操作系统——Easy OS。目前只实现了任务的简单调度，功能比较单一，后续会不断完善更新。 底层架构STM32硬件支持Cortex-M3内核提供了以下异常： 编号大于15的均属于外部中断。 异常是可以打断正常执行流的事件，这是实现实时操作系统的关键，本文中将会使用——PendSV可悬起异常和SysTick滴答定时器。 SysTick系统滴答定时器SysTick是一个24位的系统节拍定时器，具有自动重载和溢出中断功能，所有基于Cortex_M3处理器的微控制器都可以由这个定时器获得一定的时间间隔。 SysTick在实现本文的实时操作系统中起到了非常关键的作用——节拍 / 时间片，它保证了操作系统运行的基准单位。同时，通过将其优先级设置为最高，就可以实现在一个时间片用完之后，稳定触发该异常，从而实现时间片的轮转。 通过以下函数初始化SysTick计数器，设置两次中断之间的时间。 #define TICKS_PER_SEC 1000 SysTick_Config(SystemCoreClock &#x2F; TICKS_PER_SEC); 重装载值 = SysTick 时钟频率(Hz) x 想要的定时时间（S） 例如，SystemCoreClock为72MHZ，想要实现1ms进一次中断，就只需要将TICKS_PER_SEC设置为1000，也就是 x 0.001即可。 PendSV可悬起异常基于其可悬起的特点，将其配置为最低优先级，OS就可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。 悬起 PendSV 的方法是：手工往 NVIC的 PendSV悬起寄存器中写 1。悬起后，如果优先级不够高，则将缓期等待执行。 PendSV的典型使用场合是在上下文切换时（在不同任务之间切换）。 例如，一个系统中有两个就绪的任务，上下文切换被触发的场合可以是：1、执行一个系统调用2、系统滴答定时器（SYSTICK）中断（本文中使用） 为什么PendSV好用，如下： 假设有这么一个系统，里面有两个就绪的任务，并且通过SysTick异常启动上下文切换。但若在产生 SysTick 异常时正在响应一个中断，则 SysTick异常会抢占其 ISR。在这种情况下，OS是不能执行上下文切换的，否则将使中断请求被打断延迟，而且在真实系统中延迟时间还往往不可预知，这是不应该被允许的。 在Cortex-M3中，如果 OS 在某中断活跃时尝试切入线程模式，将触犯用法fault异常。 PendSV完美解决了这个问题。PendSV异常会自动延迟上下文切换的请求，直到其它的 ISR都完成了处理后才放行。为实现这个机制，需要把 PendSV编程为最低优先级的异常。 如果 OS检测到某 IRQ正在活动并且被 SysTick抢占，它将悬起一个 PendSV异常，以便缓期执行 上下文切换。 上图很好的展示了本文实现的操作系统的任务切换的时序实现。 汇编实现使用SysTick异常实现时间片轮转，并触发PendSV中断。 在PendSV中实现上下文的切换。 SysTick中断调用;EQU 等价替换 NVIC_INT_CTRL EQU 0xE000ED04 ; 中断控制寄存器 NVIC_PENDSVSET EQU 0x10000000 ; 触发软中断，通过给NVIC_INT_CTRL第28bit写1 CPU_TASK_SCHEDULE ;OS context switch（任务切换） ;PUSH 压栈。&#123;&#125;表示一个列表，这里先将R4压栈再压R5 PUSH &#123;R4, R5&#125; ;LDR 将源寄存器的值（这里是直接取NVIC_INT_CTRL的值，也就是ICSR的地址）加载到目标寄存器中（R4） LDR R4, &#x3D;NVIC_INT_CTRL ; R4 &#x3D; NVIC_INT_CTRL（触发 PendSV 异常） LDR R5, &#x3D;NVIC_PENDSVSET ; R5 &#x3D; NVIC_PENDSVSET ; *R4 &#x3D; R5（向 NVIC_INT_CTRL 写入NVIC_PENDSVSET 触发 PendSV 中断） STR R5, [R4] POP &#123;R4, R5&#125; BX LR ; return; align 4 ; 4字节对齐，写于文件末 end 其中中断控制寄存器片段 PendSV汇编函数PendSV_Handler ; 保存现场 CPSID I ; 关中断，任务切换期间要关中断 ; 异常处理或进程切换时，需要保存程序状态寄存器的值，可用该指令读出程序状态寄存器的值，然后保存。 MRS R0, PSP CBZ R0, PendSV_Handler_NoSave ; PSP指针为0就跳转，只在第一次运行时跳转 ;---------------------------------------------------------------------------------------- SUB R0, R0, #0x20 ; R0 &#x3D; R0 - 0x20; STM R0, &#123;R4-R11&#125; ; 将R4-R11的值暂存起来 ;---------------------------------------------------------------------------------- LDR R1, &#x3D;TCB_CurP ; LDR伪指令获取 TCB_CurP-&gt;StackTop 指针 ; R1 &#x3D; *R1; 获取 TCB_CurP-&gt;StackTop 指向的值（这个值是一个地址） LDR R1, [R1] ; *R1 &#x3D; R0; 将现场信息（R4-R11）存入 TCB_CurP-&gt;StackTop 指向的地址所在的内存 STR R0, [R1] ; 由于汇编语言是顺序执行，所以执行完上面那条语句后，在没有跳转等指令的情况下，会接下去执行。 PendSV_Handler_NoSave ; 恢复现场 LDR R0, &#x3D;TCB_CurP ; R0 获取 TCB_CurP-&gt;StackTop 指针 LDR R1, &#x3D;TCB_NextP ; R1 获取 TCB_NextP-&gt;StackTop 指针 LDR R2, [R1] ; R2 获取 TCB_NextP-&gt;StackTop 指向的值 STR R2, [R0] ; 将 TCB_CurP-&gt;StackTop 指向这个值 ; 将 以这个值为地址的内存里的值（也就是之前保存的现场信息）存入R0，开始恢复 LDR R0, [R2] LDM R0, &#123;R4-R11&#125; ; 从 R0 存储的地址处恢复R4-R11的值 MSR PSP, R0 ; PSP 指向R0（恢复现场） ORR LR, LR, #0x04 ; LR&#x3D;LR|0x04; EXC_RETURN, 第2位赋1表示返回后使用PSP CPSIE I ; 开中断 BX LR ; return; 汇编指令CPSID I CPSID: 这是 “Change Processor State, Interrupts Disabled” 的缩写，表示更改处理器状态以禁用中断。 I: Interrupts 的缩写，指定要更改的处理器状态。当前情况下，表示禁用中断。 MRS R0, PSP MRS：”Move to Register from Special register”的缩写，表示从特殊寄存器中将值移动到通用寄存器。 PSP 是 Process Stack Pointer 的缩写，它是 ARM Cortex-M 处理器中用于指示当前进程（线程）的堆栈指针。该指针为0代表当前进程的堆栈指针未初始化或者当前没有运行的任务。Cortex-M 处理器通常具有两个堆栈指针，另一个是 MSP（Main Stack Pointer）。 CBZ 条件分支指令，用于在指定的寄存器为零时跳转到目标地址。 “Compare and Branch on Zero”的缩写。 SUB R0, R0, #0x20 这里将PSP指针减去0x20是为了保存R4-R11的上下文（8个寄存器共32字节-&gt;0x20）。避免堆栈溢出。 STM R0, &#123;R4-R11&#125; 将多个寄存器的值保存到内存中，常用于保存上下文。注意是内存！！！ “Store Multiple” 的缩写。这里将R4-R11保存至R0中存储的地址所指向的内存。 STR R0, [R1] 用于将寄存器 R0 中的值存储到 R1 中地址指向的内存位置。 “Store Register” 的缩写。 LDM R0, &#123;R4-R11&#125; 从内存中加载多个寄存器的值， “Load Multiple” 的缩写。 MSR PSP, R0 将R0中的地址移动到PSP指针中。即恢复现场。 ORR LR, LR, #0x04 执行按位或操作，这里将第2位赋1，告诉处理器返回后使用PSP指针继续执行程序。 LR寄存器在出入ISR的时候，LR的值将得到重新的诠释，这种特殊的值称为EXC_RETURN。 EXC_RETURN的二进制值除了最低4位外全为1，而其最低4位则有另外的含义，如下： 上下文切换一个形象的GIF如下所示： 上下文切换，其实就是保存和恢复上图中这些CM3内核寄存器中的值。 寄存器 用途 R0~R3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。 R4~R11 存放函数的局部变量。若被调用函数使用了这些寄存器，返回之前必须恢复这些寄存器的值。 R12 内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。 在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 R13 栈指针 sp。它不能用于任何其它用途。sp 中的值在退出被调用函数时必须与进入时的值相同。 R14 链接寄存器 lr。若保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复。 R15 程序计数器 PC。它不能用于任何其它用途。 CM3处理异常/中断时，硬件会把R0-R3，R12，LR，PC, XPSR自动压栈。然后由PendSV的中断服务程序(后面简称PendSV ISR)手动把R4-R11寄存器压入任务栈中，这样就完成了任务上下文的保存。 恢复下一个任务的寄存器(包含PC)，当恢复PC时就能跳转到任务被打断的地方继续执行。恢复过程正好与保存过程相反，PendSV ISR会先手动地将R4-R11恢复到CM3中，然后在PendSV ISR退出时，CM3硬件会自动将R0-R3，R12，LR, XPSR恢复到CM3的寄存器中。 中断控制的汇编函数CPU_SR_Save ; 关中断（进入临界区） MRS R0, PRIMASK ; 读取 PRIMASK 到 R0,R0 为返回值 ; PRIMASK寄存器只有一位，当这个位置 1 时 就关掉所有可屏蔽的异常 CPSID I ; PRIMASK&#x3D;1,关中断(NMI和硬件FAULT可以响应) BX LR ; 返回 CPU_SR_Restore ;开中断（退出临界区） MSR PRIMASK, R0 ;读取 R0 到 PRIMASK 中,R0 为参数 BX LR c语言定义宏实现调用 u32 CPU_SR; &#x2F;&#x2F; 保存PRIMASK的值(中断开关的状态控制) #define ENTER_CRITICAL() &#123; CPU_SR &#x3D; CPU_SR_Save(); &#125; &#x2F;&#x2F; 关中断 #define EXIT_CRITICAL() &#123; CPU_SR_Restore(CPU_SR); &#125; 注意，ARM架构中汇编函数的返回值默认为存储在R0中；同理，汇编函数的前四个输入参数一般为R0-R3。 初始化的汇编函数NVIC_INT_CTRL EQU 0xE000ED04 ; 中断控制寄存器的地址 NVIC_PENDSVSET EQU 0x10000000 ; 触发软中断，通过给NVIC_INT_CTRL第28bit写1 NVIC_SYSPRI14 EQU 0xE000ED22 ; 系统优先级寄存器(14) 对应 PendSV NVIC_PENDSV_PRI EQU 0xFF ; PendSV 中断优先级为最低(0xFF) CPU_Start CPSID I LDR R0, &#x3D;NVIC_SYSPRI14 ; 初始化PendSV，并设置中断优先级为255，最低 LDR R1, &#x3D;NVIC_PENDSV_PRI STRB R1, [R0] LDR R4, &#x3D;0x0 ; 初始化PSP为0 MSR PSP, R4 LDR R4, &#x3D;NVIC_INT_CTRL ; 先触发一次PendSV异常 LDR R5, &#x3D;NVIC_PENDSVSET STR R5, [R4] CPSIE I STM32F103初始化 在stm32的启动汇编文件中，最重要的就是这段启动代码。 跳转指令ARM指令中，B、BL、BX、BLX 区别如下： B——跳转 B &#123;条件&#125; 目标地址 B 指令是最简单的跳转指令。一旦遇到B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。 注意存储在跳转指令中的实际值是相对当前PC 值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是 24 位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(前后32MB 的地址空间)。 BL——带链接的跳转 BL &#123;条件&#125; 目标地址 首先将当前指令的下一条指令地址保存在LR寄存器，然后跳转至目标地址。通常用于调用子程序，可通过在子程序的尾部添加mov pc, lr 返回。 BL 是另一个跳转指令，但跳转之前，会在寄存器R14 中保存PC 的当前内容，因此，可以通过将R14 的内容重新加载到PC 中，来返回到跳转指令之后的那个指令处执行。 BX——带状态切换的跳转 BX &#123;条件&#125; 目标地址 最低位为1时，切换到Thumb指令执行，为0时，解释为ARM指令执行。 BX 指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM 指令，也可以是Thumb指令。 BLX——带链接和状态切换的跳转 BLX 目标地址 相当于 BL 和 BX 的结合。BLX 指令从ARM 指令集跳转到指令中所指定的目标地址，并将处理器的工作状态由ARM 状态切换到Thumb 状态，该指令同时将PC 的当前内容保存到寄存器R14 中。因此，当子程序使用Thumb 指令集，而调用者使用ARM 指令集时，可以通过BLX 指令实现子程序的调用和处理器工作状态的切换。 SystemInit 首先跳转到SystemInit()进行时钟的初始化工作（RTOS的基础）后返回。 开启内部8MHz振荡器 根据芯片容量不同默认初始化CFGR寄存器（Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits ） 赋值CR寄存器的某些位，其作用为：Reset HSEON, CSSON and PLLON 把CFGR寄存器的PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE位置0 根据芯片容量初始化中断位（关闭中断位） 初始化Memory控制 调用宏定义指定频率系统时钟设置函数，默认 SetSysClockTo72()。即将SYSCLK设置为72MHz，这是后续一切时间操作的基础。 在 SetSysClockTo72() 函数中，实现了：配置CR、CFGR、ACR（设置FLASH）寄存器的某些位（使能，判断是否就绪，设置相应位，设置FLASH，设置AHB、APB预分频系数，设置HCLK、PCLK等等外设时钟，设置PLL锁相环倍频系数最终确定系统时钟）。 systick在上述文本中提到的 SysTick_Config() 函数，内部实现如下： static __INLINE uint32_t SysTick_Config(uint32_t ticks) &#123; if (ticks &gt; SysTick_LOAD_RELOAD_Msk) return (1); SysTick-&gt;LOAD &#x3D; (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1; NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1); SysTick-&gt;VAL &#x3D; 0; SysTick-&gt;CTRL &#x3D; SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; return (0); &#125; 通过设置为 SystemCoreClock / ticks_per_sec，即 72MHz / 1000，实现1ms结束一次计时。 相关寄存器 上表中的四个寄存器负责管理systick的运行。 用来装载我们需计数的次数的寄存器。(即VAL寄存器重置时的值) 每一个时钟周期，VAL的值自减1。当VAL值为0时,会重新加载LOAD中的值，并且产生COUNTFLAG标志。(COUNTFLA标志在CTRL寄存器) 第0位：定时器使能位。使能即运行。 第1位：中断使能位，用于决定自减为0后是否执行 SysTick_Handler 中断。 第2位：时钟源选择位 ，可以选择内部时钟或外部时钟作为时钟源。 内部时钟：上述时钟树中的SYSCLK系统时钟，也是输入给AHB总线的HCLK时钟，72MHz； 外部时钟：RCC通过AHB时钟(HCLK)8分频后作为Cortex系统定时器(SysTick)的外部时钟，9MHz。 第16位：计数标志位 ，SysTick自减到0时，该位置1，表示计数完毕。读取该位后，该位自动清零。 不常用。 至此以上两步，完成了systick时钟的初始化，用作RTOS的时间片基准。 定时器systick内核定时器可参考 任务的延时 。 tim定时器分为：1.高级控制定时器（TIM1、TIM8）、2.通用定时器（TIM2 ~ TIM5）、3.基本定时器（TIM6、TIM7） 其中1在APB2总线上，2、3在APB1总线上。 实现u16 fac_ms[6] &#x3D; &#123;1&#125;; TIM_TypeDef* tims[6] &#x3D; &#123;TIM2, TIM3, TIM4, TIM5, TIM6, TIM7&#125;; bool delay_init(u16 psc, u8 tim_used) &#123; if(tim_used &lt; 2 || tim_used &gt; 7) return false; tim_used -&#x3D; 2; RCC-&gt;APB1ENR |&#x3D; (1 &lt;&lt; tim_used); &#x2F;&#x2F; 1.总线时钟使能 tims[tim_used]-&gt;DIER &amp;&#x3D; ~TIM_DIER_UIE; &#x2F;&#x2F; 2.禁用中断 tims[tim_used]-&gt;PSC &#x3D; psc - 1; &#x2F;&#x2F; 3.设置预分频器 fac_ms[tim_used] &#x3D; SystemCoreClock &#x2F; (psc * 1000); &#x2F;&#x2F; 设置ms倍因子 &#125; void delay_ms(u16 ms, u8 tim_used) &#123; tim_used -&#x3D; 2; tims[tim_used]-&gt;ARR &#x3D; ms * fac_ms[tim_used] - 1; &#x2F;&#x2F; 设置重装载值 tims[tim_used]-&gt;CNT &#x3D; 0; &#x2F;&#x2F; 设置计数初始值 tims[tim_used]-&gt;CR1 |&#x3D; TIM_CR1_CEN; &#x2F;&#x2F; 使能指定tim定时器 while(!(tims[tim_used]-&gt;SR&amp;1)); &#x2F;&#x2F; 判断是否计时结束(延时) tims[tim_used]-&gt;SR &amp;&#x3D; ~TIM_SR_UIF; &#x2F;&#x2F; SR状态复位 &#125; 寄存器初始化部分 1.首先需要使能APB1总线上的对应tim时钟。 2.频繁产生中断有损性能，因此需要禁用，定时结束可以通过SR寄存器判断，以此实现延时。该寄存器仅使用第0位。 3.对时钟进行分频，然后提供给计数器，作为计数器的时钟。根据上述时钟树，可以看到APB1经过了2分频，因此最后tim2-7的时钟频率为 APB1 x 2，即 fck_psc = 72MHz。 此时，当设置该寄存器为7199时（上限65535，没法7w2），可以得到时钟频率为10KHz，也就是计数累加一次需要0.1ms 延时部分 4.设置重装载值。上述计数一次0.1ms，因此每十次为1ms。输入参数为延时ms，乘以10后存入ARR寄存器中。 5.开始计数前设置计数器CNT初值为0（向上计数）。 6.使能tim定时器。计数方向默认0为向上不需要设置。 7.通过while判断SR寄存器的第0位是否置位实现延时。 注意这里需要软件清0，因此在结束循环后将该位复位。 Note在RTOS中的不同任务，使用的是相同的定时器资源，因此调用延时函数时应注意同时进行的任务中不能使用相同的tim定时器。否则在出现任务切换时会修改同一tim寄存器的值，导致时序混乱。 USART初始化void uart_init(u32 bound) &#123; MY_NVIC_Init(3,3,USART1_IRQn,2); RCC-&gt;APB2ENR |&#x3D; 1 &lt;&lt; 2; RCC-&gt;APB2ENR |&#x3D; 1 &lt;&lt; 14; RCC-&gt;APB2RSTR |&#x3D; 1 &lt;&lt; 14; RCC-&gt;APB2RSTR &amp;&#x3D; ~(1 &lt;&lt; 14); GPIOA-&gt;CRH &amp;&#x3D; 0xFFFFF00F; GPIOA-&gt;CRH |&#x3D; 0x000008B0; GPIOA-&gt;ODR |&#x3D; 1 &lt;&lt; 10; float uart_div; uart_div &#x3D; (float)SystemCoreClock &#x2F; (bound * 16); u16 div_m &#x3D; (u16)uart_div; u16 div_f &#x3D; (uart_div - div_m) * 16 + 0.5f; USART1-&gt;BRR &#x3D; div_m &lt;&lt; 4 | div_f; USART1-&gt;CR1 |&#x3D; 0x202C; &#125; 使能串口作为 STM32 的一个外设，其时钟由外设时钟使能寄存器控制，usart1是在APB2ENR寄存器的第14位，其余都在 APB1ENR 寄存器。同时usart1默认是复用GPIOA的9、10端口，因此还需要使能第2位。 复位清0由软件手动复位后再置0 IO模式PA9为TX，因此为复用推挽输出，50MHz，即 1011 。 PA10为RX，因此为上拉输入，即 1000，同时把ODR相应位置1。（为什么是上拉，因为usart协议规定在RX输入信号中, 以低电平脉冲 （下降沿）作为数据接收的开始. 所以上拉可以保持 RX 无数据接收的状态） 波特率 根据公式，输入波特率后反推出填入寄存器的值。 使能 第2、3、13位，分别为接收使能、发送使能、usart使能。 第5位如下： 第10位，校验位不使能。 最后即 0x202C。 中断优先级既然开启了中断使能，就需要设置中断的优先级。 协议 标准 在上面的通讯方式中，两个通讯设备的DB9 接口（常说的COM口）之间通过串口信号线建立起连接，串口信号线中使用RS-232 标准传输数据信号。由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个电平转换芯片转换成控制器能识别的TTL 标准的电平信号，才能实现通讯。 波特率串口异步通讯中由于没有时钟信号（DB9接口没有时钟信号），所以两个通讯设备之间需要约定好波特率，即每个码元的长度，以便对信号进行解码，图中用虚线分开的每一格就是代表一个码元。常见的波特率为4800、9600、115200 等。 起始和停止信号串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示，而数据包的停止信号可由 0.5、1、1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可。 有效数据起始位之后接着的就是要传输的数据，也称为有效数据，有效数据的长度常被约定为 5、6、7 或 8 位长。 数据校验在有效数据之后，有一个可选的数据校验位。由于数据通信相对更容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。 校验方法有奇校验(odd)、偶校验(even)、0 校验(space)、1 校验(mark)以及无校验(noparity)。 奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个 8 位长的有效数据为：01101001，此时总共有 4 个“1”，为达到奇校验效果，校验位为“1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位。 偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4 个，所以偶校验位为“0”。 0 校验是不管有效数据中的内容是什么，校验位总为“0”， 1 校验是校验位总为“1”。 系统结构任务控制块TCB包含三个部分，任务栈顶指针、延时时长以及任务状态 typedef unsigned int STACK_TypeDef; typedef unsigned int PRIO_TypeDef; typedef unsigned int TICKS_TypeDef; typedef void (*TASK_TypeDef)(void); &#x2F;&#x2F; 任务状态 typedef enum TASK_STATUS &#123; TASK_READY &#x3D; 0, &#x2F;&#x2F;就绪 TASK_DELAY &#x3D; 1, &#x2F;&#x2F;延时等待 TASK_SUSPEND &#x3D; 2, &#x2F;&#x2F;挂起 &#125; TASK_STATUS; &#x2F;&#x2F; TCB控制块 typedef struct &#123; STACK_TypeDef *StackTop; &#x2F;&#x2F;任务栈顶指针 TICKS_TypeDef Delay; &#x2F;&#x2F;任务延时时钟 TASK_STATUS State; &#x2F;&#x2F;任务状态 &#125; TASK_TCB, *TCB_Ptr; #define TASKS_NUM 5 &#x2F;&#x2F; 设定运行任务的数量,不包含空闲任务 extern TASK_TCB TCB[TASKS_NUM + 1]; &#x2F;&#x2F; 定义任务控制块TCB数组 extern PRIO_TypeDef PrioCur; &#x2F;&#x2F; 当前任务的优先级 extern PRIO_TypeDef PrioNext; &#x2F;&#x2F; 下一个运行任务的优先级 extern TCB_Ptr TCB_CurP; &#x2F;&#x2F; 当前任务的TCB指针 extern TCB_Ptr TCB_NextP; &#x2F;&#x2F; 下一个运行任务的TCB指针 就绪任务列表extern u32 TaskReadyTable; &#x2F;&#x2F; 就绪任务列表 维护一个任务就绪列表，通过对位进行操作来保存就绪的任务。 每个任务都有相对应的、不同的优先级，以此区分任务。 &#x2F;&#x2F; prio: 任务优先级 #define SetTaskReady(prio) ( TaskReadyTable |&#x3D; 0x01&lt;&lt;prio ) #define DelTaskReady(Prio) ( TaskReadyTable &amp;&#x3D; ~(0x01&lt;&lt;Prio) ) 通过一个简单的for循环获取当前最高优先级的任务（实际就是获取优先级数） u32 i; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); 相应优先级的任务，存于 TCB[i] 中。 任务的创建&#x2F;* --- 创建任务 - *p_Task: 任务函数地址 - *p_Stack：任务栈顶指针 - prio: 任务优先级 *&#x2F; void STM32_TaskCreate(TASK_TypeDef task, STACK_TypeDef *stack, PRIO_TypeDef prio) &#123; STACK_TypeDef *p_stk; p_stk &#x3D; stack; &#x2F;&#x2F;加载栈顶指针 p_stk &#x3D; (STACK_TypeDef *)((STACK_TypeDef)(p_stk) &amp; 0xFFFFFFF8u); *(--p_stk) &#x3D; (STACK_TypeDef)0x01000000uL; &#x2F;&#x2F; xPSR的T位置1，设置为Thumb模式？TODO *(--p_stk) &#x3D; (STACK_TypeDef)task; &#x2F;&#x2F; PC指针 &#x2F;&#x2F; 无意义，只为了--p_stk *(--p_stk) &#x3D; (STACK_TypeDef)0x14141414uL; &#x2F;&#x2F; R14 (LR) *(--p_stk) &#x3D; (STACK_TypeDef)0x12121212uL; &#x2F;&#x2F; R12 *(--p_stk) &#x3D; (STACK_TypeDef)0x03030303uL; &#x2F;&#x2F; R3 *(--p_stk) &#x3D; (STACK_TypeDef)0x02020202uL; &#x2F;&#x2F; R2 *(--p_stk) &#x3D; (STACK_TypeDef)0x01010101uL; &#x2F;&#x2F; R1 *(--p_stk) &#x3D; (STACK_TypeDef)0x00000000u; &#x2F;&#x2F; R0 *(--p_stk) &#x3D; (STACK_TypeDef)0x11111111uL; &#x2F;&#x2F; R11 *(--p_stk) &#x3D; (STACK_TypeDef)0x10101010uL; &#x2F;&#x2F; R10 *(--p_stk) &#x3D; (STACK_TypeDef)0x09090909uL; &#x2F;&#x2F; R9 *(--p_stk) &#x3D; (STACK_TypeDef)0x08080808uL; &#x2F;&#x2F; R8 *(--p_stk) &#x3D; (STACK_TypeDef)0x07070707uL; &#x2F;&#x2F; R7 *(--p_stk) &#x3D; (STACK_TypeDef)0x06060606uL; &#x2F;&#x2F; R6 *(--p_stk) &#x3D; (STACK_TypeDef)0x05050505uL; &#x2F;&#x2F; R5 *(--p_stk) &#x3D; (STACK_TypeDef)0x04040404uL; &#x2F;&#x2F; R4 TCB[prio].StackTop &#x3D; p_stk; TCB[prio].Delay &#x3D; 0; TCB[prio].State &#x3D; TASK_READY; &#125; ARM or Thumb指令集 ARM 模式：在 ARM 模式下，处理器执行的是 ARM 指令集，这是一种32位的指令集，指令长度固定为32位。ARM 指令集通常用于执行复杂的指令，适用于高性能和较大的内存空间。 Thumb 模式：在 Thumb 模式下，处理器执行的是 Thumb 指令集，这是一种16位的指令集，指令长度较短。Thumb 指令集通常用于节省存储空间和提高代码密度，适用于资源受限的嵌入式系统。 指令宽度 ARM 模式：ARM 模式下的指令宽度固定为32位，每条指令都是32位长。 Thumb 模式：Thumb 模式下的指令宽度为16位，每条指令都是16位长。 代码密度 ARM 模式：由于指令宽度较大，ARM 模式下的指令通常需要更多的存储空间，因此代码密度相对较低。 Thumb 模式：Thumb 模式下的指令长度更短，可以实现更高的代码密度，适用于存储空间有限的系统。 性能 ARM 模式：由于指令更长，每条指令通常执行的操作更多，因此在 ARM 模式下可以实现更高的性能。 Thumb 模式：虽然指令更短，但执行速度可能较慢，因为一些操作需要多条 Thumb 指令来实现。 中断处理 ARM 模式：在 ARM 模式下，通常可以更快速地响应中断，因为每条指令执行的操作较多。 Thumb 模式：Thumb 模式下，由于指令较短，中断处理可能需要更多的指令来完成，因此响应中断的速度可能较慢。 部分函数接口任务的调度&#x2F;* --- 任务调度 *&#x2F; void SysTaskSchedule(void) &#123; u32 i; if(SCHEDULE &#x3D;&#x3D; 1) &#123; for(i &#x3D; 0; i &lt; TASKS_NUM; i++) &#x2F;&#x2F; 刷新各任务剩余延时时间 &#123; if(TCB[i].State &#x3D;&#x3D; TASK_DELAY ) &#123; TCB[i].Delay--; if(TCB[i].Delay &#x3D;&#x3D; 0) &#x2F;&#x2F; 必须是由定时器减时的才行 &#123; TCB[PrioCur].State &#x3D; TASK_READY; SetTaskReady(i); &#x2F;&#x2F;修改任务就绪表 使任务可以重新运行 &#125; &#125; &#125; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 任务的创建&#x2F;* --- 创建任务 - *p_Task: 任务函数地址 - *p_Stack：任务栈顶指针 - prio: 任务优先级 *&#x2F; void TaskCreate(void (*p_Task)(void), STACK_TypeDef *p_Stack, PRIO_TypeDef prio) &#123; if(prio &lt;&#x3D; TASKS_NUM) &#123; STM32_TaskCreate(p_Task, p_Stack, prio); SetTaskReady(prio); &#125; &#125; 任务的挂起void TaskSuspend(PRIO_TypeDef prio) &#123; u32 i; ENTER_CRITICAL(); TCB[prio].Delay &#x3D; 0; TCB[prio].State &#x3D; TASK_SUSPEND; DelTaskReady(prio); &#x2F;&#x2F; 从任务就绪表上去除标志位 EXIT_CRITICAL(); if(PrioCur &#x3D;&#x3D; prio) &#x2F;&#x2F; 当要挂起的任务为当前任务 重新调度 &#123; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 任务的恢复void TaskResume(PRIO_TypeDef prio) &#123; u32 i; ENTER_CRITICAL(); SetTaskReady(prio); &#x2F;&#x2F; 从任务就绪表上重置标志位 TCB[prio].Delay &#x3D; 0; &#x2F;&#x2F; 将时间计时设为0,延时到 TCB[prio].State &#x3D; TASK_READY; &#x2F;&#x2F; s EXIT_CRITICAL(); if(PrioCur &#x3D;&#x3D; prio) &#x2F;&#x2F; 不执行？ &#123; for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 任务的延时&#x2F;* --- 任务延时 - ticks: 延时的节拍数 *&#x2F; void SysTimeDelay(TICKS_TypeDef ticks) &#123; u32 i &#x3D; 0; if (ticks) &#123; ENTER_CRITICAL(); DelTaskReady(PrioCur); TCB[PrioCur].Delay &#x3D; ticks; &#x2F;&#x2F; 设置任务延时节拍数 TCB[PrioCur].State &#x3D; TASK_DELAY; EXIT_CRITICAL(); for(i &#x3D; 0; (i &lt; TASKS_NUM) &amp;&amp; (!(TaskReadyTable &amp; (0x01&lt;&lt;i))); i++); PrioNext &#x3D; i; PrioCur &#x3D; i; TCB_NextP &#x3D; &amp;TCB[i]; CPU_TASK_SCHEDULE(); &#125; &#125; 实例应用测试例程单任务计数#define TASK_2_STK_SIZE 128 static STACK_TypeDef TASK_2_STK[TASK_2_STK_SIZE]; u32 task2count &#x3D; 0; void task_2() &#123; while(1) &#123; task2count++; display(task2count); &#x2F;&#x2F; 数码管显示函数 if (task2count &gt;&#x3D; 9999) &#123; task2count &#x3D; 0; &#125; SysTimeDelay(1); &#125; &#125; int main() &#123; delay_init(72); LED_Configuration(); DigitalTube_Configuration(); LCD_Configuration(); Sys_Init(); &#x2F;&#x2F;TaskCreate(task_1, &amp;TASK_1_STK[TASK_1_STK_SIZE-1], TASK1_PRIO); TaskCreate(task_2, &amp;TASK_2_STK[TASK_2_STK_SIZE-1], TASK2_PRIO); Sys_Start(); return 0; &#125;","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.hanhan0223.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://www.hanhan0223.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"opencv图像算法","slug":"opencv图像算法","date":"2021-12-23T11:36:24.000Z","updated":"2023-03-21T02:41:50.856Z","comments":true,"path":"原理/opencv图像算法/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/","excerpt":"图像低通滤波邻域滤波","text":"图像低通滤波邻域滤波 中值滤波图像的中值滤波是一种非线性图像处理方法,是统计排序滤波器的一种典型应用。中值滤波是通过对邻域内像素按灰度排序的结果决定中心像素的灰度。具体的操作过程如下：用一个奇数点的移动窗口，将窗口中心点的值用窗口内各点的中值代替。假设窗口内有5个点，其值为1,2,3,4和5，那么此窗口内各点的中值即为3，也就是用3来代替中心点的像素值。 中值滤波对于滤除脉冲干扰及图像扫描噪声最为有效，还可以克服线性滤波器（如领域简单平滑滤波）带来的图像细节模糊。 数字图像存在冗余信息，具体分为六大冗余：空间冗余、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余。其中第一个空间冗余就可以很好的解释中值滤波的作用。空间冗余指的是：图像内部相邻像素之间存在较强的相关性而造成的冗余。简单来说就是，同一景物表面上采样点的颜色之间通常存在着空间相关性，相邻各点的取值往往相近或者相同，这就是空间冗余。而脉冲噪声通常是在一个邻域内有一个点或多个点的灰度值很高或很低，这就与周围像素存在较大差异，因此中值滤波能很好的去除这种噪声。 需要注意的是，中值滤波的窗口形状和尺寸对滤波效果影响很大，不同的图像内容和不同的应用要求，往往采用不同的窗口形状和尺寸。常用的中值滤波窗口有线状、方形、圆形、十字形以及圆环形等等。窗口尺寸一般先用3x3,再取5x5逐渐增大，直到滤波效果满意为止。就一般经验来讲，对于有缓变的较长轮廓线物体的图像，采用方形或圆形窗口为宜。对于包含有尖顶物体的图像，用十字形窗口，而窗口大小则以不超过图像中最小有效物体的尺寸为宜。如果图像中点、线、尖角细节较多（感觉就是邻域灰度值变化较大），则不宜采用中值滤波。 自适应中值滤波上面提到常规的中值滤波器，在噪声的密度不是很大的情况下，效果不错。但是密度较高时，常规的中值滤波的效果就不是很好了。有一个选择就是增大滤波器的窗口大小，这虽然在一定程度上能解决上述的问题，但是会给图像造成较大的模糊。 常规的中值滤波器的窗口尺寸是固定大小不变的，就不能同时兼顾去噪和保护图像的细节。这时就要寻求一种改变，根据预先设定好的条件，在滤波的过程中，动态的改变滤波器的窗口尺寸大小，这就是自适应中值滤波器 。在滤波的过程中，自适应中值滤波器会根据预先设定好的条件，改变滤波窗口的尺寸大小，同时还会根据一定的条件判断当前像素是不是噪声，如果是则用邻域中值替换掉当前像素；不是，则不作改变。 自适应中值滤波器有三个目的： 滤除椒盐噪声 平滑其他非脉冲噪声 尽可能的保护图像中细节信息，避免图像边缘的细化或者粗化。 实现过程： 对于每一个像素点的处理，使用一个while循环。在while循环中： 首先，在当前像素点下根据当前尺寸窗口的大小获取数据存入数组； 其次，获取窗口内像素的最大最小值和中值； 再，得到A1（中值 - 最小值），A2（中值 - 最大值）。 预先定义好以下符号： Sxy： 滤波器的作用区域，滤波器窗口所覆盖的区域；Zmin： Sxy中最小的灰度值；Zmax： Sxy中最大的灰度值；Zmed： Sxy中所有灰度值的中值；Zxy： 表示图像中对应像素点的灰度值；Smax： Sxy所允许的最大窗口尺寸； 自适应中值滤波器分为以下两个过程，A和B： A: A1 = Zmed - Zmin A2 = Zmed - Zmax 如果A1&gt;0 且 A2&lt;0，则跳转到B 否则，增大窗口的尺寸 如果增大后的尺寸 ≤ Smax，则重复A 否则，直接输出Zmed B： B1 = Zxy - Zmin B2 = Zxy - Zmax 如果B1&gt;0 且 B2&lt;0，则输出Zxy 否则输出Zmed 实现原理： A步骤实质是判断当前区域的中值点是否是噪声点，通常来说是满足条件的，此时中值点不是噪声点，跳转到B；考虑一些特殊情况，如果Zmed=Zmin或者Zmed=Zmax，则认为是噪声点，应该扩大窗口尺寸，在一个更大的范围内寻找一个合适的非噪声点，随后再跳转到B，否则输出的中值点是噪声点； 接下来考虑跳转到B之后的情况：判断中心点的像素值是否是噪声点，原理同上，因为如果Zxy=Zmin或者Zxy=Zmax，则认为是噪声点。如果不是噪声点，我们可以保留当前像素点的灰度值；如果是噪声点，则使用中值替代原始灰度值，滤去噪声。 均值滤波一种特殊形式的邻域滤波（邻域算子都是1/M*N）。 图片中一个方块区域（一般为3*3）内，中心点的像素为全部点像素值的平均值。均值滤波就是对于整张图片进行以上操作。 缺陷：均值滤波本身存在着固有的缺陷，即它不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，不能很好地去除噪声点。特别是椒盐噪声 算术均值滤波这是最简单的均值滤波器，可以去除均匀噪声和高斯噪声，但会对图像造成一定程度的模糊。 算术均值滤波器就是简单的计算窗口区域的像素均值，然后将均值赋值给窗口中心点处的像素： 其中，g(s,t)表示原始图像，f(x,y)表示均值滤波后得到的图像，Sxy表示滤波器窗口。 基于上述公式，可以很容易的得到的算术均值滤波器的窗口模板，下面以3×3为例： 几何均值滤波滤波后图像的像素由模板窗口内像素的乘积的1/mn幂给出。 和算术均值滤波器相比，几何均值滤波器能够更好的取出高斯噪声，并且能够更多的保留图像的边缘信息。但其对0值是非常敏感的，在滤波器的窗口内只要有一个像素的灰度值为0，就会造成滤波器的输出结果为0。 公式如下： 谐波均值滤波对盐粒噪声（白噪声）效果较好，不适用于胡椒噪声；比较适合处理高斯噪声。 公式如下： 逆谐波均值滤波 其中Q称为滤波器的阶数，该滤波器可以用来消除椒盐噪声。但是不能同时处理盐粒噪声和胡椒噪声，当Q为正时，可以消除胡椒噪声；当Q为负时，消除盐粒噪声。当Q=0时，该滤波器退化为算术均值滤波器；Q=-1时，退化为谐波均值滤波器。 修正后的alpha均值滤波假设在Sxy模板领域内，去掉g(s,t)中最高灰度值的d/2和最低灰度值的d/2个像素。用gr(s,t)来代替剩余的mn-d个像素。由剩余像素点的平均值形成的滤波器称为修正后的alpha均值滤波器： 其中d取0~m*n-1之间的任意数。 当d=0时，退变为算术均值滤波； 当d=(m*n-1)，退变为中值滤波器； d取其他值时，该滤波器适用于包括多种噪声的情况，如高斯噪声和椒盐噪声混合的情况。 基于局部均方差的图像去噪设x(i,j)为模板中心的灰度值，那么在（2n+1）x（2m+1）的窗口内，其局部均值可以表示为 其局部均方差可以表示为： 加性去噪后的结果为，其中 σ 为输入值： 方差在统计学中表示的是与中心偏离的程度，用来衡量数据的波动性大小。对于图像而言，当上述局部方差比较小，意味着图像中该局部区域属于灰度平坦区，各个像素灰度值相差不大；相反，当上述局部方差比较大的时候，意味着图像中该局部区域属于边缘或者是其他高频部分区域，各个像素的灰度值相差比较大。 当局部属于平坦区时，方差很小，趋近于0。该点滤波之后的像素就是该点的局部平均值。由于该局部各点像素的灰度值相差不大，其局部平均值也与各个像素的灰度值相差不大；当局部属于边缘区域时，方差较大，相对于用户输入的参数可以基本忽略不计，其图像去噪之后，就等于输入的图像灰度值。 这种方法在一定程度上对边缘具有保留，能够保留边缘的同时，进行去噪。 本质上是一个动态均值滤波的过程，在边缘处（即方差较大区域）尽量保留原值，而在平坦处尽量执行均值滤波。 最值滤波最大值和最小值滤波最值滤波就是取kernal排序后得最大值或最小值来取代中心像素作为输出。 分为最大值滤波和最小值滤波，分别相当于形态学操作的膨胀和腐蚀。 中点滤波在上述最值滤波的基础上，取最大值和最小值的平均值作为中心像素点的输出。 双边滤波双边滤波是一种非线性滤波器，它可以达到保持边缘、降噪平滑的效果。和其他滤波原理一样，双边滤波也是采用加权平均的方法，用周边像素亮度值的加权平均代表某个像素的强度，所用的加权平均基于高斯分布[1]。最重要的是，双边滤波的权重不仅考虑了像素的欧氏距离（如普通的高斯低通滤波，只考虑了位置对中心像素的影响），还考虑了像素范围域中的辐射差异（例如卷积核中像素与中心像素之间相似程度、颜色强度，深度距离等），在计算中心像素的时候同时考虑这两个权重。它是一种可以保边去噪的滤波器。之所以可以达到此去噪效果，是因为滤波器是由两个函数构成。一个函数是由几何空间距离决定滤波器系数。另一个由像素差值决定滤波器系数。 双边滤波的核函数是空间域核与像素范围域核的综合结果：在图像的平坦区域，像素值变化很小，对应的像素范围域权重接近于1，此时空间域权重起主要作用，相当于进行高斯模糊；在图像的边缘区域，像素值变化很大，像素范围域权重变大，从而保持了边缘的信息。 空间域公式如下： 像素范围域（颜色域）公式如下： 他们的乘积即为双边滤波的权重： 根据权重计算最后目标点的像素值： 高斯滤波高斯滤波器是一种线性滤波器，能够有效的抑制噪声，平滑图像。其作用原理和均值滤波器类似，都是取滤波器窗口内的像素的均值作为输出。其窗口模板的系数和均值滤波器不同，均值滤波器的模板系数都是相同的为1；而高斯滤波器的模板系数，则随着距离模板中心的增大而系数减小。所以，高斯滤波器相比于均值滤波器对图像个模糊程度较小。 高斯滤波器 二维高斯函数如下： 其中e前的参数可以忽略，因为这只是个表示幅值的常数，并不影响相互之间的比例关系，并且最终都要进行归一化，所以实际只需要计算后半部分即可。该参数仅影响图像的亮度而不影响模糊。 例如，要产生一个3×3的高斯滤波器模板，以模板的中心位置为坐标原点进行取样。模板在各个位置的坐标，如下所示（x轴水平向右，y轴竖直向下） 对于窗口模板的大小为 (2k+1)×(2k+1)，模板中各个元素值的计算公式如下： 转化为代码： for(int i &#x3D; 0; i &lt; m; ++i) for(int j &#x3D; 0; j &lt; n; ++j) double g &#x3D; exp(((i - m&#x2F;2)*(i - m&#x2F;2) + (j - n&#x2F;2)*(j - n&#x2F;2)) * -1.0 &#x2F; (2 * sigma * sigma)); 再对求出来的每个g进行归一化（因为求的是加权平均，要保证窗口模板各元素和为1） kernel &#x3D; g &#x2F; sum; 关于高斯分布的标准差σ的选值，代表着数据的离散程度。如果σ较小，那么生成的模板的中心系数较大，而周围的系数较小，这样对图像的平滑效果就不是很明显；反之，σ较大，则生成的模板的各个系数相差就不是很大，比较类似均值模板，对图像的平滑效果比较明显。 高斯分布的概率分布密度图如下： 横轴表示可能得取值x，竖轴表示概率分布密度F(x)，那么不难理解这样一个曲线与x轴围成的图形面积为1。σσ（标准差）决定了这个图形的宽度，可以得出这样的结论：σσ越大，则图形越宽，尖峰越小，图形较为平缓；σσ越小，则图形越窄，越集中，中间部分也就越尖，图形变化比较剧烈。这其实很好理解，如果sigma也就是标准差越大，则表示该密度分布一定比较分散，由于面积为1，于是尖峰部分减小，宽度越宽（分布越分散）；同理，当σσ越小时，说明密度分布较为集中，于是尖峰越尖，宽度越窄！ 以上求出来的就是模板系数，滤波操作就是分别以图像的每个像素点为中心再根据模板系数求出加权平均像素，作为该点的滤波后像素。比如3x3模板，对选中像素点的外一圈共九个像素点，分别乘以对应位置的模板系数再求和，即为选中点的像素。 高通滤波（边缘检测）如何识别图像边缘？图里面有一条线,左边很亮,右边很暗,那人眼就很容易识别这条线作为边缘.也就是像素的灰度值快速变化的地方，那么如何来数学化这个问题，就是梯度。 要获得一幅图像的梯度，就需要在图像的每个像素点计算对x和对y的偏导数，也就是 **gx = f(x+1,y) - f(x,y) 和 gy = f(x,y+1) - f(x,y)**，转化为模板也就是，水平和垂直的 [-1,1] 模板。 而当我们对对角线方向的边缘感兴趣时，就产生了Roberts算子，原理就是把一维的模板斜过来。 Roberts算子中2x2的模板在概念上很简单，但在实际应用中，它对于用关于中心点对称的模板来计算边缘方向不是很有用。相对来说3x3考虑了中心点对端数据的性质，并携带了关于边缘方向的更多信息。于是就产生了 Prewitt算子。它的3x3模板考虑到了水平/垂直和斜边的信息，相比于Roberts更准确。 在Prewitt的基础上，在卷积核的中心位置处使用2代替1，能较为有效的平滑图像，抑制噪声，这就是Sobel算子。而针对不同的需求，可以设计不同的卷积核，例如需要对对角线方向有更好的响应，那么可以将2设置在卷积核的两个对角。 Roberts算子Roberts算子是一种最简单的算子，利用局部差分寻找边缘的算子。采用对角线相邻两像素之差近似梯度幅值检测边缘。检测垂直边缘的效果比斜向边缘要好，定位精度高，对噪声比较敏感，无法抑制噪声的影响。 Roberts边缘算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差。从图像处理的实际效果来看，边缘定位较准，对噪声敏感。模板如下： 对于输入图像f(x,y),使用Roberts算子后输出的目标图像为g(x,y),则 Sobel算子（一阶导数法）基于寻找梯度强度 对于f(t),其导数f’(t)反映了每一处的变化趋势.在变化最快的位置其导数最大. sobel算子的思路就是模拟求一阶导数. sobel算子是一个离散差分算子.它计算图像像素点亮度值的近似梯度。图像是二维的,即沿着宽度/高度两个方向。我们使用两个卷积核对原图像进行处理: 水平方向： 原始像素灰度值–&gt;(右边像素值-左边像素值),反映了水平方向的变化情况. 垂直方向同理： 这样就得到了两个新的矩阵,分别反映了每一点像素在水平方向上的亮度变化情况和在垂直方向上的亮度变换情况。 综合考虑这两个方向的变化，使用反映某个像素的梯度变化情况. 有时候为了简单起见,也直接用绝对值相加替代： 在opencv中也可以通过以下卷积核（Scharr）大像素的变化情况： 与滤波一样，对每个像素点的处理为：要操作像素点对应于Gx，Gy矩阵中心，对该像素点和周边9个像素点乘以相应系数求和，得到一个方向上的处理结果。完整的Sobel算子则需要对两个方向上的处理结果求和，得到完整的新像素值。 opencv的Sobel函数 1.采用了可分离的卷积核 图A是可分离的；它可以表示为两个一维卷积（B和C）；D是一个不可分割内核的例子。可分离的内核是可以被认为是两个一维的内核，首先与x内核进行卷积然后与y内核进行卷积来应用。这种分解的好处是内核卷积的计算成本大约是图像面积乘以内核区域。这意味着用n×n内核卷积区域A的图像需要时间与An2成正比，同时n×1内核与图像卷积一次，然后与1×n内核卷积占用与An + An = 2An成比例。 随着图像尺寸与卷积核尺寸的增大，用分离的卷积核依次对图像进行卷积操作，可以有效地提高运算速度。因此，在二维图像处理中，经常将一个可分离卷积核分解为一维水平核 kernalX 和一维垂直核 kernalY 的乘积。 秩为 1 的矩阵可以分解为一个列向量与一个行向量的乘积，因此秩为 1 的卷积核是可分离卷积核。 可分离卷积核 w 与图像 f 的卷积（same 卷积），等于先用 f 与 w1 卷积，再用 w2 对结果进行卷积： 2.行、列卷积核的生成 阅读源码： for( int k &#x3D; 0; k &lt; 2; k++ ) &#x2F;&#x2F; 分别生成行、列 &#123; Mat* kernel &#x3D; k &#x3D;&#x3D; 0 ? &amp;kx : &amp;ky; int order &#x3D; k &#x3D;&#x3D; 0 ? dx : dy; int ksize &#x3D; k &#x3D;&#x3D; 0 ? ksizeX : ksizeY; &#x2F;&#x2F; ksize都是相同的 CV_Assert( ksize &gt; order ); if( ksize &#x3D;&#x3D; 1 ) kerI[0] &#x3D; 1; else if( ksize &#x3D;&#x3D; 3 ) &#x2F;&#x2F; 卷积核大小设为3时使用固定值 &#123; if( order &#x3D;&#x3D; 0 ) kerI[0] &#x3D; 1, kerI[1] &#x3D; 2, kerI[2] &#x3D; 1; else if( order &#x3D;&#x3D; 1 ) kerI[0] &#x3D; -1, kerI[1] &#x3D; 0, kerI[2] &#x3D; 1; else kerI[0] &#x3D; 1, kerI[1] &#x3D; -2, kerI[2] &#x3D; 1; &#125; else &#x2F;&#x2F; 大于3时进行计算，巧妙 &#123; int oldval, newval; kerI[0] &#x3D; 1; for( i &#x3D; 0; i &lt; ksize; i++ ) kerI[i+1] &#x3D; 0; for( i &#x3D; 0; i &lt; ksize - order - 1; i++ ) &#123; oldval &#x3D; kerI[0]; for( j &#x3D; 1; j &lt;&#x3D; ksize; j++ ) &#123; newval &#x3D; kerI[j]+kerI[j-1]; kerI[j-1] &#x3D; oldval; oldval &#x3D; newval; &#125; &#125; for( i &#x3D; 0; i &lt; order; i++ ) &#123; oldval &#x3D; -kerI[0]; for( j &#x3D; 1; j &lt;&#x3D; ksize; j++ ) &#123; newval &#x3D; kerI[j-1] - kerI[j]; kerI[j-1] &#x3D; oldval; oldval &#x3D; newval; &#125; &#125; &#x2F;&#x2F; 以上计算，假设ksize&#x3D;5，order&#x3D;1，可得一维核：[-1，-2，0，2，1] &#125; &#125; 设ksize=3，dx=1，dy=0，带入运算可得： 卷积核的效果和二维的是相同的。 3.可分离卷积的计算 我们首先在5x5图像上用3x1卷积。这样的话卷积核就能横向扫描5个位置，纵向扫描3个位置，如上图所标的点所示。 现在得到的是一个3x5的矩阵，这个矩阵经过1x3卷积核的卷积操作——从横向上的 3 个位置以及纵向上的 3个位置来扫描该矩阵。 Prewitt算子Prewitt算子的原理和sobel是一模一样的，唯一的区别就是卷积核存在差异： Sobel相较于Prewitt，在中心权值上使用2来代替1，这样可以较好的抑制噪声。 Laplacian算子（二阶微分法）基于过零点检测 对Sobel算子中的一阶导数函数再次求导可得： 二阶差分公式： Laplace算子的差分形式： 分别对Laplace算子x,y两个方向的二阶导数进行差分就得到了离散函数的Laplace算子。在一个二维函数f(x,y)中，x,y两个方向的二阶差分分别为： 于是可得Laplace算子的差分形式为： 写作滤波模板的形式如下： 注意该模板的特点，在上下左右四个90度的方向上结果相同，也就是说在90度方向上无方向性。为了让该mask在45度的方向上也具有该性质，可以对该模板进行扩展定义为： 注：定义数字形式的拉普拉斯要求系数之和必为0。 之后的操作与其他的空间滤波操作相同。将模板在原图上逐行移动，然后模板中各系数与其重合的像素相乘后求和，赋给与mask中心重合的像素。 拉普拉斯对噪声敏感，会产生双边效果。不能检测出边的方向。通常不直接用于边的检测，只起辅助的角色，检测一个像素是在边的亮的一边还是暗的一边利用零跨越，确定边的位置。 Canny算子图像边缘信息主要集中在高频段，通常说图像锐化或检测边缘，实质就是高频滤波。 微分运算是求信号的变化率，具有加强高频分量的作用。在空域运算中来说，对图像的锐化就是计算微分。由于数字图像的离散信号，微分运算就变成计算差分或梯度。 因此canny算子求边缘点分为以下四步： 1.使用高斯滤波器平滑图像 卷积的核心意义就是获取原始图像中像模板特征的性质。 2.用一阶偏导有限差分（Sobel）计算梯度值和方向 经典Canny算法用了四个梯度算子来分别计算水平，垂直和对角线方向的梯度。但是通常都不用四个梯度算子来分别计算四个方向。常用的边缘差分算子（如Rober，Prewitt，Sobel）计算水平和垂直方向的差分Gx和Gy。这样就可以如下计算梯度模和方向： 梯度角度θ范围从弧度-π到π，然后把它近似到四个方向，分别代表水平，垂直和两个对角线方向（0°,45°,90°,135°）。 由于图像的坐标系是以左上角为原点向右和下延展，因此根据像素点计算出的角度值必然在一、四象限。那么可以分别以 ± π / 8（水平） 、π / 8 ~ 3π / 8（45°）、- π / 8 ~ - 3π / 8（-45°）、一四象限剩余部分（垂直）来分割，落在每个区域的梯度角给一个特定值，代表四个方向之一。 3.对梯度幅值进行非极大值抑制 意义就是寻找像素点局部最大值。 沿着梯度方向，比较它前面和后面的梯度值即可（对于左右边界，则比较附近的两个值）。如果是最大值就保留，否则置为0。 如上图，c点为需要判断的点，按照2中划分的四个区域，可以看到每个区域包含了八邻域中的两个点，通过判断c点的角度值所在区域，与该区域包含的那两个点进行比较即可。 若想提高精度，如上右图：c的角度值在π / 8 ~ 3π / 8（45°）区域，不比较g1和g4，而是比较dTmp1和dTmp2，由于这两个点都是浮点坐标，因此需要采用线性插值方法来计算这两个点的幅值。 通过角度θ可以计算出dTmp1在g1和g2之间的比例，设dis(dTmp1，g2) = w，则dis(g1，dTmp1) = 1 - w。所以dTmp1的幅值为：w * g2 + （1 - w）* g1。同理可得dTmp2的幅值。将c的幅值与这两个浮点坐标的幅值进行比较进行非极大值抑制。 4.用双阈值算法检测、连接边缘 一般的边缘检测算法用一个阈值来滤除噪声或颜色变化引起的小的梯度值，而保留大的梯度值。Canny算法应用双阈值，即一个高阈值和一个低阈值来区分边缘像素。如果边缘像素点梯度值大于高阈值，则被认为是强边缘点。如果边缘梯度值小于高阈值，大于低阈值，则标记为弱边缘点。小于低阈值的点则被抑制掉。 一般来说，建议高低阈值的比率为2：1或3：1 4.5.滞后边界跟踪 强边缘点可以认为是真的边缘。弱边缘点则可能是真的边缘，也可能是噪声或颜色变化引起的。为得到精确的结果，后者引起的弱边缘点应该去掉。通常认为真实边缘引起的弱边缘点和强边缘点是连通的，而又噪声引起的弱边缘点则不会。所谓的滞后边界跟踪算法检查一个弱边缘点的8连通领域像素，只要有强边缘点存在，那么这个弱边缘点被认为是真是边缘保留下来。 只需对所有被标记过的弱边缘点的八邻域进行遍历，若邻域中存在强边缘点，则保留；否则抑制掉。 方向算子方向算子利用一组模板分别计算在不同方向上的差分值，取其中最大的值作为边缘强度，而将与之对应的方向作为边缘方向。 Kirsch算子类似于Sobel算子，也利用图像中某点的梯度幅值作为像素的灰度值，Sobel算子计算出某点两个方向的梯度值，Gx、Gy；但Kirsch算子 利用8个卷积模板计算出了某点8个方向的梯度幅值和方向，并以最大的卷积值作为该点的灰度值。 对每个像素点都用 这8个模板进行进行卷积（注意，每个卷积值都应取绝对值），求出该点的最大卷积值。 Nevitia算子 形态学膨胀膨胀的操作本质上来说和滤波是一样的，采用滑动窗口（为像素点指定邻域）的模式去遍历整张图，来调整像素值。 调整方式为：选取像素点及其指定邻域中的极大值，作为该像素点的新值。 膨胀同sobel一样存在方向性，可以通过改变邻域的形状，来控制膨胀的方向。 腐蚀腐蚀与膨胀的原理相同。 调整方式为：选取像素点及其指定邻域中的极小值，作为该像素点的新值。 膨胀和腐蚀是针对图像中的高亮部分的变化来说的。 膨胀和腐蚀常用于二值图的操作。 连通域连通域一般是指图像中具有相同像素值且位置相邻的前景像素点组成的图像区域。连通区域分析是指将图像中的各个连通区域找出并标记。通常连通区域分析处理的对象是一张二值化后的图像。 从连通域的定义可以知道，一个连通区域是由具有相同像素值的相邻像素组成像素集合，因此，我们就可以通过这两个条件在图像中寻找连通区域，对于找到的每个连通区域，我们赋予其一个唯一的标识（Label），以区别其他连通区域。 最常见的有两种算法：Two-pass法和Seed-Filling种子填充法。 种子填充法本质上就是DFS，维护一个队列或者堆栈。 按照从上到下、从左到右的顺序遍历图像，对于找到的每一个为指定前景色且未被标记的像素点重复执行以下步骤： 1.标记该像素点，并将该点坐标入队。 2.开启DFS，while（队列非空）。 3.while内部，获取队首的坐标，并将其出队。搜寻该点的4邻域或8邻域（注意边界限幅），若存在为指定前景色且未被标记的像素点，标记并入队。 3.5 while中可维护变量用于统计该连通域的像素点数（面积）和x、y坐标的总和（求均值作为连通域的中心）。 代码实现 由于实际应用需求，写的是纯C的版本，没有队列向量，malloc了两个二维数组用来存取连通域信息。 unsigned char* flag &#x3D; (unsigned char*)malloc(sizeof(unsigned char) * width * height); memset(flag, 0, sizeof(unsigned char) * width * height); int** con &#x3D; (int**)malloc(sizeof(int*) * conNums); int** conInfo &#x3D; (int**)malloc(sizeof(int*) * conNums); for (int i &#x3D; 0; i &lt; conNums; i++) &#123; &#x2F;&#x2F; x、y点坐标 con[i] &#x3D; (int*)malloc(width * height * sizeof(int) * 2); &#x2F;&#x2F; 区域信息 0-Area、12-Center、310-Rect conInfo[i] &#x3D; (int*)malloc(sizeof(int) * 11); &#125; int conIdx &#x3D; -1; &#x2F;&#x2F; 标记连通域的序号 int ptr &#x3D; 0; &#x2F;&#x2F; 通过自加模拟出队 int growNum &#x3D; 0; &#x2F;&#x2F; 模拟队列是否为空 int sumx &#x3D; 0, sumy &#x3D; 0, curx &#x3D; 0, cury &#x3D; 0; for (int i &#x3D; 0; i &lt; height; i++) &#123; for (int j &#x3D; 0; j &lt; width; j++) &#123; if (srcImage[i * width + j] &#x3D;&#x3D; 255 &amp;&amp; flag[i * width + j] &#x3D;&#x3D; 0 &amp;&amp; conIdx &lt; conNums - 1) &#123; &#x2F;&#x2F; 初始化本次连通域信息 conIdx++; growNum &#x3D; 1; ptr &#x3D; 0; sumx &#x3D; 0; sumy &#x3D; 0; flag[i * width + j] &#x3D; conIdx + 1; con[conIdx][0] &#x3D; j; con[conIdx][1] &#x3D; i; &#x2F;&#x2F; 开找 while (growNum &gt; 0) &#123; curx &#x3D; con[conIdx][ptr++]; cury &#x3D; con[conIdx][ptr++]; sumx +&#x3D; curx; sumy +&#x3D; cury; growNum--; if (cury &gt; 0 &amp;&amp; srcImage[(cury - 1) * width + curx] &#x3D;&#x3D; 255 &amp;&amp; flag[(cury - 1) * width + curx] &#x3D;&#x3D; 0) &#123; flag[(cury - 1) * width + curx] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury - 1; growNum++; &#125; if (cury &lt; height - 1 &amp;&amp; srcImage[(cury + 1) * width + curx] &#x3D;&#x3D; 255 &amp;&amp; flag[(cury + 1) * width + curx] &#x3D;&#x3D; 0) &#123; flag[(cury + 1) * width + curx] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury + 1; growNum++; &#125; if (curx &gt; 0 &amp;&amp; srcImage[cury * width + curx - 1] &#x3D;&#x3D; 255 &amp;&amp; flag[cury * width + curx - 1] &#x3D;&#x3D; 0) &#123; flag[cury * width + curx - 1] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx - 1; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury; growNum++; &#125; if (curx &lt; width - 1 &amp;&amp; srcImage[cury * width + curx + 1] &#x3D;&#x3D; 255 &amp;&amp; flag[cury * width + curx + 1] &#x3D;&#x3D; 0) &#123; flag[cury * width + curx + 1] &#x3D; conIdx + 1; con[conIdx][ptr + growNum * 2] &#x3D; curx + 1; con[conIdx][ptr + growNum * 2 + 1] &#x3D; cury; growNum++; &#125; &#125; &#x2F;&#x2F; 计算连通域的面积、中心点和最小外接矩 conInfo[conIdx][0] &#x3D; ptr &#x2F; 2; if (conInfo[conIdx][0] &lt; minConArea) &#123; &#x2F;&#x2F; 小于指定面积的连通域舍弃 conIdx--; &#125; else &#123; conInfo[conIdx][1] &#x3D; sumx * 2 &#x2F; ptr; conInfo[conIdx][2] &#x3D; sumy * 2 &#x2F; ptr; int miny &#x3D; 9999, maxy &#x3D; 0, minx &#x3D; 9999, maxx &#x3D; 0; for (int y &#x3D; 0; y &lt; conInfo[conIdx][0]; y++) &#123; if (con[conIdx][y * 2 + 1] &lt; miny) miny &#x3D; con[conIdx][y * 2 + 1]; if (con[conIdx][y * 2 + 1] &gt; maxy) maxy &#x3D; con[conIdx][y * 2 + 1]; if (con[conIdx][y * 2] &lt; minx) minx &#x3D; con[conIdx][y * 2]; if (con[conIdx][y * 2] &gt; maxx) maxx &#x3D; con[conIdx][y * 2]; &#125; conInfo[conIdx][3] &#x3D; minx; conInfo[conIdx][4] &#x3D; maxy; conInfo[conIdx][5] &#x3D; minx; conInfo[conIdx][6] &#x3D; miny; conInfo[conIdx][7] &#x3D; maxx; conInfo[conIdx][8] &#x3D; miny; conInfo[conIdx][9] &#x3D; maxx; conInfo[conIdx][10] &#x3D; maxy; &#125; &#125; &#125; &#125; Two-pass法由于业务环境为纯c，写Two-pass较为麻烦而且效率并不比种子填充高，因此这里只是贴了网上的代码。 1.生成等价对 要找一张二维图像中的连通域，很容易想到可以一行一行先把子区域找出来，然后再拼合成一个完整的连通域，因为从每一行找连通域是一件很简单的事。这个过程中需要记录每一个子区域，为了满足定位要求，并且节省内存，我们需要记录子区域所在的行号、区域开始和结束的位置以及子区域的总数。需要注意的就是子区域开始位置和结束位置在行首和行末的情况要单独拿出来考虑。 代码实现 &#x2F;&#x2F; 查找每一行的子区域 &#x2F;&#x2F; numberOfArea：子区域总数 stArea：子区域开始位置 enArea：子区域结束位置 rowArea：子区域所在行号 void searchArea(const Mat src, int &amp;numberOfArea, vector&lt;int&gt; &amp;stArea, vector&lt;int&gt; &amp;enArea, vector&lt;int&gt; &amp;rowArea) &#123; for (int row &#x3D; 0; row &lt; src.rows; row++) &#123; &#x2F;&#x2F; 行指针 const uchar *rowData &#x3D; src.ptr&lt;uchar&gt;(row); &#x2F;&#x2F; 判断行首是否是子区域的开始点 if (rowData[0] &#x3D;&#x3D; 255)&#123; numberOfArea++; stArea.push_back(0); &#125; for (int col &#x3D; 1; col &lt; src.cols; col++) &#123; &#x2F;&#x2F; 子区域开始位置的判断：前像素为背景，当前像素是前景 if (rowData[col - 1] &#x3D;&#x3D; 0 &amp;&amp; rowData[col] &#x3D;&#x3D; 255) &#123; numberOfArea++; stArea.push_back(col); &#x2F;&#x2F; 子区域结束位置的判断：前像素是前景，当前像素是背景 &#125;else if (rowData[col - 1] &#x3D;&#x3D; 255 &amp;&amp; rowData[col] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 更新结束位置vector、行号vector enArea.push_back(col - 1); rowArea.push_back(row); &#125; &#125; &#x2F;&#x2F; 结束位置在行末 if (rowData[src.cols - 1] &#x3D;&#x3D; 255) &#123; enArea.push_back(src.cols - 1); rowArea.push_back(row); &#125; &#125; &#125; 另外一个比较棘手的问题，如何给这些子区域标号，使得同一个连通域有相同的标签值。我们给单独每一行的子区域标号区分是很容易的事， 关键是处理相邻行间的子区域关系（怎么判别两个子区域是连通的）。 主要思路：以四连通为例，在上图我们可以看出BE是属于同一个连通域，判断的依据是E的开始位置小于B的结束位置，并且E的结束地址大于B的开始地址；同理可以判断出EC属于同一个连通域，CF属于同一个连通域，因此可以推知BECF都属于同一个连通域。 迭代策略：寻找E的相连区域时，对前一行的ABCD进行迭代，找到相连的有B和C，而D的开始地址已经大于了E的结束地址，此时就可以提前break掉，避免不必要的迭代操作；接下来迭代F的时候，由于有E留下来的基础，因此对上一行的迭代可以直接从C开始。另外，当前行之前的一行如果不存在子区域的话，那么当前行的所有子区域都可以直接赋新的标签，而不需要迭代上一行。 标签策略：以上图为例，遍历第一行，A、B、C、D会分别得到标签1、2、3、4。到了第二行，检测到E与B相连，之前E的标签还是初始值0，因此给E赋上B的标签2；之后再次检测到C和E相连，由于E已经有了标签2，而C的标签为3，则保持E和C标签不变，将（2,3）作为等价对进行保存。同理，检测到F和C相连，且F标签还是初始值0，则为F标上3。如此对所有的子区域进行标号，最终可以得到一个等价对的列表。 下面的代码实现了上述的过程。子区域用一维vector保存，没办法直接定位到某一行号的子区域，因此需要用curRow来记录当前的行，用firstAreaPrev记录前一行的第一个子区域在vector中的位置，用lastAreaPrev记录前一行的最后一个子区域在vector中的位置。在换行的时候，就去更新刚刚说的3个变量，其中firstAreaPrev的更新依赖于当前行的第一个子区域位置，所以还得用firstAreaCur记录当前行的第一个子区域。 &#x2F;&#x2F; 初步标签,获取等价对 &#x2F;&#x2F; labelOfArea:子区域标签值， equalLabels：等价标签对 offset:0为四连通,1为8连通 void markArea(int numberOfArea, vector&lt;int&gt; stArea, vector&lt;int&gt; enArea, vector&lt;int&gt; rowArea, vector&lt;int&gt; &amp;labelOfArea, vector&lt;pair&lt;int, int&gt;&gt; &amp;equalLabels, int offset) &#123; int label &#x3D; 1; &#x2F;&#x2F; 当前所在行 int curRow &#x3D; 0; &#x2F;&#x2F; 当前行的第一个子区域位置索引 int firstAreaCur &#x3D; 0; &#x2F;&#x2F; 前一行的第一个子区域位置索引 int firstAreaPrev &#x3D; 0; &#x2F;&#x2F; 前一行的最后一个子区域位置索引 int lastAreaPrev &#x3D; 0; &#x2F;&#x2F; 初始化标签都为0 labelOfArea.assign(numberOfArea, 0); &#x2F;&#x2F; 遍历所有子区域并标记 for (int i &#x3D; 0; i &lt; numberOfArea; i++) &#123; &#x2F;&#x2F; 行切换时更新状态变量 if (curRow !&#x3D; rowArea[i]) &#123; curRow &#x3D; rowArea[i]; firstAreaPrev &#x3D; firstAreaCur; lastAreaPrev &#x3D; i - 1; firstAreaCur &#x3D; i; &#125; &#x2F;&#x2F; 相邻行不存在子区域 if (curRow !&#x3D; rowArea[firstAreaPrev] + 1) &#123; labelOfArea[i] &#x3D; label++; continue; &#125; &#x2F;&#x2F; 对前一行进行迭代 for (int j &#x3D; firstAreaPrev; j &lt;&#x3D; lastAreaPrev; j++) &#123; &#x2F;&#x2F; 判断是否相连 if (stArea[i] &lt;&#x3D; enArea[j] + offset &amp;&amp; enArea[i] &gt;&#x3D; stArea[j] - offset) &#123; &#x2F;&#x2F; 之前没有标记过 if (labelOfArea[i] &#x3D;&#x3D; 0) labelOfArea[i] &#x3D; labelOfArea[j]; &#x2F;&#x2F; 之前已经被标记，保存等价对 else if (labelOfArea[i] !&#x3D; labelOfArea[j]) equalLabels.push_back(make_pair(labelOfArea[i], labelOfArea[j])); &#125;else if (enArea[i] &lt; stArea[j] - offset) &#123; &#x2F;&#x2F; 为当前行下一个子区域缩小上一行的迭代范围 firstAreaPrev &#x3D; max(firstAreaPrev, j - 1); break; &#125; &#125; &#x2F;&#x2F; 与上一行不存在相连 if (labelOfArea[i] &#x3D;&#x3D; 0) &#123; labelOfArea[i] &#x3D; label++; &#125; &#125; &#125; 2.DFS Two-pass算法 建立一个Bool型等价对矩阵，用作深搜环境。具体做法是先获取最大的标签值maxLabel，然后生成一个maxLabel∗maxLabel大小的二维矩阵，初始值为false；对于例如（1，3）这样的等价对，在矩阵的（0，2）和（2，0）处赋值true——要注意索引和标签值是相差1的。就这样把所有等价对都反映到矩阵上。 深搜的目的在于建立一个标签的重映射。例如4、5、8是等价的标签，都重映射到标签2。最后重映射的效果就是标签最小为1，且依次递增，没有缺失和等价。深搜在这里就是优先地寻找一列等价的标签，例如一口气把4、5、8都找出来，然后给他们映射到标签2。程序也维护了一个队列，当标签在矩阵上值为true，而且没有被映射过，就加入到队列。 当然不一定要建立一个二维等价矩阵，一般情况，等价对数量要比maxLabel来的小，所以也可以直接对等价对列表进行深搜，但无论采用怎样的深搜，其等价对处理的性能都不可能提高很多。 代码实现 &#x2F;&#x2F; 等价对处理，标签重映射 void replaceEqualMark(vector&lt;int&gt; &amp;labelOfArea, vector&lt;pair&lt;int, int&gt;&gt; equalLabels) &#123; int maxLabel &#x3D; *max_element(labelOfArea.begin(), labelOfArea.end()); &#x2F;&#x2F; 等价标签矩阵，值为true表示这两个标签等价 vector&lt;vector&lt;bool&gt;&gt; eqTab(maxLabel, vector&lt;bool&gt;(maxLabel, false)); &#x2F;&#x2F; 将等价对信息转移到矩阵上 vector&lt;pair&lt;int, int&gt;&gt;::iterator labPair; for (labPair &#x3D; equalLabels.begin(); labPair !&#x3D; equalLabels.end(); labPair++) &#123; eqTab[labPair-&gt;first -1][labPair-&gt;second -1] &#x3D; true; eqTab[labPair-&gt;second -1][labPair-&gt;first -1] &#x3D; true; &#125; &#x2F;&#x2F; 标签映射 vector&lt;int&gt; labelMap(maxLabel + 1, 0); &#x2F;&#x2F; 等价标签队列 vector&lt;int&gt; tempList; &#x2F;&#x2F; 当前使用的标签 int curLabel &#x3D; 1; for (int i &#x3D; 1; i &lt;&#x3D; maxLabel; i++) &#123; &#x2F;&#x2F; 如果该标签已被映射，直接跳过 if (labelMap[i] !&#x3D; 0) &#123; continue; &#125; labelMap[i] &#x3D; curLabel; tempList.push_back(i); for (int j &#x3D; 0; j &lt; tempList.size(); j++) &#123; &#x2F;&#x2F; 在所有标签中寻找与当前标签等价的标签 for (int k &#x3D; 1; k &lt;&#x3D; maxLabel; k++) &#123; &#x2F;&#x2F; 等价且未访问 if (eqTab[tempList[j] - 1][k - 1] &amp;&amp; labelMap[k] &#x3D;&#x3D; 0) &#123; labelMap[k] &#x3D; curLabel; tempList.push_back(k); &#125; &#125; &#125; curLabel++; tempList.clear(); &#125; &#x2F;&#x2F; 根据映射修改标签 vector&lt;int&gt;::iterator label; for (label &#x3D; labelOfArea.begin(); label !&#x3D; labelOfArea.end(); label++) &#123; *label &#x3D; labelMap[*label]; &#125; return; &#125; 2.并查集 Two-pass算法 等价对，实质是一种关系分类，因而联想到并查集。并查集方法在这个问题上显得非常合适，首先将等价对进行综合就是合并操作，标签重映射就是查询操作（并查集可以看做一种多对一映射）。这里定义成了类。 代码实现 #include&lt;opencv2&#x2F;opencv.hpp&gt; #include&lt;iostream&gt; using namespace std; using namespace cv; class AreaMark &#123; public: AreaMark(const Mat src,int offset); int getMarkedArea(vector&lt;vector&lt;int&gt;&gt; &amp;area); void getMarkedImage(Mat &amp;dst); private: Mat src; int offset; int numberOfArea&#x3D;0; vector&lt;int&gt; labelMap; vector&lt;int&gt; labelRank; vector&lt;int&gt; stArea; vector&lt;int&gt; enArea; vector&lt;int&gt; rowArea; vector&lt;int&gt; labelOfArea; vector&lt;pair&lt;int, int&gt;&gt; equalLabels; void markArea(); void searchArea(); void setInit(int n); int findRoot(int label); void unite(int labelA, int labelB); void replaceEqualMark(); &#125;; &#x2F;&#x2F; 构造函数 &#x2F;&#x2F; imageInput:输入待标记二值图像 offsetInput:0为四连通，1为八连通 AreaMark::AreaMark(Mat imageInput,int offsetInput) &#123; src &#x3D; imageInput; offset &#x3D; offsetInput; &#125; &#x2F;&#x2F; 使用可区分的颜色标记连通域 void AreaMark::getMarkedImage(Mat &amp;dst) &#123; Mat img(src.rows, src.cols, CV_8UC3, CV_RGB(0, 0, 0)); cvtColor(img, dst, CV_RGB2HSV); int maxLabel &#x3D; *max_element(labelOfArea.begin(), labelOfArea.end()); vector&lt;uchar&gt; hue; for (int i &#x3D; 1; i&lt;&#x3D; maxLabel; i++) &#123; &#x2F;&#x2F; HSV color-mode hue.push_back(uchar(180.0 * (i - 1) &#x2F; (maxLabel + 1))); &#125; for (int i &#x3D; 0; i &lt; numberOfArea; i++) &#123; for (int j &#x3D; stArea[i]; j &lt;&#x3D; enArea[i]; j++) &#123; dst.at&lt;Vec3b&gt;(rowArea[i], j)[0] &#x3D; hue[labelOfArea[i]]; dst.at&lt;Vec3b&gt;(rowArea[i], j)[1] &#x3D; 255; dst.at&lt;Vec3b&gt;(rowArea[i], j)[2] &#x3D; 255; &#125; &#125; cvtColor(dst, dst, CV_HSV2BGR); &#125; &#x2F;&#x2F; 获取标记过的各行子区域 int AreaMark::getMarkedArea(vector&lt;vector&lt;int&gt;&gt; &amp;area) &#123; searchArea(); markArea(); replaceEqualMark(); area.push_back(rowArea); area.push_back(stArea); area.push_back(enArea); area.push_back(labelOfArea); return numberOfArea; &#125; &#x2F;&#x2F; 查找每一行的子区域 &#x2F;&#x2F; numberOfArea：子区域总数 stArea：子区域开始位置 enArea：子区域结束位置 rowArea：子区域所在行号 void AreaMark::searchArea() &#123; for (int row &#x3D; 0; row &lt; src.rows; row++) &#123; &#x2F;&#x2F; 行指针 const uchar *rowData &#x3D; src.ptr&lt;uchar&gt;(row); &#x2F;&#x2F; 判断行首是否是子区域的开始点 if (rowData[0] &#x3D;&#x3D; 255)&#123; numberOfArea++; stArea.push_back(0); &#125; for (int col &#x3D; 1; col &lt; src.cols; col++) &#123; &#x2F;&#x2F; 子区域开始位置的判断：前像素为背景，当前像素是前景 if (rowData[col - 1] &#x3D;&#x3D; 0 &amp;&amp; rowData[col] &#x3D;&#x3D; 255) &#123; numberOfArea++; stArea.push_back(col); &#x2F;&#x2F; 子区域结束位置的判断：前像素是前景，当前像素是背景 &#125;else if (rowData[col - 1] &#x3D;&#x3D; 255 &amp;&amp; rowData[col] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 更新结束位置vector、行号vector enArea.push_back(col - 1); rowArea.push_back(row); &#125; &#125; &#x2F;&#x2F; 结束位置在行末 if (rowData[src.cols - 1] &#x3D;&#x3D; 255) &#123; enArea.push_back(src.cols - 1); rowArea.push_back(row); &#125; &#125; &#125; void AreaMark::markArea() &#123; int label &#x3D; 1; &#x2F;&#x2F; 当前所在行 int curRow &#x3D; 0; &#x2F;&#x2F; 当前行的第一个子区域位置索引 int firstAreaCur &#x3D; 0; &#x2F;&#x2F; 前一行的第一个子区域位置索引 int firstAreaPrev &#x3D; 0; &#x2F;&#x2F; 前一行的最后一个子区域位置索引 int lastAreaPrev &#x3D; 0; &#x2F;&#x2F; 初始化标签都为0 labelOfArea.assign(numberOfArea, 0); &#x2F;&#x2F; 遍历所有子区域并标记 for (int i &#x3D; 0; i &lt; numberOfArea; i++) &#123; &#x2F;&#x2F; 行切换时更新状态变量 if (curRow !&#x3D; rowArea[i]) &#123; curRow &#x3D; rowArea[i]; firstAreaPrev &#x3D; firstAreaCur; lastAreaPrev &#x3D; i - 1; firstAreaCur &#x3D; i; &#125; &#x2F;&#x2F; 相邻行不存在子区域 if (curRow !&#x3D; rowArea[firstAreaPrev] + 1) &#123; labelOfArea[i] &#x3D; label++; continue; &#125; &#x2F;&#x2F; 对前一行进行迭代 for (int j &#x3D; firstAreaPrev; j &lt;&#x3D; lastAreaPrev; j++) &#123; &#x2F;&#x2F; 判断是否相连 if (stArea[i] &lt;&#x3D; enArea[j] + offset &amp;&amp; enArea[i] &gt;&#x3D; stArea[j] - offset) &#123; &#x2F;&#x2F; 之前没有标记过 if (labelOfArea[i] &#x3D;&#x3D; 0) labelOfArea[i] &#x3D; labelOfArea[j]; &#x2F;&#x2F; 之前已经被标记，保存等价对 else if (labelOfArea[i] !&#x3D; labelOfArea[j]) equalLabels.push_back(make_pair(labelOfArea[i], labelOfArea[j])); &#125;else if (enArea[i] &lt; stArea[j] - offset) &#123; &#x2F;&#x2F; 为当前行下一个子区域缩小上一行的迭代范围 firstAreaPrev &#x3D; max(firstAreaPrev, j - 1); break; &#125; &#125; &#x2F;&#x2F; 与上一行不存在相连 if (labelOfArea[i] &#x3D;&#x3D; 0) &#123; labelOfArea[i] &#x3D; label++; &#125; &#125; &#125; &#x2F;&#x2F;集合初始化 void AreaMark::setInit(int n) &#123; for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123; labelMap.push_back(i); labelRank.push_back(0); &#125; &#125; &#x2F;&#x2F;查找树根 int AreaMark::findRoot(int label) &#123; if (labelMap[label] &#x3D;&#x3D; label) &#123; return label; &#125; else &#123; &#x2F;&#x2F; path compression return labelMap[label] &#x3D; findRoot(labelMap[label]); &#125; &#125; &#x2F;&#x2F; 合并集合 void AreaMark::unite(int labelA, int labelB) &#123; labelA &#x3D; findRoot(labelA); labelB &#x3D; findRoot(labelB); if (labelA &#x3D;&#x3D; labelB) &#123; return; &#125; &#x2F;&#x2F; rank optimization:tree with high rank merge tree with low rank if (labelRank[labelA] &lt; labelRank[labelB]) &#123; labelMap[labelA] &#x3D; labelB; &#125; else &#123; labelMap[labelB] &#x3D; labelA; if (labelRank[labelA] &#x3D;&#x3D; labelRank[labelB]) &#123; labelRank[labelA]++; &#125; &#125; &#125; &#x2F;&#x2F; 等价对处理，标签重映射 void AreaMark::replaceEqualMark() &#123; int maxLabel &#x3D; *max_element(labelOfArea.begin(), labelOfArea.end()); setInit(maxLabel); &#x2F;&#x2F; 合并等价对，标签初映射 vector&lt;pair&lt;int, int&gt;&gt;::iterator labPair; for (labPair &#x3D; equalLabels.begin(); labPair !&#x3D; equalLabels.end(); labPair++) &#123; unite(labPair-&gt;first, labPair-&gt;second); &#125; &#x2F;&#x2F; 标签重映射，填补缺失标签 int newLabel&#x3D;0; vector&lt;int&gt; labelReMap(maxLabel + 1, 0); vector&lt;int&gt;::iterator old; for (old &#x3D; labelMap.begin(); old !&#x3D; labelMap.end(); old++) &#123; if (labelReMap[findRoot(*old)] &#x3D;&#x3D; 0) &#123; labelReMap[findRoot(*old)] &#x3D; newLabel++; &#125; &#125; &#x2F;&#x2F; 根据重映射结果修改标签 vector&lt;int&gt;::iterator label; for (label &#x3D; labelOfArea.begin(); label !&#x3D; labelOfArea.end(); label++) &#123; *label &#x3D; labelReMap[findRoot(*label)]; &#125; &#125; int main() &#123; Mat img &#x3D; imread(&quot;img&#x2F;qrcode.jpg&quot;, IMREAD_GRAYSCALE); threshold(img, img, 0, 255, THRESH_OTSU); AreaMark marker(img, 0); vector&lt;vector&lt;int&gt;&gt; area; int amount; &#x2F;&#x2F; 1s for 1000 times amount &#x3D; marker.getMarkedArea(area); Mat dst; marker.getMarkedImage(dst); imshow(&quot;img&quot;, img); imshow(&quot;dst&quot;, dst); waitKey(0); &#125; 霍夫变换直线检测标准霍夫变换首先该检测算法的输入图像只能是边缘二值图像。 1.一条直线在图像二维空间可由两个变量表示： · 在笛卡尔坐标系：y = kx + b，可由k、b表示。 · 在极坐标系：ρ = xcosθ + ysinθ，可由ρ、θ表示 2.对于点（x0，y0），可将经过这个点的一簇直线定义为ρ = x0cosθ + y0sinθ 2.很自然的，对于两个点，满足同一对（ρ，θ）时，这两个点处于同一直线上 3.于是，当有更多个点满足同一对（ρ，θ）时，该对表示的直线由更多的点组成.。一般可以通过设置直线上点的阈值来定义多少个点组成的（ρ，θ）能被认为是一条直线。 4.霍夫变换追踪图像中每个点对应的所有（ρ，θ）并记录数量，若超过了阈值, 那么可以认为这个交点所代表的参数对在原图像中为一条直线。 代码实现 对于图像的每个像素点，遍历 [0, PI] 共180个θ值，得到相应的ρ，并对每一组（ρ，θ）记录值+1（计分板）。 遍历计分板，找出分数大于设定阈值的（ρ，θ）对，即为检测到的直线参数，再将其还原为数学概念上的直线即可。 累计概率霍夫变换（常用）它是对标准霍夫变换的改进。在一定的范围内进行霍夫变换，计算单独线段的方向以及范围，从而减少计算量，缩短计算时间。之所以称PPHT为“概率”的，是因为并不将累加器平面内的所有可能的点累加，而只是累加其中的一部分，该想法是如果峰值如果足够高，只用一小部分时间去寻找它就够了。这样猜想的话，可以实质性地减少计算时间。 代码实现 1.随机获取边缘图像上的前景点，映射到极坐标系画曲线； 2.当极坐标系里面有交点达到最小投票数，将该点对应x-y坐标系的直线L找出来； 3.搜索边缘图像上前景点，在直线L上的点（且点与点之间距离小于maxLineGap的）连成线段，然后这些点全部删除，并且记录该线段的参数（起始点和终止点），当然线段长度要满足最小长度； 4.重复1. 2. 3.。 opencv函数 HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength &#x3D; 0, double maxLineGap &#x3D; 0) 池化池化的作用：减少特征图大小，也就是可以减少计算量和所需显存。 平均池化（mean-pooling）即对邻域内特征点只求平均 优缺点：能很好的保留背景，但容易使得图片变模糊 正向传播：邻域内取平均 反向传播：特征值根据领域大小被平均，然后传给每个索引位置 最大池化（max-pooling）即对邻域内特征点取最大 优缺点：能很好的保留纹理特征，一般现在都用最大而很少用平均 正向传播：取邻域内最大，并记住最大值的索引位置，以方便反向传播 反向传播：将特征值填充到正向传播中，值最大的索引位置，其他位置补0 随机池化（stochastic-pooling）只需对邻域中的元素按照其概率值大小随机选择，即元素值大的被选中的概率也大。而不像max-pooling那样，永远只取那个最大值元素。 在区域内，将左图的数值进行归一化处理，即 1/（1+2+3+4）=0.1；2/10=0.2；3/10=0.3；4/10=0.4 正向传播：对矩阵区域求加权平均即可，比如上面图中，池化输出值为：1 * 0.1+2 * 0.2+3 * 0.3+4 * 0.4=3。 反向传播：只需保留前向传播已经记录被选中节点的位置的值，其它值都为0,这和max-pooling的反向传播非常类似。 优点：方法简单，泛化能力更强（带有随机性） 颜色亮度与对比度基础线性变化在查询opencv的亮度与对比度变化算法时，大多是博客都采用的最基础的线性变换： ​ out = in * α + β 其中 α 为对比度的变化，β 为亮度变化。 亮度（β）：像素点的值就是0~255，0为黑表示最暗，255为白表示最亮。因此调节亮度就是简单的对像素值进行增减即可，即 β ∈ (-100，-100) 。 对比度（α）：这里就存在问题了，线性变化的对比度调节非常不明显，在视觉上依旧呈现的是亮度的变化，在进行代码编写的时候一直达不到Photoshop里面的对比度调节效果。 改进通过查阅资料不难发现，对比度的调节原理如下： 对比度反应了图片上亮区域和暗区域的层次感。而反应到图像编辑上，调整对比度就是在保证平均亮度不变的情况下，扩大或缩小亮的点和暗的点的差异。既然是要保证平均亮度不变，所以对每个点的调整比例必须作用在该值和平均亮度的差值之上，这样才能够保证计算后的平均亮度不变。 因此很容易得出对比度变化的调整公式如下： ​ out = (in - average) * α + in 其中average为图像的平均亮度，α ∈ (-1，1) 。 但是实际处理中，并没有太多的必要去计算一张图的平均亮度：一来耗时间，二来在平均亮度上的精确度并不会给图像的处理带来太多的好处。因此一般假设一张图的平均亮度为127，即一半亮度，而一张正常拍照拍出来的图平均亮度应该是在[100,150]。在视觉上基本没有任何区别。 于是可得最终的亮度对比度调节公式： ​ out = (in - average) * α + in + β 达到了和Photoshop相同的效果。 通道混合也就是调整某一个通道中的颜色成分，可以理解为调整图片某一颜色区域的颜色。 对于选中通道的每一个像素值，进行如下变换： ​ out = red * r + green * g + blue * b + constant * 255 其中，red、green、blue ∈ (-2, 2) ，**constant ∈ (-1, 1)**，r、g、b为每一个像素点的三个通道的值。 gamma变换（校正）Gamma校正是一种非常重要的非线性变换。对输入图像的灰度值进行指数变换，进而校正亮度偏差，通常应用于扩展暗调的细节。gamma校正可使得图像看起来更符合人眼的特性。 但其实Gamma校正不仅会改变亮度，还会改变彩色图像中rgb的比率。 当Gamma校正的值大于1时，图像的高光部分被压缩而暗调部分被扩展，图像整体变暗； 当Gamma校正的值小于1时，图像的高光部分被压缩而暗调部分被压缩，图像整体变亮。 gamma校正的作用： 1.人眼对外界光源的感光值与输入光强不是呈线性关系的，而是呈指数型关系的。在低照度下，人眼更容易分辨出亮度的变化，随着照度的增加，人眼不易分辨出亮度的变化。而摄像机感光与输入光强呈线性关系。 2.为能更有效的保存图像亮度信息。未经Gamma变换和经过Gamma变换保存图像信息如下所示：可以观察到，未经Gamma变换的情况下，低灰度时，有较大范围的灰度值被保存成同一个值，造成信息丢失；同时高灰度值时，很多比较接近的灰度值却被保存成不同的值，造成空间浪费。经过Gamma变换后，改善了存储的有效性和效率。 Gamma校正主要应用在图像增强、目标检测以及图像分析等领域。表达式如下： 代码实现 unsigned char newPixel &#x3D; static_cast&lt;unsigned char&gt;(pow(pixel &#x2F; 255.0, gamma) * 255); 对数变换由于对数曲线在像素值较低的区域斜率大，在像素值较高的区域斜率较小，所以图像经过对数变换后，较暗区域的对比度将有所提升，所以就可以增强图像的暗部细节。 对数变换可以将图像的低灰度值部分扩展，显示出低灰度部分更多的细节，将其高灰度值部分压缩，减少高灰度值部分的细节，从而达到强调图像低灰度部分的目的。表达式如下： 图像的归一化所谓归一化，就是把需要处理的数据限制在你需要的一定范围内。 首先归一化是为了后面数据处理的方便，其次是保证程序运行时收敛加快。归一化的具体作用是归纳统一样本的统计分布性。归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布。 而图像的归一化用的最多的就是归一化到（min，max）范围内： 代码实现 首先迭代整个图的像素点，获取max( src( x，y ) )和min像素点。 然后再次迭代整张图的像素点，将低于min的设置为min，高于max 的设置为max，在（min，max）之间的通过上式计算即可。 图像的均衡化直方图均衡化，是对图像像素值进行非线性拉伸，使得一定范围内像素值的数量的大致相同。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。如下图所示： 通过这种方法可以按照需要对图像的亮度进行调整，并且，这种方法是可逆的，也就是说知道了均衡化函数，也可以恢复原始的直方图。 为什么要选用累积分布函数? 均衡化过程中，必须要保证两个条件：①像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；②如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界。综合以上两个条件，累积分布函数是个好的选择，因为累积分布函数是单调增函数（控制大小关系），并且值域是0到1（控制越界问题），所以直方图均衡化中使用的是累积分布函数。 为什么使用累积分布函数处理后像素值会均匀分布？ 比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是： 其中，n是图像中像素点的总数，nk是当前灰度级的像素个数，L是图像中可能的灰度级总数。 于是对于像素值为k的点，只需要计算： 像素为0~k的点的数量 / 像素点总数，就可以得到直方图中的纵坐标（比例）。再乘以255，即为该点经过均衡化后的像素点。 RGB转灰度一、基础 对于彩色转灰度，有一个很著名的心理学公式： Gray = R * 0.299 + G * 0.587 + B * 0.114 二、整数算法 而实际应用时，希望避免低速的浮点运算，所以需要整数算法。 注意到系数都是3位精度的没有，我们可以将它们缩放1000倍来实现整数运算算法： Gray = (R * 299 + G * 587 + B * 114 + 500) / 1000 RGB一般是8位精度，现在缩放1000倍，所以上面的运算是32位整型的运算。注意后面那个除法是整数除法，所以需要加上500来实现四舍五入。 三、整数移位算法 上面的整数算法已经很快了，但是有一点仍制约速度，就是最后的那个除法。移位比除法快多了，所以可以将系数缩放成 2的整数幂。 习惯上使用16位精度，2的16次幂是65536，所以这样计算系数： 0.299 * 65536 = 19595.264 ≈ 19595 0.587 * 65536 + (0.264) = 38469.632 + 0.264 = 38469.896 ≈ 38469 0.114 * 65536 + (0.896) = 7471.104 + 0.896 = 7472 这所使用的舍入方式不是四舍五入。四舍五入会有较大的误差，应该将以前的计算结果的误差一起计算进去，舍入方式是去尾法，表达式是： Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16 同理，2至20位精度的系数： Gray = (R * 1 + G * 2 + B * 1) &gt;&gt; 2Gray = (R * 2 + G * 5 + B * 1) &gt;&gt; 3Gray = (R * 4 + G * 10 + B * 2) &gt;&gt; 4Gray = (R * 9 + G * 19 + B * 4) &gt;&gt; 5Gray = (R * 19 + G * 37 + B * 8) &gt;&gt; 6Gray = (R * 38 + G * 75 + B * 15) &gt;&gt; 7Gray = (R * 76 + G * 150 + B * 30) &gt;&gt; 8Gray = (R * 153 + G * 300 + B * 59) &gt;&gt; 9Gray = (R * 306 + G * 601 + B * 117) &gt;&gt; 10Gray = (R * 612 + G * 1202 + B * 234) &gt;&gt; 11Gray = (R * 1224 + G * 2405 + B * 467) &gt;&gt; 12Gray = (R * 2449 + G * 4809 + B * 934) &gt;&gt; 13Gray = (R * 4898 + G * 9618 + B * 1868) &gt;&gt; 14Gray = (R * 9797 + G * 19235 + B * 3736) &gt;&gt; 15Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16Gray = (R * 39190 + G * 76939 + B * 14943) &gt;&gt; 17Gray = (R * 78381 + G * 153878 + B * 29885) &gt;&gt; 18Gray = (R * 156762 + G * 307757 + B * 59769) &gt;&gt; 19Gray = (R * 313524 + G * 615514 + B * 119538) &gt;&gt; 20 这些精度实际上是一样的：3与4、7与8、10与11、13与14、19与20 所以16位运算下最好的计算公式是使用7位精度，比先前那个系数缩放100倍的精度高，而且速度快 Gray = (R * 38 + G * 75 + B * 15) &gt;&gt; 7 灰度转伪彩色本质就是将灰度值根据一定的比例关系转化为RGB三通道值。 人类能够观察到的光的波长范围是有限的，并且人类视觉有一个特点，只能分辨出二十几种灰度，也就是说即使采集到的灰度图像分辨率超级高，有上百个灰度级，但是很遗憾，人们只能看出二十几个，也就是说信息损失了五十倍。但人类视觉对彩色的分辨能力相当强，能够分辨出几千种色度。 以下为opencv中ColorMap提供的21种不同伪彩色： 根据源码中获得的数组对每个像素进行转换即可。 RGB模型图像处理中，最常用的颜色空间是RGB模型，常用于颜色显示和图像处理，三维坐标的模型形式。 原点到白色顶点的中轴线是灰度线，r、g、b三分量相等，强度可以由三分量的向量表示。 用RGB来理解色彩、深浅、明暗变化如下： 色彩变化： 三个坐标轴RGB最大分量顶点与黄紫青YMC色顶点的连线 深浅变化：RGB顶点和CMY顶点到原点和白色顶点的中轴线的距离 明暗变化：中轴线的点的位置，到原点，就偏暗，到白色顶点就偏亮 HSV色域这是针对用户观感的一种颜色模型，侧重于色彩表示，什么颜色、深浅如何、明暗如何。 色调H 用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°； 饱和度S 饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。 明度V 明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。 H是色彩 S是深浅， S = 0时，只有灰度 V是明暗，表示色彩的明亮程度 把RGB三维坐标的中轴线立起来，并扁化，就能形成HSV的锥形模型了。 RGB到HSV转化模型 首先要将图像的R、G、B三个通道的分量归一化到0 ~ 1之间。 我们设max为该像素点的RGB中的最大值，min为最小值，有如下公式： float max &#x3D; 0,min &#x3D; 0; max &#x3D; retmax(R,G,B); &#x2F;&#x2F; 计算三者的最大值 min &#x3D; retmin(R,G,B); v &#x3D; max; if(max &#x3D;&#x3D; 0) s &#x3D; 0; else s &#x3D; 1 - (min &#x2F; max); if(max &#x3D;&#x3D; min) h &#x3D; 0; else if(max &#x3D;&#x3D; R &amp;&amp; G &gt;&#x3D; B) h &#x3D; 60 * ((G - B) &#x2F; (max - min)); else if(max &#x3D;&#x3D; R &amp;&amp; G &lt; B) h &#x3D; 60 * ((G - B) &#x2F; (max - min)) + 360; else if(max &#x3D;&#x3D; G) h &#x3D; 60 * ((B - R) &#x2F; (max - min)) + 120; else if(max &#x3D;&#x3D; B) h &#x3D; 60 * ((R - G) &#x2F; (max - min)) + 240; HSV到RGB转化模型 float C &#x3D; 0,X &#x3D; 0,Y &#x3D; 0,Z &#x3D; 0; int i &#x3D; 0; float H &#x3D; h &#x2F; 1.0; float S &#x3D; s &#x2F; 100.0; float V &#x3D; v &#x2F; 100.0; if(S &#x3D;&#x3D; 0) R &#x3D; G &#x3D; B &#x3D; V; else &#123; H &#x3D; H &#x2F; 60; i &#x3D; (int)H; C &#x3D; H - i; X &#x3D; V * (1 - S); Y &#x3D; V * (1 - S * C); Z &#x3D; V * (1 - S * (1 - C)); switch(i)&#123; case 0 : R &#x3D; V; G &#x3D; Z; B &#x3D; X; break; case 1 : R &#x3D; Y; G &#x3D; V; B &#x3D; X; break; case 2 : R &#x3D; X; G &#x3D; V; B &#x3D; Z; break; case 3 : R &#x3D; X; G &#x3D; Y; B &#x3D; V; break; case 4 : R &#x3D; Z; G &#x3D; X; B &#x3D; V; break; case 5 : R &#x3D; V; G &#x3D; X; B &#x3D; Y; break; &#125; &#125; HSI色域与HSV色域表达的意义类似，区别在于取值的方式，基于I和V。 二者都是表示明度，V取值为R、G、B中的最大值，而I取值为R、G、B的均值。 RGB到HSI转化模型 HSI到RGB转化模型 HSL色域是工业界的另一种色彩模型标准。 HSL 和 HSV二者都把颜色描述在圆柱体内的点，这个圆柱的中心轴取值为自底部的黑色到顶部的白色而在它们中间是的灰色，绕这个轴的角度对应于“色相”，到这个轴的距离对应于“饱和度”，而沿着这个轴的距离对应于“亮度”，“色调”或“明度”。 这两种表示在目的上类似，但在方法上有区别。二者在数学上都是圆柱，但 HSV（色相，饱和度，明度）在概念上可以被认为是颜色的倒圆锥体（黑点在下顶点，白色在上底面圆心），HSL在概念上表示了一个双圆锥体和圆球体（白色在上顶点，黑色在下顶点，最大横切面的圆心是半程灰色）。注意尽管在HSL 和HSV 中“色相”指称相同的性质，它们的“饱和度”的定义是明显不同的。 在 HSL 中，饱和度分量总是从完全饱和色变化到等价的灰色（在 HSV 中，在极大值 V 的时候，饱和度从全饱和色变化到白色，这可以被认为是反直觉的）。 在 HSL 中，亮度跨越从黑色过选择的色相到白色的完整范围（在 HSV 中，V 分量只走一半行程，从黑到选择的色相）。 RGB到HSL转化模型 HSL到RGB转化模型 差影法原理上来说就是两幅图像作差对应的像素点之间作差。 常用于判断两幅角度相同的相似图像之间的差别。 可以通过对差值乘以一个倍数，实现放大差别的效果。 是否对差值使用绝对值计算，对作差的结果有一定影响。 二值化普通二值化遍历判断图像每个像素点的值，如果大于设定的阈值，则修改为255，如果小于，则修改为0。 大津法二值化图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响。它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量，背景和前景之间的类间方差越大，说明构成图像的两部分的差别越大，当部分前景错分为背景或部分背景错分为前景都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。 优点：计算简单快速，不受图像亮度和对比度的影响。适用于大部分需要求图像全局阈值的场合。 缺点：对图像噪声敏感；只能针对单一目标分割；当目标和背景大小比例悬殊、类间方差函数可能呈现双峰或者多峰，这个时候效果不好。 实现原理 同样用到了最大类间方差的概念，参考下面双阈值三值化，不再多叙述。 注： 为了快速计算，可将类间方差计算公式：σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 简化为：σ^2 = p1 * p2 * ( m1 - m2 ) ^ 2 局部自适应二值化核心就是对每个像素点，计算它指定大小邻域内的阈值，来作为这个像素点的二值化阈值。 邻域阈值的计算方法常用的有两种：均值和高斯加权和。 计算方法非常简单，在本文上述提到的均值滤波和高斯滤波的基础上，对计算出的每个像素点邻域内的均值或高斯加权和，减去一个指定的偏移量，就是该点的二值化阈值了。 双阈值三值化首先获取图像像素的直方图，即像素值为0 - 255的点分别有几个，并分别计算它们占总像素点数的比例（即一个点为该像素值的概率，Pi（i=0 - 255））。 其次设定两个阈值k1和k2，将0 - 255分为三类（0 - k1，k1 - k2，k2 - 255），计算： 一个点被分为其中一类的概率，表现为该类像素范围内概率的和。 这三类各自的像素均值，表现为： 于是有：mg = p1 * m1 + p2 * m2 + p3 * m3，且 p1+p2+p3 = 1 可得类间方差：（更多或更少类均同理） σ^2 = p1 * ( m1 - mg ) ^ 2 + p2 * ( m2 - mg ) ^ 2 + p3 * ( m3 - mg ) ^ 2 最终目的是为了获得当类间方差最大时的k1和k2 最后只需要判断每个像素点的值在这三类中的哪类，分别修改值为0，128，255即可。 因此代码实现为： for (k1 &#x3D; 1; k1 &lt; 256; k1++)&#123; for (k2 &#x3D; 1; k2 &lt; 256; k2++)&#123; for (int i &#x3D; 0; i &lt; k1; i++)&#123; p1 +&#x3D; Pi; m1 +&#x3D; i * Pi; &#125; for (int i &#x3D; k1; i &lt; k2; i++)&#123; p2 +&#x3D; Pi; m2 +&#x3D; i * Pi; &#125; for (int i &#x3D; k2; i &lt; 256; i++)&#123; p3 +&#x3D; Pi; m3 +&#x3D; i * Pi; &#125; mg &#x3D; m1 + m2 + m3; m1 &#x2F;&#x3D; p1; m2 &#x2F;&#x3D; p2; m3 &#x2F;&#x3D; p3; &#x2F;&#x2F; 类间方差 double sigma &#x3D; p1 * pow(m1 - mg, 2) + p2 * pow(m2 - mg, 2) + p3 * pow(m3 - mg, 2); if (max &lt; sigma)&#123; max &#x3D; sigma; thres1 &#x3D; k1; thres2 &#x3D; k2; &#125; &#125; &#125; 几何变换图像的缩放最近邻插值 由于缩放比例（即srcWidth / dstWidth）基本上是浮点数值，而最后得到的图像坐标（srcX）是整数。因此需要对等式右边的值进行四舍五入的操作： int srcX &#x3D; static_cast&lt;int&gt;(dstX * (srcWidth &#x2F; dstWidth) + 0.5f); &#x2F;&#x2F; 其中static_cast用于强制转换为int类型 &#x2F;&#x2F; +0.5f是为了实现四舍五入而不是舍去小数点后的值 这种方法在放大图像时容易导致图像的严重失真，根源在于当坐标是浮点数时直接四舍五入取最近的整数。 双线性插值线性插值的解释 已知数据 (x0, y0) 与 (x1, y1)，要计算 [x0, x1] 区间内某一位置 x 在直线上的y值。 双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。如下图： 假如我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。最常见的情况，f就是一个像素点的像素值。首先在 x 方向进行线性插值，得到： 然后在上述基础上（R1和R2），在 y 方向进行线性插值，得到： 展开即为最终结果： 代码实现 由于图像双线性插值只会用相邻的4个点，因此上述公式的分母都是1。opencv中的源码如下，用了一些优化手段： 用整数计算代替float（下面代码中的 * 2048就是变11位小数为整数，最后有两个连乘，因此&gt;&gt;22位） 源图像和目标图像几何中心的对齐 SrcX&#x3D;(dstX + 0.5) * (srcWidth&#x2F;dstWidth) -0.5 SrcY&#x3D;(dstY + 0.5) * (srcHeight&#x2F;dstHeight) - 0.5 源图像和目标图像的原点（0，0）均选择左上角，然后根据插值公式计算目标图像每点像素，假设你需要将一幅5x5的图像缩小成3x3，那么源图像和目标图像各个像素之间的对应关系如下。如果没有这个中心对齐，根据基本公式去算，就会得到左边这样的结果；而用了对齐，就会得到右边的结果： 双立方插值邻域像素再取样插值lanczos插值图像的旋转旋转矩阵的计算原理参考： 实现方法： 采用反向映射。即从旋转后的图像出发，找到对应的原图像的点，然后将原图像中的灰度值传递过来即可，这样旋转后的图像的每个像素肯定可以对应到原图像中的一个点。 采用不同的策略算法可以使像素更加准确，*具体参照图像缩放中的各种插值法，在旋转中是同理。 直线拟合 这里只记录最常用的一种：最小二乘拟合算法 这种方法是以距离平方和为拟合判据，运行速度也最快。但是这个算法也有个很大的问题，就是当干扰点离直线较远时，一个干扰点就可能将整条拟合直线拉偏了。简单的说就是对干扰点的鲁棒性不够。 代码实现 假设直线表达式为：y = ax + b，a表示斜率，b表示截距。 对于等精度测量所得到的N组数据（xi，yi），i＝1，2……，N，其中xi值被认为是准确的，所有的误差只联系着yi；用最小二乘法估计参数时，要求观测值yi的偏差的加权平方和为最小。对于等精度观测值的直线拟合来说，可使下式的值最小： 令上式等于D，并分别对a，b求一阶偏导数： 再求二阶偏导数： 很显然二阶偏导数均为非负数，于是令一阶偏导数等于0，解得a和b： 若要转化成方向向量： 因为方向向量长度为1且起点为原点，所以易得：x^2 + a * x^2 = 1，解得： **x = 1 / sqrt( a^2 + 1 ) ** **y = a / sqrt( a^2 + 1 ) ** 即为方向向量。","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"},{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"图像","slug":"图像","permalink":"https://www.hanhan0223.cn/tags/%E5%9B%BE%E5%83%8F/"}]},{"title":"opencv移库笔记","slug":"opencv移库笔记","date":"2021-12-23T11:28:33.000Z","updated":"2022-11-07T10:39:23.766Z","comments":true,"path":"杂记/opencv移库笔记/","link":"","permalink":"https://www.hanhan0223.cn/%E6%9D%82%E8%AE%B0/opencv%E7%A7%BB%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"环境配置VMware Workstation版本 16.0版本！ 16.0版本！ 16.0版本！15版本的有bug，会闪退。 VMware Tools实现物理机和虚拟机之间的文件和文本的直接复制粘贴 1.点击虚拟机选项中的安装，安装的是个tar.gz的压缩包 2.将虚拟机解压至任意路径下，并在该路径下进入命令行 3../vmware-install.pl即可完成安装","text":"环境配置VMware Workstation版本 16.0版本！ 16.0版本！ 16.0版本！15版本的有bug，会闪退。 VMware Tools实现物理机和虚拟机之间的文件和文本的直接复制粘贴 1.点击虚拟机选项中的安装，安装的是个tar.gz的压缩包 2.将虚拟机解压至任意路径下，并在该路径下进入命令行 3../vmware-install.pl即可完成安装 Ubuntu16.0版本，用户名和密码设简单点！建议英文！ 切换中文输入法用Ctrl+空格。 解压：tar -zxvf xxx.tar.gz 分辨率cvt 1920 1080 &#x2F;&#x2F; 返回 # 1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.00 MHz Modeline &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync &#x2F;&#x2F; 增加显示模块，并设置为开机启动，编辑”&#x2F;etc&#x2F;profile”，在末尾增加： xrandr --newmode &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync xrandr --addmode VGA1 &quot;1920x1080_60.00&quot; &#x2F;&#x2F; 立即启用 source &#x2F;etc&#x2F;profile 之后就可以在设置中的Display里修改啦。 opencv库安装与编译下载1.在GitHub上下载了opencv4.1.1的库，并在Ubuntu中解压 2.下载 ippicv_2019_lnx_intel64_general_20180723，这个压缩包无需解压 3.将opencv-4.1.1/3rdparty/ippicv/ippicv.cmake文件中倒数第十行(以http开头的)修改成”file://path“, path为下载的ippicv_2019_lnx_intel64_general_20180723在你的电脑中存放的位置（绝对路径） 安装依赖包sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 编译opencv在opencv-4.1.1路径下 mkdir build cd build cmake -D CMAKE_BUILD_TYPE&#x3D;Release -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local -D OPENCV_GENERATE_PKGCONFIG&#x3D;ON .. &#x2F;&#x2F; 这里选择安装路径为&#x2F;usr&#x2F;local下，并开启了pkg-config &#x2F;&#x2F; 因为opencv4开始就不会主动支持pkg-config了，但是编译还是需要这个。 &#x2F;&#x2F; 一定注意这两个点“..”，这是选择编译的内容为整个opencv文件夹 &#x2F;&#x2F; 编译结束后进入下一步： make -j8 &#x2F;&#x2F; 这一步比较久一点，8为选择编译时使用的内核数 sudo make install opencv_version &#x2F;&#x2F;编译结束后运行，若能查看到版本号就ok了 sudo gedit &#x2F;etc&#x2F;ld.so.conf.d&#x2F;opencv.conf &#x2F;&#x2F;设置opencv的环境变量。(文件可能为空，即原来不存在，新建立的) &#x2F;&#x2F;将如下内容添加到最后： &#x2F;usr&#x2F;local&#x2F;lib (依然要对应成你本身的路径，这个看看安装好之后，你的安装路径下的lib文件夹位置) &#x2F;&#x2F;配置库 sudo ldconfig &#x2F;&#x2F;更改环境变量： sudo gedit &#x2F;etc&#x2F;bash.bashrc &#x2F;&#x2F;在文件后添加 PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;home&#x2F;ubun&#x2F;myinstall&#x2F;lib&#x2F;pkgconfig export PKG_CONFIG_PATH opencv 编译后主要文件位于 /usr/local/bin /usr/local/include/opencv4 /usr/local/lib 导入opencv扩展包1.下载opencv_contrib-4.1.1扩展包 2.将文件夹解压至opencv-4.1.1文件夹下，同时删除其下的build文件夹（之前的编译文件） 3.下载可能缺少的.i文件（会导致编译失败） 将下载的.i文件放至**/opencv_4.1.1/opencv_contrib-4.1.1/modules/xfeatures2d/src/**目录下 4.按照上一节的步骤重新编译，其中编译命令做一点改动（增加一句） cmake -D CMAKE_BUILD_TYPE&#x3D;Release -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local -D OPENCV_EXTRA_MODULES_PATH&#x3D;&#x2F;home&#x2F;shenzihan&#x2F;opencv-4.1.1&#x2F;opencv_contrib-4.1.1&#x2F;modules&#x2F; -D OPENCV_GENERATE_PKGCONFIG&#x3D;ON .. 5.在执行make -j4时可能会报错：fatal error: features2d/test/test_detectors_regression.impl.hpp: No such file or directory 按照内容，将opencv-4.1.1/modules/下的features2d文件夹复制到build文件夹下即可。 移植opencv总体流程1.封装函数 需求的操作系统环境下，只允许int char等基本类型的数据类型，因此需要将opencv库中定义的类型（如Mat）做一个转换。函数的输入不再是Mat而是转化成unsigned char和int。 也就是需要在每个opencv函数外面套一层壳，先将unsigned char和int 转为Mat CPoint等输入opencv函数，返回值再转回unsigned char和int作为移植函数的返回值，即可。 2.生成.so动态链接库 编译写好的移植函数生成.so文件： g++ -fpic -shared -o target.so source.cpp &#96;pkg-config --cflags --libs opencv4&#96; -std&#x3D;c++11 一步到位，直接生成.so文件 3.在测试文件中调用so文件测试功能 void * LdSoHandle&#x3D;dlopen(&quot;.&#x2F;target.so&quot;, RTLD_NOW|RTLD_GLOBAL); 4.编译测试文件生成可执行文件 g++ -std&#x3D;c++11 main.cpp -o mai &#96;pkg-config --cflags --libs opencv4&#96; -ldl &#x2F;&#x2F; -ldl一定要加上 opencv图像类型参数的值 类型 int值 elemSize() CV_8UC1 0 1 CV_8UC2 8 2 CV_8UC3 16 3 CV_32FC1 5 4 CV_32FC2 13 8 CV_32FC3 21 12 CV_16FC1 7 2 CV_16FC2 15 4 CV_16FC3 23 6","categories":[{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"环境","slug":"环境","permalink":"https://www.hanhan0223.cn/tags/%E7%8E%AF%E5%A2%83/"}]},{"title":"PyQt5狗都不用:阴阳师挂机软件OnHook","slug":"PyQt5狗都不用-阴阳师挂机软件OnHook","date":"2021-08-11T15:02:25.000Z","updated":"2022-11-07T10:39:23.705Z","comments":true,"path":"应用/PyQt5狗都不用-阴阳师挂机软件OnHook/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E7%8B%97%E9%83%BD%E4%B8%8D%E7%94%A8-%E9%98%B4%E9%98%B3%E5%B8%88%E6%8C%82%E6%9C%BA%E8%BD%AF%E4%BB%B6OnHook/","excerpt":"阴阳师玩家占比最大的行为就是刷魂土了，但作为万年老咸鱼，单刷得12体，500樱饼完全挂不了多少局自动。而手动挂……既然是重复操作，就有办法用自动化脚本来代替，于是想到了最简单的模拟鼠标事件来实现。 源码（包含2.0的GUI程序和单独的挂机python脚本）：Github 百度云：OnHook 提取码：mc13 脚本很简单的思路——每一轮只需要两次移动和点击事件，识别到开始界面第一次移动并点击开始按钮，识别到结束界面第二次移动点击奖励界面退出去，然后循环。 为了怕被检测封号，需要对这样机械的行为进行一定伪装：比如一次点击事件的点击次数随机1-3次；每次点击的间隔在0.15-0.3s之间随机；每次移动的时间在0.05-0.25s随机；每次点击的像素点坐标在识别到的点击区域中随机等等。不知道有多大用，感觉是跟我个人手动挂的习惯比较相符的==","text":"阴阳师玩家占比最大的行为就是刷魂土了，但作为万年老咸鱼，单刷得12体，500樱饼完全挂不了多少局自动。而手动挂……既然是重复操作，就有办法用自动化脚本来代替，于是想到了最简单的模拟鼠标事件来实现。 源码（包含2.0的GUI程序和单独的挂机python脚本）：Github 百度云：OnHook 提取码：mc13 脚本很简单的思路——每一轮只需要两次移动和点击事件，识别到开始界面第一次移动并点击开始按钮，识别到结束界面第二次移动点击奖励界面退出去，然后循环。 为了怕被检测封号，需要对这样机械的行为进行一定伪装：比如一次点击事件的点击次数随机1-3次；每次点击的间隔在0.15-0.3s之间随机；每次移动的时间在0.05-0.25s随机；每次点击的像素点坐标在识别到的点击区域中随机等等。不知道有多大用，感觉是跟我个人手动挂的习惯比较相符的== python现成的pyautogui库： click(x, y) 函数模拟点击 move(x, y) 函数模拟移动 locateOnScreen(image_path, confidence=0.8) 函数获取指定png图片在当前屏幕状态下的左上角坐标和宽高（这里值得一提的是这个函数默认100%相同才识别，有点苛刻，需要修改参数confidence=0.8差不多。但是这个参数的使用是需要调用cv2这个库的，python的依赖属实==顺带吐槽一下，这个库能一下让后面封装的exe应用程序的大小扩大一倍，pyinstaller出来的exe实在太大了）。 整体代码结构，如果把一整个放到while里，按照顺序死循环识别图片，会导致响应的不够及时。而为每一类图片的识别开一个线程又太奢侈了，于是最终选择了协程——又称为微线程，它是实现多任务的另一种方式，只不过是比线程更小的执行单元（操作系统为了程序运行的高效性，每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作，所以线程的切换非常耗性能。但是协程的切换只是单纯地操作CPU的上下文，一秒钟切换上百万次都不会卡死）。 同样的，python有封装好的非常好用的三方库gevent： spawn(func, info) 函数将生成一个协程并绑定func函数，可带输入信息； 将所有协程加入一个list中，通过 joinall(list) 将存储所有协程的矩阵加入协程池，并开始执行所有协程，当所有协程执行完后返回； sleep(time) 将立即休眠当前线程指定时间。 最后就是组装了。将通过pyautogui库实现的识别指定位置并模拟点击行为封装成函数，在spawn中导入，输入为每一类的图片路径即可实现脚本功能。因为这个函数中写有while(True)，因此每个协程都不会主动停止，需等待外部指令中断运行。 也不知道是不是还没过完以前做上位机时的瘾，，每次写个脚本都想封装成exe配个GUI界面……而我只会qt……PyQt5的封装实在太大了，用了各种方法也没能给它压缩下去==想学一下C#了…… version 1.0 经典老界面，我这审美没救了。 P1：可以选择挂机方案，输入挂机轮数（不输入就是无限挂），主窗口显示每次鼠标行为的信息，停止后返回总挂机轮数和用时。 P2：设置挂机方案，双击编辑方案名和选择该方案所需识别的截图。 P3：截图功能，仿QQ。（这里学到了PyQt一个很重要的函数**paintEvent( )**，超级有用，是实现动态效果的好帮手，帮助实现了2.0版本中不少特效） 这软件单独一个窗口，用起来不方便，也不好看，功能还四不像，跟个缝合怪似的，做完就被我放弃了。。 我老想让一个软件的功能尽可能完善，所以每次能想到的可能会用到的都加进去，就很冗余。。 于是立马着手2.0版本👇 version2.0 嗯，主界面如上图所示，挂在客户端的左上角，面积很小，然后改了改UI，看上去还行哈哈。 设计的灵感来自于炉石的HDT插件（看胜率那个），也是悬挂在炉石界面的顶部，看上去轻便美观，一目了然。 功能介绍： 1.第二块 用于显示挂机成功的轮数，简洁明了~停止后再次开始就会重新计数。 2.第三块 是控制开始结束的按钮，主要绑定了三个事件：1.按钮图标的变化；2.挂机线程的启动/停止；3.时间统计框的弹出/落下。 很简单，每次点击判断状态然后修改图标至相应状态 即可； 这里要注意，挂机脚本的函数内是死循环！也就是说当协程被执行，GUI界面会处于假死状态，无法进行任何的UI交互。因此，使用QThread分出一个子线程用于控制挂机任务，将挂机任务的函数内容重写至QThread的run( ) 函数内即可。这里还要注意，中止时不仅需要杀死这个子线程，同时也需要杀死已加入协程池的所有协程。否则鼠标事件依旧会执行。 这个就是纯UI的设计了，使用了github上的方案pyqt5Custom.Toast类👉pyqt5Custom。 首先是一个水平布局，包含一个icon图标、文本Label和关闭按钮，设置了qss样式（黑色半透明，圆角，按钮default、press、hover等不同样式）。其次是动态升起和落下的特效，这里用到了上述的paintEvent( ) 事件。 这个函数不能被直接调用，而是被动触发的，触发条件为——当窗口需要被重绘时（包含第一次显示）（这里又关联了另一个pyqt5内置函数：update( ) 用于发送窗口绘制事件）。那么动态原理就简单了： 通过在父子类中相互调用彼此的update函数实现循环，不断触发paintEvent，在其中使用setGeometry函数不断的调整这个框的显示位置直至达到预期的显示位置。 控制窗体移动的速度变化：采用先快后慢的变化曲线，在视觉感官上会比较自然舒服。因此选用了在0~1之间呈现此曲线的 y = 1 - (1-x) ^ 4 函数。设置参数speed控制速度快慢，计算每次重绘窗体和开始移动时的时间戳之差t，用 speed * t 作为x的输入，那么随着时间的变化，y的值会逐渐接近1直至达到。最后只需要将：原坐标 +/- (y * 移动距离) 这一数据作为setGeometry的输入，就可以实现移动效果了。 3.第一块 用于打开设置选项，如上图所示。选项中包含挂机方案的选择、创建桌面快捷方式和关闭程序的按钮。 唔，弹出收回的动态效果是对上述Toast类的修改，修改了内部的布局内容和动态弹出的方向。另外在收回时的速度曲线我认为是应该跟上述的 y = 1 - (1-x) ^ 4 关于y=x对称的，即先慢后快，因此修改了曲线函数为 y = x ^ 3。 而GUI界面中所有按钮包括方案的分段按钮组的特效都是在paintEvent( ) 这个函数的基础上来实现的。这个函数真的非常非常的重要！ 设置选项里的按钮们的颜色、背景颜色和动态效果等其实我也没想到什么更好的方案，总觉得怪怪的，但又还行。。就先这样了。 PyQt5这个库我暂时是不想再用了。。因为封装的应用程序实在是太大了。。。好蠢，而且启动速度也很慢……接下来要学C#和C++了，正好也是实验室主用的编程语言~ 不过这个GUI界面我还是比较满意的哈哈哈~就酱 something今天是2022.1.9，从我加入实验室以来已经快一学期了，确实干上了C#相关的活。。。但感觉自定义UI还是Qt香就是说QAQ","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"ID卡与IC卡原理","slug":"ID卡与IC卡原理","date":"2020-08-14T15:27:28.000Z","updated":"2022-11-07T10:39:23.694Z","comments":true,"path":"原理/ID卡与IC卡原理/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/ID%E5%8D%A1%E4%B8%8EIC%E5%8D%A1%E5%8E%9F%E7%90%86/","excerpt":"ID卡（非接触卡）的读卡原理1.简单描述ID卡全称为身份识别卡（Identification Card）,是一种不可写入的感应卡,含固定的编号,主要类型有台湾SYRIS的EM格式，美国HID,TI,MOTOROLA等。 在出厂时，厂家会将ID号写死在芯片的内部，是不允许进行二次修改的。国内常见的型号有EM4100和EM4102。 有别于IC卡这种高频（13.56MHz）、可加密的存储卡，ID卡属于低频（125KHz）的只读卡。 2.读卡流程1.读卡器采用射频识别技术（RFID），持续发射特定频率的射频信号 2.当ID卡进入读卡器工作范围时，将产生感应电流，将自身芯片内的编码信息通过线圈发送出去 3.读卡器接收到从ID卡发送来的调制信号，经过解调后，得到ID卡的编码信息","text":"ID卡（非接触卡）的读卡原理1.简单描述ID卡全称为身份识别卡（Identification Card）,是一种不可写入的感应卡,含固定的编号,主要类型有台湾SYRIS的EM格式，美国HID,TI,MOTOROLA等。 在出厂时，厂家会将ID号写死在芯片的内部，是不允许进行二次修改的。国内常见的型号有EM4100和EM4102。 有别于IC卡这种高频（13.56MHz）、可加密的存储卡，ID卡属于低频（125KHz）的只读卡。 2.读卡流程1.读卡器采用射频识别技术（RFID），持续发射特定频率的射频信号 2.当ID卡进入读卡器工作范围时，将产生感应电流，将自身芯片内的编码信息通过线圈发送出去 3.读卡器接收到从ID卡发送来的调制信号，经过解调后，得到ID卡的编码信息 3.工作原理1.读卡器发送射频信号：推挽式功放电路（放大）+LC谐振电路（选频） + 2.ID卡返回编码信息：负载调制 关于负载调制： 通常使用电阻负载调制，原理图如下： 当芯片工作时，会产生由内部存储的编码信息的数据流（即0和1，也就是高低电平），数据流控制开关s的变化，从而改变右端负载的大小。当数据为1时，s接通，负载变小，品质因数会降低，谐振回路两端电压降低；数据为0时同理。线圈右端的电压变化，通过线圈电感耦合传递给读写器，最终改变读写器两端电压的振幅变化，产生包络。如下图所示： 图中a为原本信号，b为ID卡线圈的电压，c为读卡器收到的未解调的电压信号，而红框中包络即为解调后的信号。 整体过程：当ID卡靠近读卡器，谐振将能量感应到了卡内线圈上，产生电流并对电容进行充电，于是产生了使芯片工作的电源电压。芯片输出存储的数据流，通过负载调制的方式将数据发送给了读卡器。 3.读卡器解调信号获取编码：包络检波+滤波整形 上文中提到读卡器接收到的载波的包络即为我们想要的数据，这些数据的编码方式为曼彻斯特码。要获取这些数据就需要包络检波。 上图为包络检波部分电路，获取到载波的包络部分，但是还需要进行滤波整形获得平滑的直流电压（曼彻斯特码），如下图： 以上电路就是读卡器和ID卡内所需的一些电路。在最后获取到ID卡相应卡号的曼彻斯特码后，只需要对其进行解码即可获得ID卡卡号，并和后台数据对比判断能否通过验证~ 4.曼彻斯特码常见编码方式分为以下几种： 1.NRZ编码（不归零编码）：数据1和0分别用高低电平表示，当一位数据传输完后电平信号不归零。 2.BiPhase编码（双相编码）：每当一位数据传输后，电平跳变一次。 3.曼彻斯特编码：利用信号边沿来表示0和1，并且跳变发生在位帧中间，比如上升沿表示1，下降沿0。 曼彻斯特码的编码 设数据传输的波特率为f，则一个位的时长为1/f，半个位帧的时长为T = 1/2f。 设两个函数RisingEdge(T)和FallingEdge(T)，执行过程如下： RisingEdge(T)：输出低电平，等待T，输出高电平，等待T，返回； FallingEdge(T)：输出高电平，等待T，输出低电平，等待T，返回。 编码的流程如下： 曼彻斯特码的解码 1.获取数据流的波特率 2.同步数据流的时钟信号（区分位帧边沿和半位帧边沿） 3.根据编码原理进行解码即可 5.常见ID卡型号的卡号数据格式（EM4100）EM4100可存储64bits数据，可读不可写，它的数据格式如下： **1.**第一行，是9个“1”，这是EM4100固定的格式 **2.**D00D03，就是第一个ID号，P0代表的是第一行的偶校验（例：0010_1/0001_1/0110_0）当D00D03中0的个数不为偶数时，偶校验置1。P0-P9均为每行前四位的偶校验，ID号共10位 **3.**PC0~PC3为每列（P0-P9）的偶校验，（例：0000000110_0） 4.举个栗子：卡号为06001259E3，转换可得111111111 00000 01100 00000 00000 00011 00101 01010 10010 11101 00110 01000（这一串64位就是曼彻斯特码解码后得到的数据） **5.**在编写程序判断卡号时，应舍弃前63位数据，只取第一次64位码中的停止位0作为开头，以0111111111作为校验开头，判断第二次64位数据中的前63位数据是否符合。同理，判断完后本次的第64位停止位0作为开头再次判断，重复三次，确认卡号正确。 **6.**卡号06001259E3，其中的第一位0为版本号，第二位6为客户号，后面8位为ID号。 7.若卡面有标注卡号，格式一般为0001202659 (18,23011)。分别为ABA码和wiegand26码。ABA码由8位ID号转换成10进制可得，共10位，少位在前补0。wiegand26码这组数据分别为8位ID号的倒数56位和倒数后四位转换成十进制组成。 关于IC卡相比于ID卡，IC卡在目前的应用更加的广泛1、安全性 IC卡的安全性远大于ID卡，ID卡内的卡号读取无任何权限,易于仿制。IC卡内所记录数据的读取，写入均需相应的密码认证,甚至卡片内每个区均有不同的密码保护，全面保护数据安全，IC卡写数据的密码与读出数据的密码可设为不同，提供了良好分级管理方式，确保系统安全。 2、可记录性 ID卡不可写入数据,其记录内容(卡号)只可由芯片生产厂一次性写入，开发商只可读出卡号加以利用，无法根据系统的实际需要制订新的号码管理制度。IC卡不仅可由授权用户读出大量数据，而且亦可由授权用户写入大量数据(如新的卡号，用户的权限，用户资料等)，IC卡所记录内容可反复擦写。 3、存储容量 ID卡仅仅记录卡号；而IC卡(比如Philips mifare1卡)可以记录约1000个字符的内容 4、脱机与联网运行 由于ID卡卡内无内容，故其卡片持有者的权限，系统功能操作要完全依赖于计算机网络平台数据库的支持。 而IC卡本身已记录了大量用户相关内容(卡号，用户资料，权限，消费余额等大量信息)，完全可以脱离计算机平台运行,实现联网与脱机自动转换的运行方式，能够达到大范围使用，少布线的需求。 5、一卡通扩展应用 ID卡由于无记录,无分区,只能依赖网络软件来处理各子系统的信息,这就大大增加对网络的依赖；如果在ID卡系统完成后,用户欲增加功能点，则需要另外布线,这不仅增加了工程施工难度,而且增加了不必要的投资.所以说,使用ID卡来做系统,难以进行系统扩展,难以实现真正的一卡通。 而IC卡存储区自身分为16个分区，每个分区有不同的密码,具有多个子系统独立管理功能，如第一分区实现门禁，第二分区实现消费,第三分区实现员工考勤等等。充分实现一卡通的目的,并且可以做到完全模块化设计，用户即使要增加功能点，也无需再布线,只需增加硬件和软件模块，这便于IC卡系统以后的随时升级扩展,实现平稳升级,减少重复投资。 6、智能化系统的维护和运行 比如：电脑发行了一张新的用户ID卡,就必须通过ID卡系统的网络,用人工方式将所有ID卡号一个个下载到各ID卡读卡控制器中，否则ID卡被作为无效卡而不能使用;若要更改用户权限，则需在每个ID卡控制器上输入有权限的ID卡号。 又比如：在系统投入使用后经常要新增ID卡,则每新增一张卡或修改了某一张卡片的权限,就必需在该卡可用的所有控制器上输入该卡片号码，这就增加了工作量 关于手机NFC功能苹果手机仅支持apple pay，门禁、公交等功能并不支持。小米还是香嗷。 在b站看到稚晖大佬做了一个可以存储多张ic卡信息的小卡片，开源了👉L-ink_Card 以后有机会想自己实现一哈","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"}]},{"title":"关于url编码","slug":"关于url编码","date":"2020-05-20T14:20:46.000Z","updated":"2022-11-07T10:39:23.769Z","comments":true,"path":"原理/关于url编码/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Eurl%E7%BC%96%E7%A0%81/","excerpt":"为什么需要URL编码1.URL 只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。这意味着 如果URL中有汉字，就必须编码后使用。但问题在于，标准的国际组织并没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这会导致”URL编码”成为了一个混乱的领域。 2.对于get传参的网页来说，采取的是如下方式 ( ? key = value ) 问题在于，若是传的参数中包含？和=怎么办，就冲突了，所以需要编码以区分 http:&#x2F;&#x2F;www.biquge.tv&#x2F;modules&#x2F;article&#x2F;search.php?searchkey&#x3D;xxx","text":"为什么需要URL编码1.URL 只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。这意味着 如果URL中有汉字，就必须编码后使用。但问题在于，标准的国际组织并没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这会导致”URL编码”成为了一个混乱的领域。 2.对于get传参的网页来说，采取的是如下方式 ( ? key = value ) 问题在于，若是传的参数中包含？和=怎么办，就冲突了，所以需要编码以区分 http:&#x2F;&#x2F;www.biquge.tv&#x2F;modules&#x2F;article&#x2F;search.php?searchkey&#x3D;xxx 如何进行URL编码Url编码通常也被称为百分号编码（percent-encoding），编码方式非常简单。 使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。 对于ASCII字符，字母a 在ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，字母abc， url编码后得到的就是%61%62%63。 对于非ASCII字符，在无BOM编码格式中有UTF-8和GBK两种。 1.”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到”%E4%B8%AD%E6%96%87”。 2.“中文”使用GBK编码得到 %D6%D0%CE%C4。 注意一定要先进行编码再向服务器提交，这样可以保证只使用了固定的一种编码方式。 python中的URL编码与解码封装成以下库： 编码和解码的调用： 小说爬取爬小说的脚本写的时候没碰到什么别的问题，就是一个编码的问题，之前不了解，所以写了这篇文章码一下。 在用爬虫向网页提交搜索信息（小说名字）的时候： http:&#x2F;&#x2F;www.biquge.tv&#x2F;modules&#x2F;article&#x2F;search.php?searchkey&#x3D;%bd%a3%c0%b4 需要用到URL编码来提交（因为我爬的那个网站用的是get方式提交信息，并且是GBK编码）","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]},{"title":"关于RSA加密算法","slug":"关于RSA加密算法","date":"2020-05-16T14:27:37.000Z","updated":"2022-11-07T10:39:23.766Z","comments":true,"path":"原理/关于RSA加密算法/","link":"","permalink":"https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8ERSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"RSA是目前使用最广泛的公钥密码体制之一。 RSA产生公私钥对1.随机选取两个相近但不相等的质数p和q（越大越难破解） 取p=11，q=13，n = p * q = 143，n即为密钥长度，143二进制为10001111，密钥为8位。实际应用中，一般为1024位。 2.计算n的欧拉函数z z = (p-1)(q-1) = 120 3.随机选择一个整数e，作为公钥中用来加密的数字 条件1 &lt; e &lt; z，且e与z互质。假设随机选择e = 7（实际中常选择为65537） 4.计算e对于z的模反元素d，作为密钥中用来解密的数字 模反元素指存在一个整数d，使得e * d mod z = 1。带入可得d = 103 5.将n和e封装成公钥（143，7），n和d封装成密钥（143，103）","text":"RSA是目前使用最广泛的公钥密码体制之一。 RSA产生公私钥对1.随机选取两个相近但不相等的质数p和q（越大越难破解） 取p=11，q=13，n = p * q = 143，n即为密钥长度，143二进制为10001111，密钥为8位。实际应用中，一般为1024位。 2.计算n的欧拉函数z z = (p-1)(q-1) = 120 3.随机选择一个整数e，作为公钥中用来加密的数字 条件1 &lt; e &lt; z，且e与z互质。假设随机选择e = 7（实际中常选择为65537） 4.计算e对于z的模反元素d，作为密钥中用来解密的数字 模反元素指存在一个整数d，使得e * d mod z = 1。带入可得d = 103 5.将n和e封装成公钥（143，7），n和d封装成密钥（143，103） 题外话：关于m^e mod n的手动计算方法利用 (a×b) mod m = ((a mod m) × (b mod m)) mod m 这个公式 设三个变量a，b，c，对于m^e mod n，令a = e,b = m, c = 1 然后重复以下步骤： 1.判断a是奇数，进第2步；偶数进第3步 2.a = a - 1, c = (c*b) mod n,回到第1步 3.a = a / 2, b = (b*b) mod n,回到第1步 直到a = 0, c 就是最终结果 RSA的加密和解密加密：c = m^e mod n 解密：m = c^d mod n 首先对明文进行比特串分组，且保证每个分组对应的十进制数小于n，然后对每个分组进行一次加密，所有分组的密文组成的序列就是最终密文了。 举两个栗子： 1.以数据加密为例： 甲向乙发送机密数据信息m=85，并已知乙的公钥(n,e)=(143,7)，于是可计算出：c = 123甲将c发送至乙，乙利用私钥(n,d)=(143,103)对c进行计算：m = 85则乙得到甲向其要发送的机密数据信息。甲向乙发送信息，甲所拥有的仅仅是乙的公钥。 2.以数字签名为例： 乙要向甲发送信息，并要让甲确信此信息是由乙本人所发出的，于是，乙将能代表自己身份的编码值（如：123），利用私钥(n,d)=(143,103)进行计算，并将结果发送给甲：m = 85甲接受到乙的数字签名后利用乙的公钥(n,e)=(143,7)进行计算，得出代表乙身份的编码：c = 123现甲经过验证已确信信息的发送方为乙。因为只有乙拥有私钥(n,d)，来对代表自己身份的编码123进行计算。在这里，乙向甲发送信息并进行签名，甲所拥有的也仅仅是乙的公钥来验证乙的签名。 RSA实际应用在基于序列号保护的共享软件中应用RSA。 在某一共享软件中，甲想用123为注册名进行软件注册，他现在拥有的仅仅是存在于共享软件程序中的公钥(n,e)=(143,7)。 甲现将123为注册名向乙提出注册申请，乙得知此申请并通过此申请后，便利用所拥有的私钥(n,d)对注册名123进行计算：m = 85 甲得到计算后的结果85（序列号），提供给共享软件的注册程序进行计算：c = 123 然后注册程序将判断计算结果c是否为123（注册名），以决定注册是否通过。 如果甲随意输入一组序列号利用公钥(n,e)进行计算，那他得到的结果将不是123，注册也就失败了。注意，在这里，共享软件的注册程序比较的是注册名，而不是序列号。 如果甲跟踪注册程序得到了他所随意输入的序列号所产生的注册名，将其提供给注册程序，那注册程序也能够通过注册，但他由于没有(n,d)，所以他无法用自己的注册名进行软件注册，也就防止了非法注册机的制作。 将RSA应用于此的目的仅仅是防止非法注册机的制作，在以上描述中，n=143，包括以下Demo中的n(HEX)=963251DC5A9C90D9F203A03C363BA411，以现在的计算机处理速度，能很快地将其因式分解得到相应的p，q，再结合暴露在共享软件注册程序中的e，从而计算出d，那么这个共享软件的保护就完全被破解了。解决的方法是要避免n过短，以及结合MD5等加密算法……","categories":[{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]},{"title":"获取bilibili视频文件和封面","slug":"获取bilibili视频文件和封面","date":"2020-04-30T15:27:07.000Z","updated":"2023-06-29T11:01:48.534Z","comments":true,"path":"应用/获取bilibili视频文件和封面/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/%E8%8E%B7%E5%8F%96bilibili%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E5%92%8C%E5%B0%81%E9%9D%A2/","excerpt":"前两天在阿草微博粉丝群水群的时候，看到有朋友说馋想要一个往期视频的封面，但不知道咋保存~（网上有封面提取的网站） 我一想，应该可以用爬虫去实现嘛，挺有意思的，就尝试着写了一下，链接如下👇 获取b站视频封面 （现在挂在我的云服务器上，但等到过期了就寄了，GitHub Page并不支持php。话说当初学php就是因为在云服务器上建站用的WordPress，想改别人的主题但是看不懂代码才去学的） 三项功能： 输入视频的网址、BV号获取AV号（AV号明面上已经被b站禁了，但后台实际还在）； 输入视频的网址、BV号、AV号获取视频封面； 输入up主的UID获取该up主所有视频的封面，并打包成zip文件下载。","text":"前两天在阿草微博粉丝群水群的时候，看到有朋友说馋想要一个往期视频的封面，但不知道咋保存~（网上有封面提取的网站） 我一想，应该可以用爬虫去实现嘛，挺有意思的，就尝试着写了一下，链接如下👇 获取b站视频封面 （现在挂在我的云服务器上，但等到过期了就寄了，GitHub Page并不支持php。话说当初学php就是因为在云服务器上建站用的WordPress，想改别人的主题但是看不懂代码才去学的） 三项功能： 输入视频的网址、BV号获取AV号（AV号明面上已经被b站禁了，但后台实际还在）； 输入视频的网址、BV号、AV号获取视频封面； 输入up主的UID获取该up主所有视频的封面，并打包成zip文件下载。 获取封面1.爬取图片的脚本如何找到b站视频的相关信息和封面图片的源网址呢？ 关于封面图最开始学爬虫的朋友们应该都爬过豆瓣top250这个经典案例。 在body里找到img属性，里面的src就是图片的原链接了。但是要注意到一点，这里图片源文件的后缀：webp。这是一种有损压缩格式图片，优势在于网络传输快，但爬取视频封面是为了什么！是为了高清图啊！所以不能这么爬。 在个人主页中，可以通过选取工具定位到img标签，发现src里的也是webp格式图片 打开链接图片很糊而且像素低。那么问题来了，哪里有高清的呢！答案就在视频界面里。 不在body中！因为视频界面并没有显示封面图片！而是在head中！找到属性（itemprop）为image的，发现content中的链接，后缀为jpg格式，这就找对了，打开发现确实是高清图 链接位置找到了，剩下的就简单了~就不多说了。 关于AV号之前b站因为av号名称违规（？）改为了BV号，但是av号并没有完全删除，在b站中搜索视频av号同样能获取视频，这说明av号这项数据依旧保存着，那如何找出该数据呢？在b站的数据接口。 打开解析器network选项，可以看到该视频数据接口的url。archive（档案）后面的内容aid同理可以替换成bvid 可以看到该网址返回的是一串json数据，里面包含了av、bv、投币、收藏、点赞、分享、评论、观看数、这些数据，在这里便可以获取到AV号了，在就脚本中解析该json数据然后提取就可以显示在网页中了。 而个人空间同样拥有数据接口保存了该页所有视频的标题、简介、bv等信息，也可以获取下来，不再赘述。 2.py脚本与php的数据交互py文件如何向php文件传值？ ajax如何获取php文件的传值？php中如何调用py脚本？ 传值其实很简单，，就是打印函数，python 的print和php 的echo。 调用py脚本，用exec函数： $c &#x3D; exec(&quot;&#x2F;usr&#x2F;bin&#x2F;python GetBilibiliUpCover.py &#123;$func&#125; &#123;$uid&#125; &#123;$bv&#125;&quot;); exec用于执行一个外部程序，主体为执行命令，可以附带参数传递，输出数组和状态返回。因为程序要在服务器里运行，所以输入的就是ubuntu的命令行了，ubuntu怎么运行python脚本就怎么来。 后面的三个是输入参数。在python中通过如下方式获取： sys.argv[1] argv是一个数组，第一位是模块的名称，这里不去管他，从1开始是按序输入的参数，这里输入了三个，就分别用1、2、3来获取就行。 3.前后端数据交互本半吊子表示根本没系统学过前端知识，所以做这一部分的时候异常痛苦，，界面也丑的一言难尽== 用的ajax，但一开始死都进不去succes步，总进error。。 $.ajax(&#123; type : &quot;GET&quot;, url : &quot;getting.php&quot;, data : &#123; &#39;func&#39;:$(&quot;#f1&quot;).val(), &#39;bv&#39;:$(&quot;#av_info&quot;).val() &#125;, dataType : &quot;text&quot;, success : function(msg) &#123; $(&quot;#result&quot;).empty(); document.getElementById(&quot;dynamic_av&quot;).style.display &#x3D; &quot;&quot;; var data &#x3D; &#39;&#39;; if (msg !&#x3D; &#39;&#39;)&#123; data &#x3D; eval(&quot;(&quot;+msg+&quot;)&quot;); &#125; $(&quot;#result_av&quot;).html(&quot;AV号: &quot; + data.av); &#125;, error: function (msg, textStatus) &#123; console.log(msg); &#125; &#125;); 后来发现一开始数据类型用的json，网上说必须要非常标准的json数据才能接收到，我也不明白为什么我在py文件里封装的json数据就不行。。。 后来就改成text，文本用eval转化一下提取出来就解决了。 获取视频文件首先进F12，看一下： 可以看到视频源文件这边并不是mp4的源文件，而是开头带了blob：的链接，是无法访问的（暂时不了解这方面的技术，所以找了个取巧的办法） 点击开发者工具的左上角，切换为手机模拟状态，可以看到： 手机端的src不再是blob了，而是变成了这样一个url，打开即可下载mp4源文件了~舒服！","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.hanhan0223.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"第一次笔记本拆机体验","slug":"第一次笔记本拆机体验","date":"2020-04-13T14:38:42.000Z","updated":"2022-11-07T10:39:23.776Z","comments":true,"path":"杂记/第一次笔记本拆机体验/","link":"","permalink":"https://www.hanhan0223.cn/%E6%9D%82%E8%AE%B0/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8B%86%E6%9C%BA%E4%BD%93%E9%AA%8C/","excerpt":"小的时候总觉得电脑是个很神奇很牛掰的东西，虽然后来对电脑的构成还有运行原理等有了一个大致的了解，但依旧玄乎中带一点敬仰（奇怪的用词）。前段时间给母亲大人配了一台台式，自己亲自买了各种组件，组装起来后才发现其实真没什么难度。。基本是熟练度和经验的关系了。不过这倒是让我对电脑组成和运行有了更深刻的认识~ 恰巧我的笔记本最近也毛病重重（贼卡），于是在我的一位同学祝大师（sdl，wsl）的帮助下，对电脑运行的CPU占用率、硬盘测速、甜甜圈视频输出、内存延时、模具散热、坏道检测等多项数据进行了测试。发现了唯一的问题在于机械盘坏道有点多（跑了1%就有几十柱坏道，神奇，讲道理坏成这样应该经常会卡死，而我只是运行慢一些。。） 然后开始拆机~清灰，然后取出机械硬盘在台式机进行一些测试。","text":"小的时候总觉得电脑是个很神奇很牛掰的东西，虽然后来对电脑的构成还有运行原理等有了一个大致的了解，但依旧玄乎中带一点敬仰（奇怪的用词）。前段时间给母亲大人配了一台台式，自己亲自买了各种组件，组装起来后才发现其实真没什么难度。。基本是熟练度和经验的关系了。不过这倒是让我对电脑组成和运行有了更深刻的认识~ 恰巧我的笔记本最近也毛病重重（贼卡），于是在我的一位同学祝大师（sdl，wsl）的帮助下，对电脑运行的CPU占用率、硬盘测速、甜甜圈视频输出、内存延时、模具散热、坏道检测等多项数据进行了测试。发现了唯一的问题在于机械盘坏道有点多（跑了1%就有几十柱坏道，神奇，讲道理坏成这样应该经常会卡死，而我只是运行慢一些。。） 然后开始拆机~清灰，然后取出机械硬盘在台式机进行一些测试。 拆机简录 首先把四周的螺丝拧开~然后掰开后盖。因为后盖四周带有卡扣固定，所以在掀开的过程中需要拿螺丝刀一点一点的撬开。注意到上图中左右两个网格状的梯形，里面有两坨圆形的灰色，这都是灰，因为这两个网格正对电脑的散热风扇，久而久之在散热过程中就积灰了。 最后掀开，如下： 上图中左右上角是风扇，可以看到积灰很多。风扇上面是散热管，它与风扇之间的缝隙同样是积灰非常严重的地方，需要清理。 中间蓝色是主板，主板上面那块绿色就是内存条，我的是一根8g的（反正也要换硬件，顺便再加个8g内存条？） 右边风扇下面的绿色是固态硬盘（当时配的128g，这次打算换成256g，我c盘就剩12G了，括个容），用作电脑的系统盘存储。 左边风扇下面那块蓝青色板子就是机械硬盘了（配的1T，叠瓦的据说坏的快，在犹豫换1T的机械还是固态，，价格差了五六百，但固态体验要好很多） 机械盘右上角那一小块贴了白色标签的就是无线网卡 右下方那一大块是电池了，图里已经拆了~ 拆下之后对积灰的缝隙，风扇的缝隙进行了清理，顿时感觉舒爽了很多hhhh 问题测试取下机械硬盘，接到我家台式机上，在里面下了个300英雄打了一把人机，发现流畅的一批，，惊了 又接回来进入ubuntu系统，跑了一下pycharm，，还是很流畅 大概是系统问题，，，遇事不决重装系统~ 后续 京东物流是真的快！当晚9点多下单，第二天上午就到了！1TB的SSD硬盘，SATA接口（换机械的），打折799. 然后是数据转移！ 把原来的机械盘和新的固态盘都接到我家台式机上，先格式化好新盘，转gpt分区。我用了DiskGenius的磁盘克隆功能，一键复制分区和数据（大概三个小时左右，我1T基本用满了），然后就搞定啦。 剩下的机械盘格式化了塞家里电脑凑合用着，舒服！ 把固态塞进笔记本，开机，测试了一下软件启动速度，真香！","categories":[{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"},{"name":"硬件","slug":"硬件","permalink":"https://www.hanhan0223.cn/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"PyQt5再尝试:Windows桌面便笺","slug":"PyQt5再尝试-Windows桌面便笺","date":"2020-04-08T14:50:34.000Z","updated":"2022-11-07T10:39:23.702Z","comments":true,"path":"应用/PyQt5再尝试-Windows桌面便笺/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E5%86%8D%E5%B0%9D%E8%AF%95-Windows%E6%A1%8C%E9%9D%A2%E4%BE%BF%E7%AC%BA/","excerpt":"考研党给自己制定了每日计划去执行，但是市面上的桌面便笺软件都不是很合我胃口，于是花了一个礼拜多点，完成了这款完全按照我自己心意来的桌面便笺，用起来相当舒心、顺手嘿嘿。 国际惯例贴上源代码、以及软件下载链接~ GitHub：memo-master 百度网盘：memo 提取码：61uy Version：1.0 【2020.4.8】","text":"考研党给自己制定了每日计划去执行，但是市面上的桌面便笺软件都不是很合我胃口，于是花了一个礼拜多点，完成了这款完全按照我自己心意来的桌面便笺，用起来相当舒心、顺手嘿嘿。 国际惯例贴上源代码、以及软件下载链接~ GitHub：memo-master 百度网盘：memo 提取码：61uy Version：1.0 【2020.4.8】 先上图~ 主图标选择了我非常喜欢的滑稽表情~ 灯泡是用来展开、隐藏下边菜单栏的开关~ 菜单栏分别是新建一个便笺、设置（字体样式，便笺样式等）以及关于（软件的简单使用tips） 右边就是建的一个个便笺了~ 功能简介： 双击可以修改内容（目前无法使用删除键，修改方式为鼠标全选后直接输入文本，待debug） 右边按钮为当日完成情况，初始化为X，点击表示完成√ 删除：拖动单条便笺到主图标滑稽上，松开鼠标即可删除 按~键（ESC下面）即可最小化至托盘 拖动主图标即可拖动整个便笺软件移动 对便笺样式以及内容的修改信息均会保存，在下次启动时直接调用~ 主图标以及各种按钮的图标均可找自己喜欢的图片修改（要求：png图片、背景透明（怎么弄透明百度有教程，可网站上在线生成也可ps自己弄）、将处理好的图片与想改的图标做替换（文件名要相同）） 因为在x64系统下封装，仅适用于x64系统，linux和Windows x32目前不支持~ 关于里面的介绍是之前写的，忘改了，，下版再说吧，懒得重新改 对于下版的一些想法： 1.优化UI、以及界面控制，修复一些按键bug 2.添加时间数据，记录计划的创建、删除时间以及每天完成情况；每日0：00更新所有便笺状态为X 3.添加数据分析功能，生成统计文件。哦甚至一键生成统计图表（？这个好像有点麻烦，，得慢慢来） 4.添加一键换图标功能（仅需上传png图片） 5.想和网站做点联动，但不知道做啥==下版见 就酱~ Version：1.1 【2020.4.24】1.1版本搞定！ 1.优化了设置和关于界面的UI 2.添加了主图标右键可以打开菜单栏操作功能 3.新增部分设置选项（置顶功能设置、勾选重启以创建桌面快捷方式、边缘自动隐藏功能） 4.完善了每个便笺个体的信息保存，软件在下一天启动时所有便笺状态归于未完成 5.删除了任务栏图标，只保留托盘图标了 6.更新了数据统计功能，从整体和个体角度分析完成情况 7.新增简单的一键换肤功能（不提倡，建议ps手动修图手动在img文件夹下替换） 8.关于与个人网站的联动，会做一个内测版本，将我每日的学习进度展示在我的个人网站上~暂时不打算封装起来 这个小项目就告一段落了~~ 接下来的安排基本以考研为主了，以算法题为主要练习对象，偶尔有需求再写点脚本什么的~ Version：1.2 【2020.6.6】1.新增了倒计时功能，置于电脑屏幕正上方，右键为设置（内容和结束时间）、隐藏。隐藏后可在菜单栏打开。 2.新增了版本检测以及自动更新功能（有一点小bug没解决，点更新会跳cmd框并且更新时鼠标操作其他地方进度条的显示会卡死，但是不影响更新的）。更新后再次点击图标重启（重启才会删除旧版本，我没封装成正式软件，也没解决父子进程独立的问题，用的更新方法比较简单~） 3.修复了个别显示以及数据统计的小bug~ 唔，越来越感觉这软件粗制滥造了hhhh，等我有空研究一下软件构造方面的知识之后再重构一遍~ Version：2.0【2022.1.9】没想到，这小玩意儿最后居然被我拿来当毕设了。。就挺水的== 当时为了凑毕设字数就重构了一遍代码（UI与逻辑分离之类的），但是时间比较紧，也没重构完。。所以也就没更新 现在把博客从云服务器迁到github上，才想起来这回事儿。。有空搞搞？（十有八九是没下文了）","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"}]},{"title":"PyQt5初尝试:Unicode转换器","slug":"PyQt5初尝试-Unicode转换器","date":"2020-03-07T14:46:57.000Z","updated":"2022-11-07T10:39:23.705Z","comments":true,"path":"应用/PyQt5初尝试-Unicode转换器/","link":"","permalink":"https://www.hanhan0223.cn/%E5%BA%94%E7%94%A8/PyQt5%E5%88%9D%E5%B0%9D%E8%AF%95-Unicode%E8%BD%AC%E6%8D%A2%E5%99%A8/","excerpt":"Unicode转换器Version 1.1.0 【2020.3.7】最近玩阴阳师的时候接触到一位大哥写的御魂hub网站，里面通过对json文件的解析来实现了大量御魂配置的计算，省去了手动配置的无限痛苦！！！超级好用！！！ ❤❤❤ 另外有个软件可以从阴阳师桌面版中提取出账号中所有的御魂信息并集合成一个json文件，恰巧最近几天尝试了简单的python爬虫，在爬取动态信息时同样涉及到了json~~这让我对json产生了兴趣。于是今天下午尝试着解析Unicode为字符串，集成在小软件里。","text":"Unicode转换器Version 1.1.0 【2020.3.7】最近玩阴阳师的时候接触到一位大哥写的御魂hub网站，里面通过对json文件的解析来实现了大量御魂配置的计算，省去了手动配置的无限痛苦！！！超级好用！！！ ❤❤❤ 另外有个软件可以从阴阳师桌面版中提取出账号中所有的御魂信息并集合成一个json文件，恰巧最近几天尝试了简单的python爬虫，在爬取动态信息时同样涉及到了json~~这让我对json产生了兴趣。于是今天下午尝试着解析Unicode为字符串，集成在小软件里。 python也只是刚入门，所以目前只实现了这一点点小功能。效果图如下👇 源代码我上传到GitHub了非常简单的两个小文件 戳这里去star吧👇https://github.com/shen962806862/Unicode-Chinese 另外我也生成了单独的exe文件，可以直接使用 👇https://pan.baidu.com/s/1G1BLW82elUwAee7DSpzQqA 提取码：9qfw 接下来会有2.0版本，打算尝试实现txt文件与json文件的相互转换√ Version 2.0.0 【2020.3.8】弄了一晚上！更新更新！船新版本！ 新增功能： 1.实现了Json文件与txt文件的相互转换，可以快速阅读json文件中的信息了 2.当你添加一个文件后，打开添加文件夹选项，可以自动锁定到输入文件的地址了 2.5.转换生成的文件名与输入文件相同 3.优化了UI界面，实现了窗口自适应 4.优化了数据窗口，滚动条可以自动滑至文本末了 源码和软件链接依旧同上，里面存了所有更新版本的内容~ 大致搞定了第一个python制作小软件了接下来的话打算抽空做一个桌面便笺了敬请期待","categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"}]}],"categories":[{"name":"应用","slug":"应用","permalink":"https://www.hanhan0223.cn/categories/%E5%BA%94%E7%94%A8/"},{"name":"原理","slug":"原理","permalink":"https://www.hanhan0223.cn/categories/%E5%8E%9F%E7%90%86/"},{"name":"杂记","slug":"杂记","permalink":"https://www.hanhan0223.cn/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://www.hanhan0223.cn/tags/CPP/"},{"name":"服务器","slug":"服务器","permalink":"https://www.hanhan0223.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"算法","slug":"算法","permalink":"https://www.hanhan0223.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"https://www.hanhan0223.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"https://www.hanhan0223.cn/tags/javascript/"},{"name":"电子","slug":"电子","permalink":"https://www.hanhan0223.cn/tags/%E7%94%B5%E5%AD%90/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.hanhan0223.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://www.hanhan0223.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"opencv","slug":"opencv","permalink":"https://www.hanhan0223.cn/tags/opencv/"},{"name":"图像","slug":"图像","permalink":"https://www.hanhan0223.cn/tags/%E5%9B%BE%E5%83%8F/"},{"name":"环境","slug":"环境","permalink":"https://www.hanhan0223.cn/tags/%E7%8E%AF%E5%A2%83/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://www.hanhan0223.cn/tags/PyQt5/"},{"name":"小软件","slug":"小软件","permalink":"https://www.hanhan0223.cn/tags/%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"name":"脚本","slug":"脚本","permalink":"https://www.hanhan0223.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"加密与编码","slug":"加密与编码","permalink":"https://www.hanhan0223.cn/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%BC%96%E7%A0%81/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.hanhan0223.cn/tags/python%E7%88%AC%E8%99%AB/"},{"name":"硬件","slug":"硬件","permalink":"https://www.hanhan0223.cn/tags/%E7%A1%AC%E4%BB%B6/"}]}