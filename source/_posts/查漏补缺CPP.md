---
title: 查漏补缺CPP
date: 2023-06-20 16:08:36
categories: 原理
tags: 
- CPP
---

# C++11

## 右值引用

### 左值/右值

左值**可以取地址、位于等号左边**；而右值**没法取地址，位于等号右边**。

```cpp
int a = 5;
```

- a可以通过 & 取地址，位于等号左边，所以a是左值。
- 5位于等号右边，5没法通过 & 取地址，所以5是个右值。

**有地址的变量就是左值，没有地址的字面值、临时值就是右值。**

#### 左值引用

**能指向左值，不能指向右值的就是左值引用**。引用是变量的别名，由于**右值没有地址，没法被修改**，所以左值引用无法指向右值。

```cpp
int a = 5;
int &ref_a = a; // 左值引用指向左值，编译通过
int &ref_a = 5; // 左值引用指向了右值，会编译失败
```

**特例：**

**const**左值引用是可以指向右值的：

```cpp
const int &ref_a = 5;  // 编译通过
```

const左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用`const &`作为函数参数的原因之一，如`std::vector`的`push_back`：

```cpp
void push_back (const value_type& val);
```

#### 右值引用

右值引用的标志是`&&`，顾名思义，右值引用专门为右值而生，**可以指向右值，不能指向左值**：

```cpp
int &&ref_a_right = 5; 	// ok
int a = 5;
int &&ref_a_left = a; 	// 编译不过，右值引用不可以指向左值
 
ref_a_right = 6; 		// 右值引用的用途：可以修改右值
```



#### 引用本身的性质

**被声明出来的左、右值引用都是左值**。 因为被声明出的左右值引用是有地址的，也位于等号左边。

```cpp
void change(int&& right_value) {		// 形参是个右值引用
    right_value = 8;
}
int main() {
    int a = 5; 							// a是个左值
    int &ref_a_left = a; 				// ref_a_left是个左值引用
    int &&ref_a_right = std::move(a); 	// ref_a_right是个右值引用
 
    change(a); 							// 编译不过，a是左值，change参数要求右值
    change(ref_a_left); 				// 编译不过，左值引用ref_a_left本身也是个左值
    change(ref_a_right); 				// 编译不过，右值引用ref_a_right本身也是个左值
     
    change(std::move(a)); 				// 编译通过
    change(std::move(ref_a_right)); 	// 编译通过
    change(std::move(ref_a_left)); 		// 编译通过
    change(5); 							// 当然可以直接接右值，编译通过
     
    cout << &a << ' ';
    cout << &ref_a_left << ' ';
    cout << &ref_a_right;				// 打印这三个左值的地址，都是一样的
}
```

**右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值**。

<font color="red">**作为函数返回值的 && 是右值，直接声明出来的 && 是左值**。</font> 这同样符合对左值，右值的判定方式：其实引用和普通变量是一样的，`int &&ref = std::move(a)`和 `int a = 5`没有什么区别，等号左边就是左值，右边就是右值。

综上可得以下概念：

1. **从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。**
2. **右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。**
3. **作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。**



### std::move

```cpp
int a = 5; 				// a是个左值
int &ref_a_left = a; 	// 左值引用指向左值
int &&ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向
cout << a; 				// 打印结果：5
```

该函数本质上等同于一个类型转换：**把左值强制转化为右值**，让右值引用可以指向左值。**单纯的std::move()不会有性能提升。**

#### 实现移动语义

实际场景中，右值引用和std::move被广泛用于STL和自定义类中**实现移动语义，避免拷贝，从而提升程序性能**。 

```cpp
class Array {
public:
    ......
    // 深拷贝构造
    Array(const Array& temp_array) {
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
    // 移动构造
    Array(Array&& temp_array) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 为防止temp_array析构时delete data，提前置空其data_      
        temp_array.data_ = nullptr;
    }    
public:
    int *data_;
    int size_;
};
int main(){
    Array a;
    Array b(std::move(a));
}
```

加个`std::move`会调用到移动语义函数，**避免了深拷贝，这就是提高性能的原理**。

编译器会**默认**在用户自定义的`class`和`struct`中生成移动语义函数，但前提是用户没有主动定义该类的*拷贝构造*等函数。 因此，可移动对象在<**需要拷贝且被拷贝者之后不再被需要**>的场景，建议使用**`std::move`**触发移动语义，提升性能。

还有些STL类是`move-only`的，比如`unique_ptr`，这种类只有移动构造函数，因此只能移动(**转移内部对象所有权**，或者叫浅拷贝)，不能拷贝(深拷贝)。



## 关键字

### using

#### 导入命名空间

使用C++在写不同的功能模块时，为了防止命名冲突，建议对模块取命名空间，这样在使用时就需要指定是哪个命名空间。

使用 using 导入命名空间，即使一个命名空间中的所有名字都在该作用域中可见，常见的如下：

```cpp
// 导入整个命名空间到当前作用域
using namespace std;
// 只导入某个变量到当前作用域 
using std::cout; 
```

**在.h头文件中，一般不应该使用using声明。**

因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，从而可能产生名字冲突。



#### 指定别名

C++ 11 通过 using 指定别名，作用等同于 typedef，但相比 typedef，逻辑更直观，可读性更好。

```cpp
typedef int T; // 用 T 代替 int
using T = int; // 用 T 代替 int
```



#### 在派生类中引用基类成员

<img src="%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BACPP/v2-c8efe8b7be239e2a01c2089b7bb64880_720w.webp" alt="img" style="zoom: 80%;" />

如上图代码所示，尽管派生类 Derived 对 基类 Base 是**私有继承**，但通过 using 声明，派生类的对象就可以访问基类的 proteced 成员变量和 public 成员函数了。

**注意：using只是引用，不参与形参的指定。**



### operator

[operator](https://www.cnblogs.com/ZY-Dream/p/10068993.html)



### const

#### 指针和引用

关于`int * const `与`const int * `的区别，其实只用记住，**const先修饰左边，左边没有就修饰右边**。

`int * const`，const修饰的是指针，指针不能指向其他地址，但是指针所指向地址上保存的变量可以修改；

`const int *` ，const左边没有，所以修饰右边的int，指针指向的变量不能修改，但是指针可以指向别的变量。



#### 成员函数

在类成员函数中，使用`const`关键字表示该成员函数不会修改类的任何非静态成员变量（除非它们被声明为`mutable`）。这样的成员函数被称为常量成员函数。



### static

`static`关键字的一些主要用途：

- **隐藏**：当`static`用于全局变量或函数时，它改变了变量或函数的可见性。静态的全局变量或函数仅在定义它们的源文件中可见，不会在其他源文件中产生链接冲突。这可以用来实现模块内的封装。
- **保持变量持久且唯一**：当`static`用于局部变量时，它将变量的生命周期延长到整个程序执行期间。这意味着静态的局部变量在第一次执行包含它的函数时初始化，然后在程序的整个生命周期内保持其值。即使函数多次调用，静态的局部变量的值也会在调用之间保持不变。
- **静态类成员变量**：当`static`用于类成员变量时，该成员变量被所有该类的对象共享。也就是说，类的所有实例都将访问同一个静态成员变量，而不是为每个实例分配独立的存储空间。
- **静态类成员函数**：当`static`用于类成员函数时，这个函数可以在不创建类的实例的情况下直接通过类名调用。静态成员函数没有`this`指针，因此它只能访问类的静态成员变量。

静态变量的初始化时机c与c++不同：

- 静态变量只会初始化一次，静态变量放在全局区域，所以在主程之前就会为其分配内存。
- 对于c而言，c是在代码执行前，编译阶段分配好内存后，进行初始化。
- 对于c++而言，它是在执行相关代码时被初始化。



## 函数

### 匿名函数

C++11提供了对匿名函数的支持,称为**Lambda函数**(也叫**Lambda表达式**)。

它是定义和使用匿名函数对象的一种简便的方式。匿名函数是我们需要用到的一个函数，但是又不想去费力命名一个函数的场景。我们无需为每个值或者每种类型)单独编写函数，更不必把值保存在让人厌倦的全局变量中 。 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。

#### 结构

1. 一个可能为空的捕获列表，指明定义环境中的那些名字能被用在lambda表达式内，以及这些名字的访问形式拷贝还是引用，捕获列表位于 [] 内。

2. 一个可选的参数列表，指明lambda表达式所需的参数，参数列表位于 () 内。

3. 一个可以选的mutable修饰符，指明该lambda表达式可能会修改它自身的状态（即，改变通过值捕获的变量的副本）

4. 一个可选的 -> 形式的返回类型声明  

5. 一个表达式体，指明要执行的代码，表达式位于 {} 内。

```cpp
[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {
// 函数体
}
```

#### 参数分析

**1.捕获列表**

|  参数   |                      效果                       |
| :-----: | :---------------------------------------------: |
|   []    |          默认不能使用所在函数中的变量           |
|   [=]   |              默认以值捕获所有变量               |
|   [&]   |             默认以引用捕获所有变量              |
|   [x]   |           仅以值捕获x，其它变量不捕获           |
|  [&x]   |          仅以引用捕获x，其它变量不捕获          |
| [=,&x]  | 默认以值捕获所有变量，但是x是例外，通过引用捕获 |
|  [&,x]  | 默认以引用捕获所有变量，但是x是例外，通过值捕获 |
| [this]  |     通过引用捕获当前对象（其实是复制指针）      |
| [*this] |            通过传值方式捕获当前对象             |



**2.捕获使用分析**

**值捕获**

与参数传值类似，值捕获的前提是**变量可以拷贝**，不同之处则在于，被捕获的变量在 lambda 表达式被**创建时拷贝**， 而非调用时才拷贝。

```cpp
void value_capture() {
    int value = 1;
    auto copy_value = [value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    cout << stored_value << endl;
}
```

如上代码中， `value == 100` 而 `stored_value == 1`。

**引用捕获**

与引用传参类似，引用捕获保存的是引用，值会发生变化。

`auto copy_value = [&value] {}`

上述代码中，改为引用捕获后，两个值均为100。



**3.返回值**

- 一般情况下，编译器会自动推断出lambda的返回类型。
- 但是如果函数体里面有多个返回语句，甚至有一些常量return返回时候，编译器无法自动推断其返回类型，这个时候我们需要指定其返回类型。



#### c++14

**1.捕获时计算**

```cpp
int x = 3, y = 5;
auto lam = [z = x + y]() { return z; }
int z = lam();
```

在多次调用该函数时，可以直接从构造对象中读取 z，而非每次都计算一次 x + y 。



**2.即调用函数表达式**

```cpp
int x = 3, y = 5;
const int val = [z = x + y]() { 
    return z; 
}();
```

当初始化常量的过程较为复杂的时候，可以将初始化逻辑放入Lambda表达式中。



**3.递归调用**

```cpp
int main() {
	auto factorial = [
        f_impl = [](int n ,auto&& impl)->int	{
            return n > 1 ? n * impl(n-1,impl) : 1;
        }](int n){ 
        return f_impl(n,f_impl);
    };
}
```

注意在递归时，需要**显式给出匿名函数的返回值**（即 **f_impl** 会返回的值）

编译器并不需要知道factorial、f_impl的类型，故使用auto不会出现无法确定factorial、f_impl的返回类型这种trick。并且将 **f_impl** 置于 **Capture** 中，仅在初始化 **factorial** 时初始化一次  **f_impl** ，而不用多次初始化。



# STL

## STL容器大纲

### 底层实现

|        容器        |   底层数据结构    |                        时间复杂度                         | 有无序 | 可不可重复 | 其他                                                         |
| :----------------: | :---------------: | :-------------------------------------------------------: | ------ | ---------- | ------------------------------------------------------------ |
|       array        |       数组        |                       随机读改 O(1)                       | 无序   | 可重复     | 支持随机访问                                                 |
|       vector       |       数组        | 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) | 无序   | 可重复     | 支持随机访问                                                 |
|       deque        |     双端队列      |                  头尾插入、头尾删除 O(1)                  | 无序   | 可重复     | 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问  |
|    forward_list    |     单向链表      |                      插入、删除 O(1)                      | 无序   | 可重复     | 不支持随机访问                                               |
|        list        |     双向链表      |                      插入、删除 O(1)                      | 无序   | 可重复     | 不支持随机访问                                               |
|       stack        |   deque / list    |                  顶部插入、顶部删除 O(1)                  | 无序   | 可重复     | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
|       queue        |   deque / list    |                  尾部插入、头部删除 O(1)                  | 无序   | 可重复     | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
|   priority_queue   | vector + max-heap |                    插入、删除 O(log2n)                    | 有序   | 可重复     | vector容器+heap处理规则                                      |
|        set         |      红黑树       |                 插入、删除、查找 O(log2n)                 | 有序   | 不可重复   |                                                              |
|      multiset      |      红黑树       |                 插入、删除、查找 O(log2n)                 | 有序   | 可重复     |                                                              |
|        map         |      红黑树       |                 插入、删除、查找 O(log2n)                 | 有序   | 不可重复   |                                                              |
|      multimap      |      红黑树       |                 插入、删除、查找 O(log2n)                 | 有序   | 可重复     |                                                              |
|   unordered_set    |      哈希表       |              插入、删除、查找 O(1) 最差 O(n)              | 无序   | 不可重复   |                                                              |
| unordered_multiset |      哈希表       |              插入、删除、查找 O(1) 最差 O(n)              | 无序   | 可重复     |                                                              |
|   unordered_map    |      哈希表       |              插入、删除、查找 O(1) 最差 O(n)              | 无序   | 不可重复   |                                                              |
| unordered_multimap |      哈希表       |              插入、删除、查找 O(1) 最差 O(n)              | 无序   | 可重复     |                                                              |



### 迭代器

- **random_access_iterator**（随机访问迭代器，可通过偏移量直接访问(如 **it + 5**) )

1. **array** 由于数组是连续空间，可以根据头指针偏移量来直接寻址
2. **vector** 动态数组容器由于是连续空间，类似数组，所以也可以根据头指针偏移量来直接寻址
3. **deque** 双向队列的内部实现其实是通过多个连续空间拼接而成的，所以也可以直接寻址



- **bidirectional_iterator**（双向迭代器，可以通过 **++**、 **--** 操作访问前后元素 ）

1. **list** 列表的内部实现是双向链表，不是连续空间，因此只能使用指针逐一迭代间接寻址
2. 底层实现为**红黑树**的，集合 **set / multiset** 和表 **map / multimap**

红黑树结构如下：

```cpp
struct __rb_tree_node_base {
	typedef __rb_tree_color_type color_type;
	typedef __rb_tree_node_base* base_ptr;
	color_type color;
	base_ptr parent;
	base_ptr left;
	base_ptr right;
}
```



- **forward_iterator**（单向迭代器，可以通过**++**访问下一元素 ）

1. 底层实现为**哈希表**的，无序集合 **unordered_set / unordered_multiset** 和无序表 **unordered_map / unordered_multimap**
2. **forward_list** 单向列表的内部实现为单向链表，只支持单向迭代

哈希表结构如下：

```cpp
template <class Value>
struct __hashtable_node {
	__hashtable_node* next;
	Value val;
}
```



- **input_iterator**（输入迭代器）
- **output_iterator**（输出迭代器）

以上两种应用较少，常用于指向**流**，来读取流中的数据或向流中写入数据（若ostream_iterator（属于**output_iterator**）指向cout，那么即可向cout这个ostream写值，实现输出的效果）



**效率： random_access_iterator > bidirectional_iterator > forward_iterator**

**继承关系：input_iterator** → **forward_iterator** → **bidirectional_iterator** → **random_access_iterator**

但**output_iterator**和上述没有继承关系



## set

`set`和`unordered_set`都有**只读**键。如果键值发生变化，数据结构会将其归档到错误的位置，您将无法再找到它。因此无论是**for循环或迭代器遍历，返回的都是常量值，无法修改**。



# C++

## 提高速度

### 运算

**减少除法运算**

无论是整数还是浮点数的运算，除法都会比较耗时，所以最后将除法运算等效成乘法运算。例如：a/b>20可改为a>b*20，可以简化程序的运行时间。

**多用++、--、+=、-=**

通常使用自加、自减指令和复合赋值表达式(如a-=1及a+=1等)能生成高质量的程序代码，编译器通常都能够生成inc和dec之类的指令，而使用a=a+1或a=a-1之类的指令，有很多C编译器都会生成二到三个字节的指令。



### 变量&参数

**减少值传递，多用引用来传递参数**

```cpp
bool Compare（string s1, string s2)
bool Compare(string *s1, string *s2)
bool Compare(string &s1, string &s2)
bool Compare(const string &s1, const string &s2)
```

其中若使用第一个函数（值传递），则在参数传递和函数返回时，需要调用string的构造函数和析构函数两次（即共多调用了四个函数），而其他的三个函数（指针传递和引用传递）则不需要调用这四个函数。因为指针和引用都不会创建新的对象。如果一个构造一个对象和析构一个对象的开销是庞大的，这就是会效率造成一定的影响。

然而在很多人的眼中，指针是一个恶梦，使用指针就意味着错误，那么就使用引用吧！它与使用普通值传递一样方便直观，同时具有指针传递的高效和能力。因为引用是一个变量的别名，对其操作等同于对实际对象操作，所以当你确定在你的函数是不会或不需要变量参数的值时，就大胆地在声明的前面加上一个const吧，就如最后的一个函数声明一样。同时加上一个const还有一个好处，就是可以对常量进行引用，若不加上const修饰符，引用是不能引用常量的。

**多用局部变量，少用静态变量**

使用局部变量的效率比使用静态变量要高。

局部变量是存在于堆栈中的，对其空间的分配仅仅是修改一次esp寄存器的内容即可（即使定义一组局部变量也是修改一次）。而局部变量存在于堆栈中最大的好处是，函数能重复使用内存，当一个函数调用完毕时，退出程序堆栈，内存空间被回收，当新的函数被调用时，局部变量又可以重新使用相同的地址。当一块数据被反复读写，其数据会留在CPU的一级缓存（Cache）中，访问速度非常快。而静态变量却不存在于堆栈中。

**多用直接初始化**

```cpp
ClassTest ct1;
ClassTest ct2(ct1);  //直接初始化
ClassTest ct3 = ct1;  //复制初始化
```

当用于类类型对象时，初始化的复制形式和直接形式有所不同：**直接初始化**直接调用与实参匹配的构造函数，**复制初始化**总是调用复制构造函数。复制初始化首先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象”。

通常直接初始化和复制初始化仅在低级别优化上存在差异，然而，对于不支持复制的类型，或者使用非explicit构造函数的时候，它们有本质区别。

```cpp
ifstream file1("filename")://ok:direct initialization
ifstream file2 = "filename";//error:copy constructor is private
```



## 类

1. 成员变量初始化的顺序为：先进行声明时初始化，然后进行初始化列表初始化，最后进行构造函数初始化。（另外初始化列表中初始化的顺序是和变量声明的顺序一样，而与列表中的顺序无关）
