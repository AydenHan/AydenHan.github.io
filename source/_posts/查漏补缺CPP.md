---
title: 查漏补缺CPP
date: 2023-06-20 16:08:36
categories: 原理
tags: 
- CPP
---

# C++11

## 函数 - TODO

### 匿名函数

C++11提供了对匿名函数的支持,称为**Lambda函数**(也叫**Lambda表达式**)。

它是定义和使用匿名函数对象的一种简便的方式。匿名函数是我们需要用到的一个函数，但是又不想去费力命名一个函数的场景。我们无需为每个值或者每种类型)单独编写函数，更不必把值保存在让人厌倦的全局变量中 。 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。

#### 结构

1. 一个可能为空的捕获列表，指明定义环境中的那些名字能被用在lambda表达式内，以及这些名字的访问形式拷贝还是引用，捕获列表位于 [] 内。

2. 一个可选的参数列表，指明lambda表达式所需的参数，参数列表位于 () 内。

3. 一个可以选的mutable修饰符，指明该lambda表达式可能会修改它自身的状态（即，改变通过值捕获的变量的副本）

4. 一个可选的 -> 形式的返回类型声明  

5. 一个表达式体，指明要执行的代码，表达式位于 {} 内。

```cpp
[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {
// 函数体
}
```

#### 参数分析

**1.捕获列表**

|  参数   |                      效果                       |
| :-----: | :---------------------------------------------: |
|   []    |          默认不能使用所在函数中的变量           |
|   [=]   |              默认以值捕获所有变量               |
|   [&]   |             默认以引用捕获所有变量              |
|   [x]   |           仅以值捕获x，其它变量不捕获           |
|  [&x]   |          仅以引用捕获x，其它变量不捕获          |
| [=,&x]  | 默认以值捕获所有变量，但是x是例外，通过引用捕获 |
|  [&,x]  | 默认以引用捕获所有变量，但是x是例外，通过值捕获 |
| [this]  |     通过引用捕获当前对象（其实是复制指针）      |
| [*this] |            通过传值方式捕获当前对象             |



**2.捕获使用分析**

**值捕获**

与参数传值类似，值捕获的前提是**变量可以拷贝**，不同之处则在于，被捕获的变量在 lambda 表达式被**创建时拷贝**， 而非调用时才拷贝。

```cpp
void value_capture() {
    int value = 1;
    auto copy_value = [value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    cout << stored_value << endl;
}
```

如上代码中， `value == 100` 而 `stored_value == 1`。

**引用捕获**

与引用传参类似，引用捕获保存的是引用，值会发生变化。

`auto copy_value = [&value] {}`

上述代码中，改为引用捕获后，两个值均为100。



**3.返回值**

- 一般情况下，编译器会自动推断出lambda的返回类型。
- 但是如果函数体里面有多个返回语句，甚至有一些常量return返回时候，编译器无法自动推断其返回类型，这个时候我们需要指定其返回类型。



#### c++14

**1.捕获时计算**

```cpp
int x = 3, y = 5;
auto lam = [z = x + y]() { return z; }
int z = lam();
```

在多次调用该函数时，可以直接从构造对象中读取 z，而非每次都计算一次 x + y 。



**2.即调用函数表达式**

```cpp
int x = 3, y = 5;
const int val = [z = x + y]() { 
    return z; 
}();
```

当初始化常量的过程较为复杂的时候，可以将初始化逻辑放入Lambda表达式中。



**3.递归调用**

```cpp
int main() {
	auto factorial = [
        f_impl = [](int n ,auto&& impl)->int	{
            return n > 1 ? n * impl(n-1,impl) : 1;
        }](int n){ 
        return f_impl(n,f_impl);
    };
}
```

注意在递归时，需要**显式给出匿名函数的返回值**（即 **f_impl** 会返回的值）

编译器并不需要知道factorial、f_impl的类型，故使用auto不会出现无法确定factorial、f_impl的返回类型这种trick。并且将 **f_impl** 置于 **Capture** 中，仅在初始化 **factorial** 时初始化一次  **f_impl** ，而不用多次初始化。
