<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>LeetCode--2023Q2 | 小涵的米奇妙妙屋</title><meta name="keywords" content="算法,CPP"><meta name="author" content="Szh"><meta name="copyright" content="Szh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="打卡4月LeetCode2023.4.1831.隐藏个人信息解法基本思路：模拟？ 这也算算法题。。吗？ 代码class Solution &amp;#123; public:     string maskPII(string s) &amp;#123;         if(s[0] &gt;&#x3D; &#39;A&#39;)&amp;#123;             int split &#x3D; s.fin">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode--2023Q2">
<meta property="og:url" content="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/index.html">
<meta property="og:site_name" content="小涵的米奇妙妙屋">
<meta property="og:description" content="打卡4月LeetCode2023.4.1831.隐藏个人信息解法基本思路：模拟？ 这也算算法题。。吗？ 代码class Solution &amp;#123; public:     string maskPII(string s) &amp;#123;         if(s[0] &gt;&#x3D; &#39;A&#39;)&amp;#123;             int split &#x3D; s.fin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/5.jpg">
<meta property="article:published_time" content="2023-04-01T02:32:55.000Z">
<meta property="article:modified_time" content="2023-06-30T09:16:07.908Z">
<meta property="article:author" content="Szh">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/5.jpg"><link rel="shortcut icon" href="/img/Sign.ico"><link rel="canonical" href="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a8ed5b37dd0aaae924c52eb382109c5d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode--2023Q2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-30 17:16:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 脚本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/scripts/genshin/"><i class="fa-fw fas fa-gamepad"></i><span> 我焯!原!</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小涵的米奇妙妙屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 脚本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/scripts/genshin/"><i class="fa-fw fas fa-gamepad"></i><span> 我焯!原!</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode--2023Q2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-01T02:32:55.000Z" title="发表于 2023-04-01 10:32:55">2023-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-30T09:16:07.908Z" title="更新于 2023-06-30 17:16:07">2023-06-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8E%9F%E7%90%86/">原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.9k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode--2023Q2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="打卡4月LeetCode"><a href="#打卡4月LeetCode" class="headerlink" title="打卡4月LeetCode"></a>打卡4月LeetCode</h1><h2 id="2023-4-1"><a href="#2023-4-1" class="headerlink" title="2023.4.1"></a>2023.4.1</h2><h3 id="831-隐藏个人信息"><a href="#831-隐藏个人信息" class="headerlink" title="831.隐藏个人信息"></a>831.隐藏个人信息</h3><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟？</strong></p>
<p>这也算算法题。。吗？</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string maskPII(string s) &#123;
        if(s[0] &gt;&#x3D; &#39;A&#39;)&#123;
            int split &#x3D; s.find(&#39;@&#39;);
            for(int i &#x3D; split + 1; i &lt; s.length(); ++i)&#123;
                if(s[i] &lt;&#x3D; &#39;Z&#39; &amp;&amp; s[i] &gt;&#x3D; &#39;A&#39;)
                    s[i] +&#x3D; 32;
            &#125;
            if(s[0] &lt;&#x3D; &#39;Z&#39;) s[0] +&#x3D; 32;
            if(s[split - 1] &lt;&#x3D; &#39;Z&#39;) s[split - 1] +&#x3D; 32;
            s.replace(1, split - 2, &quot;*****&quot;);
        &#125;
        else&#123;
            for(string::iterator i &#x3D; s.begin(); i &lt; s.end(); ++i)&#123;
                if(*i &lt; &#39;0&#39;)
                    s.erase(i--);
            &#125;
            int len &#x3D; s.length();
            if(len &#x3D;&#x3D; 10)
                return &quot;***-***-&quot; + s.substr(6, 4);
            else if(len &#x3D;&#x3D; 11)
                return &quot;+*-***-***-&quot; + s.substr(7, 4);
            else if(len &#x3D;&#x3D; 12)
                return &quot;+**-***-***-&quot; + s.substr(8, 4);
            else if(len &#x3D;&#x3D; 13)
                return &quot;+***-***-***-&quot; + s.substr(9, 4);
        &#125;
        return s;
    &#125;
&#125;;</code></pre>



<h3 id="54-螺旋矩阵、剑指-Offer-29-顺时针打印矩阵"><a href="#54-螺旋矩阵、剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="54.螺旋矩阵、剑指 Offer 29. 顺时针打印矩阵"></a>54.螺旋矩阵、剑指 Offer 29. 顺时针打印矩阵</h3><h4 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre>

<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟过程</strong></p>
<p>相比于 59.螺旋矩阵Ⅱ ，这题的长宽不一定相同，因此不再适用按圈缩减的方法。</p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/spiral.jpg" alt="img"></p>
<ol>
<li>维护上、下、左、右四个边界的下标。</li>
<li>第一次移动，从左到右移动一整行，移动后直接将1~4从上图中抹掉，变成了一个 4 x 2 的矩阵。如何抹掉？<strong>维护的上边界加一</strong>即可。因为<strong>循环都是统一从一个边界到另一个边界的</strong>。</li>
<li>第二次移动，从上到下，移动后抹去8、12，相当于<strong>右边界减一</strong>。这样下一次移动中从右到左时从右边界开始就是从11开始的，顺序不会错乱。</li>
<li>第三从右往左，第四次从下往上，四次组成一次大循环。</li>
<li>每当有两个对应边界错位（<strong>左 &gt; 右，上 &gt; 下</strong>）时，就直接结束了。例如当仅剩一行时，上下边界重合，抹去这行时，无论up++还是down–，都会出现错位，以此为结束的判断依据。</li>
</ol>
<p>思路清晰，逻辑明了。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        vector&lt;int&gt; res;
        int up &#x3D; 0, left &#x3D; 0;
        int down &#x3D; matrix.size() - 1, right &#x3D; matrix[0].size() - 1;
        while(1)&#123;
            for(int i &#x3D; left; i &lt;&#x3D; right; ++i) res.push_back(matrix[up][i]);
            if(++up &gt; down) break;
            for(int i &#x3D; up; i &lt;&#x3D; down; ++i) res.push_back(matrix[i][right]);
            if(--right &lt; left) break;
            for(int i &#x3D; right; i &gt;&#x3D; left; --i) res.push_back(matrix[down][i]);
            if(--down &lt; up) break;
            for(int i &#x3D; down; i &gt;&#x3D; up; --i) res.push_back(matrix[i][left]);
            if(++left &gt; right) break;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h3><h4 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h4><p>给定一个长度为 <strong>n</strong> 的整数数组 <strong>height</strong> 。有 n 条垂线，第 <strong>i</strong> 条线的两个端点是 <strong>(i, 0)</strong> 和 <strong>(i, height[i])</strong> 。</p>
<p>找出其中的两条线，使得它们与 <strong>x</strong> 轴共同构成的容器可以容纳<strong>最多</strong>的水。返回容器可以储存的<strong>最大水量</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：[1,8,6,2,5,4,8,3,7]
输出：49 </code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：height &#x3D; [1,1]
输出：1</code></pre>

<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>代码很简单，这题主要在于思路上：为什么双指针按代码所示方法往中间移动时不会漏掉某种情况呢？</p>
<p>容量和两个因素有关：双指针的<strong>距离</strong>、双指针中<strong>短的那个的高度</strong>。</p>
<p>开始双指针在两端，距离是最大的，此时移动指针若想要让容量更大，就必须提高双指针中<strong>短的那个的高度</strong>，也就是把短的指针往中间移动找找有没有更高的位置。这样移动下来就不存在漏掉某种最大的情况了。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int maxArea(vector&lt;int&gt;&amp; height) &#123;
        int n &#x3D; height.size()， res &#x3D; 0;
        int l &#x3D; 0, r &#x3D; n - 1;
        while(l &lt; r)&#123;
            int area &#x3D; min(height[l], height[r]) * (r - l);
            res &#x3D; max(res, area);
            if(height[l] &lt; height[r])	l++;
            else	r--;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-3"><a href="#2023-4-3" class="headerlink" title="2023.4.3"></a>2023.4.3</h2><h3 id="1053-交换一次的先前排列"><a href="#1053-交换一次的先前排列" class="headerlink" title="1053.交换一次的先前排列"></a>1053.交换一次的先前排列</h3><h4 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h4><p>给你一个正整数数组 <strong>arr</strong>（可能存在重复的元素），请你返回可在 <strong>一次交换</strong>（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按<strong>字典序</strong>排列<strong>小于</strong> <strong>arr</strong> 的<strong>最大排列</strong>。</p>
<p>如果无法这么操作，就请返回<strong>原数组</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：arr &#x3D; [3,2,1]
输出：[3,1,2]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：arr &#x3D; [1,9,4,6,7]
输出：[1,7,4,6,9]</code></pre>

<h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>对于数组中的两元素下标 i 、j 且 <strong>i &lt; j**，若交换 arr[i] 和 arr[j] 得到的新数组按字典序排列比原数组小，显然有**arr[i] &gt; arr[j]</strong> 。因此符合题意要求的交换会使得数组  arr[i]  在下标 i 处的元素变小。那么为了得到按字典序排列小于原数组的最大新数组，尽可能地保持前面的元素不变是这一步的最优解，即让 <strong>i 最大化</strong>。</p>
<p>也就是说，从右往左遍历，找到的第一个<strong>arr[i] &gt; arr[i + 1]</strong> 处，就是需要被交换的 i 。</p>
<p>显然，找到 i 后，j 需要在 i 右半边去找。在满足 <strong>arr[i] &gt; arr[j]</strong> 的情况下，取<strong>最大</strong>的 <strong>arr[j]</strong> 是这一步的最优解，但需要注意元素可能存在重复的情况需要排除，此时把大的值换到相同数字的最左边，在小于原序列的状态下得到的序列是更大的，因此取<strong>最大的、j 尽量小的 arr[j]</strong> 为最优解。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; arr) &#123;
        for(int i &#x3D; arr.size() - 2; i &gt;&#x3D; 0; --i)&#123;
            if(arr[i] &gt; arr[i + 1])&#123;
                for(int j &#x3D; arr.size() - 1; j &gt; i; --j)&#123;
                    if(arr[j] &lt; arr[i] &amp;&amp; arr[j] !&#x3D; arr[j - 1])&#123;
                        swap(arr[j], arr[i]);
                        return arr;
                    &#125;
                &#125;
            &#125;
        &#125;
        return arr;
    &#125;
&#125;;</code></pre>



<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h3><h4 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h4><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序<strong>最小</strong>的排列（即其元素按升序排列）。</p>
<ul>
<li><p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</p>
</li>
<li><p>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</p>
</li>
<li><p>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</p>
</li>
</ul>
<p>给你一个整数数组 <strong>nums</strong> ，找出 <strong>nums</strong> 的下一个排列。必须 <strong>原地</strong> 修改，只允许使用<strong>额外常数</strong>空间。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [1,2,3]
输出：[1,3,2]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [3,2,1]
输出：[1,2,3]</code></pre>

<h4 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心？、双指针？</strong></p>
<p>这题和今天的每日一题是相同原理，是找大于原序列的最小字典序。</p>
<p>对于数组中的一部分，若完全的降序排列（不存在 <strong>arr[i] &lt; arr[i+1]** 的情况），则这段子序列是最大的。那么最优解就是从右往左找到第一个 **arr[i] &gt; arr[i+1]</strong> 处，就是从尾部开始的最大子序列长度再加一，i 即是要交换的位置。</p>
<p>显然，找到 i 后，j 需要在 i 右半边去找。在满足 <strong>arr[i] &lt; arr[j]</strong> 的情况下，取<strong>最小的</strong> <strong>arr[j]</strong> 是这一步的最优解，此题不需要考虑元素重复的情况，因为换哪个都一样。</p>
<p>交换完成后，由于 i 增大了，要找大于原序列的最小字典序，右侧的子序列自然是要最小的，<strong>因此升序排列即可</strong>。</p>
<p>若找不到这样的 i ，说明原序列就是最大字典序，直接把整个数组升序排列即可。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums)&#123;
        for(int i &#x3D; nums.size() - 2; i &gt;&#x3D; 0; --i)&#123;
        	if(nums[i] &lt; nums[i+1])&#123;
            	for(int j &#x3D; nums.size() - 1; j &gt; i; --j)&#123;  
            		if(nums[j] &gt; nums[i])&#123;
                		swap(nums[j], nums[i]);
        				sort(nums.begin()+i+1,nums.end());
                		return;
            		&#125;
        		&#125;
    		&#125;
    	&#125;
    	sort(nums.begin(),nums.end());
	&#125;
&#125;;</code></pre>



<h2 id="2023-4-4"><a href="#2023-4-4" class="headerlink" title="2023.4.4"></a>2023.4.4</h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><h4 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [1]
输出：[[1]]</code></pre>

<h4 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>回溯、DFS</strong></p>
<p>实际就是一个排列组合问题，每一个数字都要放到最前面，而对剩下的数字里同样是每个数字都要被放在最前（第二个）。。以此类推。这就是分布解决问题的过程。</p>
<p><strong>回溯法</strong>采用的是试错思想：当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。这通常是使用递归来实现的。</p>
<p>而本题中不需要判断分步答案是否正确，只需记录所有分布答案即可。</p>
<p><strong>回溯与动态规划的异同：</strong></p>
<p><strong>1.共同点</strong></p>
<ul>
<li>用于<strong>求解多阶段决策</strong>问题。即：求解一个问题分为很多步骤（阶段）；每一个步骤（阶段）可以有多种选择。</li>
</ul>
<p><strong>2.不同点</strong></p>
<ul>
<li>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；</li>
<li>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</li>
</ul>
<p>对于该题，示例1：</p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="image.png"></p>
<p>深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要<strong>撤销</strong>上一次的选择，这个操作称之为「<strong>状态重置</strong>」</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums, int start, int end)&#123;
        if(start &#x3D;&#x3D; end)&#123;
            res.push_back(nums);
            return;
        &#125;
        for(int i &#x3D; start; i &lt; end; ++i)&#123;
            swap(nums[start], nums[i]);
            dfs(res, nums, start + 1, end);
            swap(nums[start], nums[i]);
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        dfs(res, nums, 0, nums.size());
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-5"><a href="#2023-4-5" class="headerlink" title="2023.4.5"></a>2023.4.5</h2><h3 id="2427-公因子的数目"><a href="#2427-公因子的数目" class="headerlink" title="2427.公因子的数目"></a>2427.公因子的数目</h3><h4 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>暴力</strong></p>
<p>公因子的最大值就是最大公约数，因此先求最大公约数（库函数 <strong>__gcd</strong> ），再从1开始循环判断。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int commonFactors(int a, int b) &#123;
        int divisor &#x3D; __gcd(a, b);
        int res &#x3D; 0;
        for(int i &#x3D; 1; i &lt;&#x3D; divisor; ++i)
            if(a % i &#x3D;&#x3D; 0 &amp;&amp; b % i &#x3D;&#x3D; 0)
                res++;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-6"><a href="#2023-4-6" class="headerlink" title="2023.4.6"></a>2023.4.6</h2><h3 id="1017-负二进制转换"><a href="#1017-负二进制转换" class="headerlink" title="1017.负二进制转换"></a>1017.负二进制转换</h3><h4 id="题干-5"><a href="#题干-5" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数 <code>n</code> ，以二进制字符串的形式返回该整数的 <strong>负二进制（<code>base -2</code>）</strong>表示。</p>
<p><strong>注意，</strong>除非字符串就是 <code>&quot;0&quot;</code>，否则返回的字符串中不能含有前导零。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：n &#x3D; 2
输出：&quot;110&quot;
解释：(-2)2 + (-2)1 &#x3D; 2</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：n &#x3D; 3
输出：&quot;111&quot;
解释：(-2)2 + (-2)1 + (-2)0 &#x3D; 3</code></pre>

<h4 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟、数学</strong></p>
<p>本题主要用到了<strong>十进制转n进制</strong>的方法：<strong>除n取余，逆序排列</strong>。代码模拟了这个过程。</p>
<p>注意：因为填入的结果只有0、1，而余数可能为 -1，可以通过商+1重新计算余数，不影响结果。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string baseNeg2(int n) &#123;
        if(n &#x3D;&#x3D; 0)  
            return &quot;0&quot;;
        string res &#x3D; &quot;&quot;;
        while(n)&#123;
            int quotient &#x3D; n &#x2F; -2;
            int remainder &#x3D; n - quotient * -2;
            if(remainder &lt; 0)
                remainder &#x3D; n - ++quotient * -2;
            res +&#x3D; to_string(remainder);
            n &#x3D; quotient;    
        &#125;
        return string(res.rbegin(), res.rend());
    &#125;
&#125;;</code></pre>



<h3 id="47-全排列Ⅱ"><a href="#47-全排列Ⅱ" class="headerlink" title="47.全排列Ⅱ"></a>47.全排列Ⅱ</h3><h4 id="题干-6"><a href="#题干-6" class="headerlink" title="题干"></a>题干</h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [1,1,2]
输出：[[1,1,2],[1,2,1],[2,1,1]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre>

<h4 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>回溯、DFS</strong></p>
<p>相比于46.全排列，这题在输入数组中存在重复数字，这意味着按照之前的方法会导致重复数字被使用导致排列相同的情况。因此需要判断和剪枝。</p>
<p>首先，要先找到重复数字是哪些，最方便的方法就是先对原数组进行<strong>排序</strong>，那么是否重复只需和上一个数字比较即可。</p>
<p>其次，因为排序，不能直接在原数组上操作了，需要新开一个数组存储每次排列的结果，通过<strong>push</strong>和<strong>pop</strong>来实现<strong>状态重置</strong>。</p>
<p>接着，就需要找到要被剪枝的部分的<strong>判断条件</strong>——</p>
<p>以本题的示例1来说：</p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/1600386643-uhkGmW-image.png" alt="image.png"></p>
<p>可以发现，对于一个重复数字，如果它的上一个相同数字已经被使用了（添加进了数组中），那么该数字是不影响接下来的使用的，因为是添加到上一个数字后面的。而对于未被使用（不在结果数组中）的相同数字，就会导致结果重复。1、1、2中选1和选1，剩下的都是1、2，那么结果也都是一样的，因此可以得到跳过的条件：</p>
<p><strong>遍历到的数字和上一个相同（重复了）且上一个数字未被使用。</strong>使用一个数组进行记录使用情况，在递归前后改变状态完成状态重置。</p>
<p>注意：</p>
<ol>
<li>i - 1 越界问题，要加上 i &gt; 0;</li>
<li>由于原数组被排序了，也无法得知上一个被push进数组的是哪个，因此for循环需要全部遍历一遍，对于已经被push的（状态数组为true，直接跳过即可）。</li>
<li>idx用于统计结果数组中已push的数字数量，满了就存储一个结果并开始状态重置。</li>
</ol>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; sub, vector&lt;bool&gt;&amp; used, vector&lt;int&gt;&amp; nums, int idx)&#123;
        if(idx &#x3D;&#x3D; nums.size())&#123;
            res.push_back(sub);
            return;
        &#125;
        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;
            if(used[i] || i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1] &amp;&amp; !used[i-1])
                continue;
            sub.push_back(nums[i]);
            used[i] &#x3D; true;
            dfs(res, sub, used, nums, idx + 1);
            used[i] &#x3D; false;
            sub.pop_back();
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; sub;
        vector&lt;bool&gt; used(nums.size());
        sort(nums.begin(), nums.end());
        dfs(res, sub, used, nums, 0);
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h3><h4 id="题干-7"><a href="#题干-7" class="headerlink" title="题干"></a>题干</h4><p>以数组 <strong>intervals</strong> 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你<strong>合并所有重叠的区间</strong>，并返回 <strong>一个不重叠的区间数组</strong>，该数组需恰好<strong>覆盖</strong>输入中的<strong>所有区间</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：intervals &#x3D; [[1,4],[0,4]]
输出：[[0,4]]</code></pre>

<h4 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针？</strong></p>
<p>先对二维数组排序，sort默认按第一列升序排，不需要自定义比较函数（自定义的比较函数会让排序慢上很多，其中<strong>单写函数比lambda函数要快一些</strong>）。排完序后需要合并的区间必然是<strong>连续</strong>的。</p>
<p>双指针（这里用了一个大小为2的vector便于存储），只需要判断<strong>左区间和上一个的右区间</strong>即可。</p>
<ul>
<li>左区间大，不用合并，则直接将当前区间加入结果，双指针替换为当前区间的左右边界；</li>
<li>左区间小，再判断<strong>右区间和上一个的右区间</strong>，只有当前右区间更大的时候需要替换右边界的值。</li>
</ul>
<p>结束循环后，若最后一个区间需要合并，则值已经更新在双指针sub中；若不需要合并，则sub也已经替换为了该区间。仅需将sub再加入结果中即可。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; sub &#x3D; intervals[0];
        for(int i &#x3D; 1; i &lt; intervals.size(); ++i)&#123;
            if(intervals[i][0] &lt;&#x3D; sub[1])&#123;
                if(intervals[i][1] &gt; sub[1])
                    sub[1] &#x3D; intervals[i][1];
            &#125;
            else&#123;
                res.push_back(sub);
                sub &#x3D; intervals[i];
            &#125;
        &#125;
        res.push_back(sub);
        return res;56
    &#125;
&#125;;</code></pre>



<h3 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57.插入区间"></a>57.插入区间</h3><h4 id="题干-8"><a href="#题干-8" class="headerlink" title="题干"></a>题干</h4><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]
输出：[[1,5],[6,9]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]
输出：[[1,2],[3,10],[12,16]]</code></pre>

<h4 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟</strong></p>
<p>遍历一遍，每个元素判断以下三种状态：</p>
<ol>
<li>完全在插入区间左边，直接push</li>
<li>与插入区间有重叠，求他们的并集，更新插入区间的左右边界。</li>
<li>完全在插入区间右侧，需要判断插入区间是否push了，没push就push一下，然后push本次元素。</li>
</ol>
<p>如果遍历完都没有push过，那么最后push插入区间。</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;
        bool merged &#x3D; false;
        vector&lt;vector&lt;int&gt;&gt; res;
        for (auto&amp; range: intervals) &#123;
            if (range[1] &lt; newInterval[0])
                res.push_back(range);
            else if (range[0] &gt; newInterval[1]) &#123;
                if (!merged) &#123;
                    res.push_back(newInterval);
                    merged &#x3D; true;                    
                &#125;
                res.push_back(range);
            &#125;
            else &#123;
                newInterval[0] &#x3D; min(newInterval[0], range[0]);
                newInterval[1] &#x3D; max(newInterval[1], range[1]);
            &#125;
        &#125;
        if (!merged) &#123;
            res.push_back(newInterval);
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="73-矩阵置0"><a href="#73-矩阵置0" class="headerlink" title="73.矩阵置0"></a>73.矩阵置0</h3><h4 id="题干-9"><a href="#题干-9" class="headerlink" title="题干"></a>题干</h4><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong>原地</strong> 算法<strong>。</strong></p>
<p>你能想出一个仅使用<strong>常量空间</strong>的解决方案吗？</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</code></pre>

<h4 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟</strong></p>
<p>仅用常数空间，那只能利用原数组进行操作，也就是挑一行和一列记录该行/列是否有0。于是问题转化为了如何记录这一行一列本身是否有0？</p>
<p>思考过程中发现，第一行是最先遍历的话，就能先知道这一行是否有0，那么这一行的值就不重要了，可以用来存储。那么对于列来说，如果是行内遍历列的话（for循环行在外面），只需要维护一个标志位，每次行内遍历时先判断的是第一列，如果是0，标志位置位，就知道了第一列是否有0。这样第一列的值也不重要了（判断过了），也可以用来存储了。</p>
<p>最后按照第一行和第一列的记录情况把对应行列置0。注意跟上述过程相反，为了将记录信息保存到最后，从右下角开始遍历，先向左（到第一列时，这个位置的记录就不需要了。<strong>根据标志位对第一列单独置0</strong>）再向上。</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        bool col0 &#x3D; false;
        int row &#x3D; matrix.size();
        int col &#x3D; matrix[0].size();
        for(int i &#x3D; 0; i &lt; row; ++i)&#123;
            if(matrix[i][0] &#x3D;&#x3D; 0)   col0 &#x3D; true;
            for(int j &#x3D; 1; j &lt; col; ++j)&#123;
                if(matrix[i][j] &#x3D;&#x3D; 0)&#123;
                    matrix[i][0] &#x3D; 0;
                    matrix[0][j] &#x3D; 0;
                &#125;
            &#125;
        &#125;
        for(int i &#x3D; row - 1; i &gt;&#x3D; 0; --i)&#123;
            for(int j &#x3D; col - 1; j &gt;&#x3D; 1; --j)
                if(matrix[i][0] &#x3D;&#x3D; 0 || matrix[0][j] &#x3D;&#x3D; 0)
                    matrix[i][j] &#x3D; 0;
            if(col0)   matrix[i][0] &#x3D; 0;
        &#125;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-8"><a href="#2023-4-8" class="headerlink" title="2023.4.8"></a>2023.4.8</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><h4 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>链表的删除</strong></p>
<p>注意：</p>
<ul>
<li>创建的链表指针temp是<strong>new</strong>的，需要用<strong>delete</strong>手动释放；而tmp指向的是要删除的链表元素，因此也需要<strong>delete</strong>。</li>
<li>cur指针不是<strong>new</strong>或<strong>malloc</strong>分配了空间的，系统会自动释放内存。</li>
<li><strong>free</strong>是C的API，适用于malloc和calloc；<strong>delete</strong>是C++的关键字，主要用于释放new分配的内存，也可用于malloc和calloc。</li>
</ul>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode* removeElements(ListNode* head, int val) &#123;
        ListNode* temp &#x3D; new ListNode(0, head);
        ListNode* cur &#x3D; temp;
        while(cur-&gt;next)&#123;
            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val)&#123;
                ListNode* tmp &#x3D; cur-&gt;next;
                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;
                delete tmp;
            &#125;
            else
                cur &#x3D; cur-&gt;next;
        &#125;
        head &#x3D; temp-&gt;next;
        delete temp;
        return head;
    &#125;
&#125;;</code></pre>



<h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><h4 id="题干-10"><a href="#题干-10" class="headerlink" title="题干"></a>题干</h4><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</p>
<p>实现 <strong>MyLinkedList</strong> 类：</p>
<ul>
<li><strong>MyLinkedList()</strong> 初始化 MyLinkedList 对象。</li>
<li>int <strong>get</strong>(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。</li>
<li>void <strong>addAtHead</strong>(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li>void <strong>addAtTail</strong>(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。</li>
<li>void <strong>addAtIndex</strong>(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。</li>
<li>void <strong>deleteAtIndex</strong>(int index) 如果下标有效，则删除链表中下标为 index 的节点。</li>
</ul>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：
[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出：[null, null, null, null, 2, null, 3]</code></pre>

<h4 id="解法-13"><a href="#解法-13" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>链表的增删查</strong></p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class MyLinkedList &#123;
public:
    MyLinkedList() &#123;
        dummy &#x3D; new ListNode(0);
        length &#x3D; 0;
    &#125;
    int get(int index) &#123;
        if(index &gt;&#x3D; length || index &lt; 0)
            return -1;
        ListNode* cur &#x3D; dummy-&gt;next;
        while(index--)
            cur &#x3D; cur-&gt;next;
        return cur-&gt;val;
    &#125;
    void addAtHead(int val) &#123;
        ListNode* newNode &#x3D; new ListNode(val);
        newNode-&gt;next &#x3D; dummy-&gt;next;
        dummy-&gt;next &#x3D; newNode;
        length++;
    &#125;
    void addAtTail(int val) &#123;
        ListNode* newNode &#x3D; new ListNode(val);
        ListNode* cur &#x3D; dummy;
        while(cur-&gt;next)
            cur &#x3D; cur-&gt;next;
        cur-&gt;next &#x3D; newNode;
        length++;
    &#125;
    void addAtIndex(int index, int val) &#123;
        if(index &gt; length || index &lt; 0)
            return;
        ListNode* newNode &#x3D; new ListNode(val);
        ListNode* cur &#x3D; dummy;
        while(index--)
            cur &#x3D; cur-&gt;next;
        newNode-&gt;next &#x3D; cur-&gt;next;
        cur-&gt;next &#x3D; newNode;
        length++;
    &#125;
    void deleteAtIndex(int index) &#123;
        if(index &gt;&#x3D; length || index &lt; 0)
            return;
        ListNode* cur &#x3D; dummy;
        while(index--)
            cur &#x3D; cur-&gt;next;
        ListNode* tmp &#x3D; cur-&gt;next;
        cur-&gt;next &#x3D; cur-&gt;next-&gt;next;
        delete tmp;
        length--;
    &#125;
private:
    ListNode* dummy;
    int length;
&#125;;</code></pre>



<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><h4 id="解法-14"><a href="#解法-14" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt="img"></p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* tmp;
        ListNode* slow &#x3D; nullptr;
        ListNode* fast &#x3D; head;
        while(fast)&#123;
            tmp &#x3D; fast-&gt;next;
            fast-&gt;next &#x3D; slow;
            slow &#x3D; fast;
            fast &#x3D; tmp;
        &#125;
        return slow;
    &#125;
&#125;;</code></pre>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>基本思路：<strong>虚拟头节点、头插法</strong></p>
<p>建立一个新链表的虚拟头节点，指向nullptr。遍历原链表元素，依次插入到虚拟节点后。</p>
<p>速度比双指针快一些。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* dummy &#x3D; new ListNode(0);
        ListNode* cur &#x3D; head;
        while(cur)&#123;
            ListNode* tmp &#x3D; cur-&gt;next;
            cur-&gt;next &#x3D; dummy-&gt;next;
            dummy-&gt;next &#x3D; cur;
            cur &#x3D; tmp;
        &#125;
        cur &#x3D; dummy-&gt;next;
        delete dummy;
        return cur;
    &#125;
&#125;;</code></pre>



<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><h4 id="题干-11"><a href="#题干-11" class="headerlink" title="题干"></a>题干</h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：head &#x3D; [1,2,3,4]
输出：[2,1,4,3]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：head &#x3D; [1]
输出：[1]</code></pre>

<h4 id="解法-15"><a href="#解法-15" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟</strong></p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode* swapPairs(ListNode* head) &#123;
        ListNode* dummy &#x3D; new ListNode(0, head);
        ListNode* cur &#x3D; dummy;
        while(cur-&gt;next !&#x3D; nullptr &amp;&amp; cur-&gt;next-&gt;next !&#x3D; nullptr)&#123;
            ListNode* tmp &#x3D; cur-&gt;next;
            ListNode* tmp2 &#x3D; cur-&gt;next-&gt;next-&gt;next;
            cur-&gt;next &#x3D; cur-&gt;next-&gt;next;
            cur-&gt;next-&gt;next &#x3D; tmp;
            cur-&gt;next-&gt;next-&gt;next &#x3D; tmp2;
            cur &#x3D; cur-&gt;next-&gt;next;
        &#125;
        cur &#x3D; dummy-&gt;next;
        delete dummy;
        return cur;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-9"><a href="#2023-4-9" class="headerlink" title="2023.4.9"></a>2023.4.9</h2><h3 id="2399-检查相同字母间的距离"><a href="#2399-检查相同字母间的距离" class="headerlink" title="2399.检查相同字母间的距离"></a>2399.检查相同字母间的距离</h3><h4 id="解法-16"><a href="#解法-16" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<p>遍历，如果这个字符是第一次扫到（用<strong>哈希表</strong>存储判断），就判断与<strong>该下标+对应distance+1处</strong>的字符（<strong>注意越界</strong>）是否相同，任何一次不同就返回false。</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool checkDistances(string s, vector&lt;int&gt;&amp; distance) &#123;
        unordered_set&lt;char&gt; hash;
        for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123;
            if(!hash.count(s[i]))&#123;
                hash.emplace(s[i]);
                int idx &#x3D; i + distance[s[i] - &#39;a&#39;] + 1;
                if(idx &gt;&#x3D; s.length())
                    return false;
                if(s[i] !&#x3D; s[idx])
                    return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;</code></pre>



<h3 id="24-两两交换链表中的节点-1"><a href="#24-两两交换链表中的节点-1" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><h4 id="题干-12"><a href="#题干-12" class="headerlink" title="题干"></a>题干</h4><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：head &#x3D; [1,2], n &#x3D; 1
输出：[1]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：head &#x3D; [1], n &#x3D; 1
输出：[]</code></pre>

<pre class="language-none"><code class="language-none">示例 3：
输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2
输出：[1,2,3,5]</code></pre>

<h4 id="解法-17"><a href="#解法-17" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针、链表删除</strong></p>
<p>双指针的间距为 <strong>n - 1</strong>。当快指针到末尾元素时，慢指针的下一个元素就是要删的元素。</p>
<p>注意<strong>删除的是末尾元素</strong>和链表<strong>只有一个元素</strong>的情况。</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
        ListNode* slow &#x3D; head;
        ListNode* fast &#x3D; head;
        while(n--)
            fast &#x3D; fast-&gt;next;
        if(fast !&#x3D; nullptr)&#123;
            while(fast-&gt;next !&#x3D; nullptr)&#123;
                fast &#x3D; fast-&gt;next;
                slow &#x3D; slow-&gt;next;
            &#125;
            if(slow-&gt;next &#x3D;&#x3D; fast)
                slow-&gt;next &#x3D; nullptr;
            else&#123;
                ListNode* tmp &#x3D; slow-&gt;next;
                slow-&gt;next &#x3D; slow-&gt;next-&gt;next;
                delete tmp;
            &#125;
        &#125;
        else
            head &#x3D; head-&gt;next;
        return head;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-10"><a href="#2023-4-10" class="headerlink" title="2023.4.10"></a>2023.4.10</h2><h3 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019.链表中的下一个更大节点"></a>1019.链表中的下一个更大节点</h3><h4 id="题干-13"><a href="#题干-13" class="headerlink" title="题干"></a>题干</h4><p>给定一个长度为 <strong>n</strong> 的链表 <strong>head</strong>，对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。</p>
<p>返回一个整数数组 <strong>answer</strong> ，其中 <strong>answer[i]</strong> 是第 i 个节点( 从1开始 )的下一个<strong>更大的节点的值</strong>。如果第 i 个节点没有下一个更大的节点，设置 <strong>answer[i] = 0</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：head &#x3D; [2,1,5]
输出：[5,5,0]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：head &#x3D; [2,1,5]
输出：[5,5,0]</code></pre>

<h4 id="解法-18"><a href="#解法-18" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>单调栈</strong></p>
<p>维护一个底大顶小的单调栈。假设前几个元素为9、7、5、3，此时没有任意一个更大的元素时，则把每个元素都压入栈。这时出现一个6，发现比栈顶的3大，那么把3出栈，更新该处的值为6。再跟栈顶的5比，还大，就继续出栈，更新。直至跟7比小了，就结束；然后把6入栈，记录该处的值为本身6。</p>
<p>也就是说，入栈的元素栈底的必然比上面的大，而每次来一个较大元素，都把所有比他小的元素出栈，一直遍历到链表结束。此时栈中若还有元素，说明整个链表他们右边没有更大的了，那么值就是0，依次出栈记录0即可。</p>
<p>用栈维护下标，值存储在数组中。</p>
<h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; nextLargerNodes(ListNode* head) &#123;
        vector&lt;int&gt; res;
        stack&lt;int&gt; bigger;
        for(ListNode* cur &#x3D; head; cur; cur &#x3D; cur-&gt;next)&#123;
            while(!bigger.empty() &amp;&amp; res[bigger.top()] &lt; cur-&gt;val)&#123;
                res[bigger.top()] &#x3D; cur-&gt;val;
                bigger.pop();
            &#125;
            bigger.emplace(res.size());
            res.push_back(cur-&gt;val);
        &#125;
        while(!bigger.empty())&#123;
            res[bigger.top()] &#x3D; 0;
            bigger.pop();
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07.链表相交"></a>面试题 02.07.链表相交</h3><h4 id="题干-14"><a href="#题干-14" class="headerlink" title="题干"></a>题干</h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/160_statement.png" alt="img" style="zoom: 67%;">

<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3
输出：Intersected at &#39;8&#39;</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2
输出：null</code></pre>

<h4 id="解法-19"><a href="#解法-19" class="headerlink" title="解法"></a>解法</h4><p>基本思路：**双指针    **</p>
<p>因为两个链表后半部分相同，因此只要将其末尾对齐，找有无公共节点即可。</p>
<h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        ListNode* a &#x3D; headA;
        ListNode* b &#x3D; headB;
        int aLen &#x3D; 0, bLen &#x3D; 0;
        while(a)&#123;
            a &#x3D; a-&gt;next;
            aLen++;
        &#125;
        while(b)&#123;
            b &#x3D; b-&gt;next;
            bLen++;
        &#125;
        a &#x3D; headA;
        b &#x3D; headB;
        if(bLen &gt; aLen)&#123;
            swap(a, b);
            swap(aLen, bLen);
        &#125;
        int sub &#x3D; aLen - bLen;
        while(sub--)
            a &#x3D; a-&gt;next;
        while(a)&#123;
            if(a &#x3D;&#x3D; b)
                return a;
            a &#x3D; a-&gt;next;
            b &#x3D; b-&gt;next;
        &#125;
        return NULL;
    &#125;
&#125;;</code></pre>

<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p><strong>天才解法</strong></p>
<p>设链表a长度为a，b长度为b，公共部分长度为c。可知a到公共节点前长度为a - c，b为 b - c。</p>
<p>双指针A、B指向a、b头部，A遍历完a后遍历b，B遍历完b后遍历a，当走到公共节点时，两者所走步数分别为a + b - c 和 b + a - c。</p>
<p>此时指针A、B重合，<strong>a + (b - c) = b + (a - c)</strong> 必然成立，会有两种情况：</p>
<ul>
<li>有公共尾部，c ≠ 0，那么双指针肯定指向同一个节点，返回；</li>
<li>无公共尾部，c = 0，那么双指针都指向末尾NULL，也返回。</li>
</ul>
<p><strong>真牛吧！</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        ListNode *A &#x3D; headA, *B &#x3D; headB;
        while (A !&#x3D; B) &#123;
            A &#x3D; A !&#x3D; nullptr ? A-&gt;next : headB;
            B &#x3D; B !&#x3D; nullptr ? B-&gt;next : headA;
        &#125;
        return A;
    &#125;
&#125;;</code></pre>



<h3 id="142-环形链表-Ⅱ"><a href="#142-环形链表-Ⅱ" class="headerlink" title="142.环形链表 Ⅱ"></a>142.环形链表 Ⅱ</h3><h4 id="题干-15"><a href="#题干-15" class="headerlink" title="题干"></a>题干</h4><p>给定一个链表的头节点  <strong>head</strong> ，返回链表开始入环的第一个节点。 如果链表无环，则返回 <strong>null</strong>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许<strong>修改</strong> 链表。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1
输出：返回索引为 1 的链表节点</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：head &#x3D; [1,2], pos &#x3D; -1
输出：返回NULL</code></pre>

<h4 id="解法-20"><a href="#解法-20" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>第一步：<strong>快慢指针，统计环长</strong></p>
<p>slow步长为1，fast步长为2。当第一次相遇时开始维护变量len，当第二次相遇时，len即为环长（由于双指针的速度差为1，当slow走完一圈时fast正好走完两圈相遇在同一位置，也就是slow动的次数即为环长）。</p>
<p>注意：fast步长为2，循环时要考虑到fast<strong>后两个节点</strong>是否为NULL的情况。以及循环结束时根据<strong>len值</strong>判断有无环。</p>
<p>第二步：<strong>前后指针，找到进入环的节点</strong></p>
<p>slow与fast步长均为1，fast先走len步。于是当slow到达环入口节点时，fast多走了一个环长也到了入口处，两者相遇处即为答案。</p>
<h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        ListNode* slow &#x3D; head;
        ListNode* fast &#x3D; head;
        int len &#x3D; 0;
        int count &#x3D; 0;
        while(fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;
            slow &#x3D; slow-&gt;next;
            fast &#x3D; fast-&gt;next-&gt;next;
            if(count)   len++;   
            if(slow &#x3D;&#x3D; fast)&#123;
                if(count)   break;   
                count++;
            &#125;
        &#125;
        if(len &#x3D;&#x3D; 0)
            return NULL;
        slow &#x3D; head;
        fast &#x3D; head;
        while(len--)
            fast &#x3D; fast-&gt;next;
        while(slow !&#x3D; fast)&#123;
            fast &#x3D; fast-&gt;next;
            slow &#x3D; slow-&gt;next;
        &#125;
        return slow;
    &#125;
&#125;;</code></pre>



<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a>287.寻找重复数</h3><h4 id="题干-16"><a href="#题干-16" class="headerlink" title="题干"></a>题干</h4><p>给定一个包含 <strong>n + 1</strong> 个整数的数组 <strong>nums</strong> ，其数字都在 <strong>[1, n]</strong> 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 <strong>nums</strong> 只有 <strong>一个重复</strong>的整数 ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <strong>nums</strong> 且只用常量级 <strong>O(1)</strong> 的额外空间。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [1,3,4,2,2]
输出：2</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [3,1,3,4,2]
输出：3</code></pre>

<h4 id="解法-21"><a href="#解法-21" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>思路同上题 142.环形链表 Ⅱ 。</p>
<p>居然把数组当成一个特殊链表来看，只有一个重复数就像只有一个环的入口。同时n+1的长度，元素在 [1，n] 范围内不存在越界问题。</p>
<h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;
        int slow &#x3D; 0, fast &#x3D; 0;
        int len &#x3D; 0, count &#x3D; 0;
        while(count !&#x3D; 2)&#123;
            if(count)   len++;
            if(nums[slow] &#x3D;&#x3D; nums[fast])    count++;
            slow &#x3D; nums[slow];
            fast &#x3D; nums[nums[fast]];
        &#125;
        slow &#x3D; fast &#x3D; 0;
        while(len--)
            fast &#x3D; nums[fast];
        while(nums[slow] !&#x3D; nums[fast])&#123;
            slow &#x3D; nums[slow];
            fast &#x3D; nums[fast];
        &#125;
        return nums[slow];
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-11"><a href="#2023-4-11" class="headerlink" title="2023.4.11"></a>2023.4.11</h2><h3 id="1041-困于环中的机器人"><a href="#1041-困于环中的机器人" class="headerlink" title="1041.困于环中的机器人"></a>1041.困于环中的机器人</h3><h4 id="题干-17"><a href="#题干-17" class="headerlink" title="题干"></a>题干</h4><p>在无限的平面上，机器人最初位于 <strong>(0, 0)</strong> 处，面朝<strong>北方</strong>。注意:</p>
<ul>
<li><p>北方向 是y轴的正方向。</p>
</li>
<li><p>南方向 是y轴的负方向。</p>
</li>
<li><p>东方向 是x轴的正方向。</p>
</li>
<li><p>西方向 是x轴的负方向。</p>
</li>
</ul>
<p>机器人可以接受下列三条指令之一：</p>
<ul>
<li><p>“G”：直走 1 个单位</p>
</li>
<li><p>“L”：左转 90 度</p>
</li>
<li><p>“R”：右转 90 度</p>
</li>
</ul>
<p>机器人按顺序执行指令 <strong>instructions</strong>，并一直重复它们。只有在平面中存在环使得机器人永远无法离开时，返回 <strong>true</strong>。否则，返回 <strong>false。</strong></p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：instructions &#x3D; &quot;GGLLGG&quot;
输出：true</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：instructions &#x3D; &quot;GL&quot;
输出：true</code></pre>

<h4 id="解法-22"><a href="#解法-22" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟</strong></p>
<p>主要就是判断走完后的状态。若回到原点了，那一定是环。</p>
<p>若没能回到原点，分四个方向：</p>
<ul>
<li>朝北，说明回不去了，因为相当于一直在朝一个方向移动。</li>
<li>朝南，则下一次相当于原路返回原点，是环。</li>
<li>朝西、朝东，都是相当于每次移动相同形状的轨迹，转90°，也是环。</li>
</ul>
<p>因此返回false的条件必须是<strong>结束时不在原点且朝向北</strong>。</p>
<h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool isRobotBounded(string instructions) &#123;
        int x &#x3D; 0, y &#x3D; 0, direct &#x3D; 0;
        vector&lt;vector&lt;int&gt;&gt; step &#x3D; &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;
        for(char c : instructions)&#123;
            if(c &#x3D;&#x3D; &#39;G&#39;)&#123;
                x +&#x3D; step[direct][0];
                y +&#x3D; step[direct][1];
            &#125;
            else if(c &#x3D;&#x3D; &#39;L&#39;)&#123;
                direct +&#x3D; 3;
                direct %&#x3D; 4;
            &#125;
            else&#123;
                direct++;
                direct %&#x3D; 4;
            &#125;
        &#125;
        return !(direct &#x3D;&#x3D; 0 &amp;&amp; (x || y));
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-12"><a href="#2023-4-12" class="headerlink" title="2023.4.12"></a>2023.4.12</h2><h3 id="1147-段式回文"><a href="#1147-段式回文" class="headerlink" title="1147.段式回文"></a>1147.段式回文</h3><h4 id="题干-18"><a href="#题干-18" class="headerlink" title="题干"></a>题干</h4><p>你会得到一个字符串 text 。你应该把它分成 <strong>k</strong> 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足:</p>
<p>subtexti 是 <strong>非空</strong> 字符串，所有子字符串的连接等于 text ( 即subtext1 + subtext2 + … + subtextk == text )。对于所有 <strong>i</strong> 的<strong>有效</strong>值( 即 1 &lt;= i &lt;= k ) ，subtext<strong>i</strong> == subtext<strong>k - i + 1</strong> 均成立</p>
<p>返回k可能<strong>最大值</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：text &#x3D; &quot;ghiabcdefhelloadamhelloabcdefghi&quot;
输出：7</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：text &#x3D; &quot;merchant&quot;
输出：1</code></pre>

<h4 id="解法-23"><a href="#解法-23" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>双指针指向字符串头尾，用于锁定为判断字符串的范围。</p>
<p>因为要求最大值，因此字串长度要尽可能小。子串长度k从1开始（注意头串的尾部下标 &lt; 尾串的头部下标），有相同的子串直接记录+2，双指针向中间移动k。</p>
<p>缩小判断范围后重复上述过程。如果k平分了整个字符串都没有找到，那就返回整个串作为子串，记录只能+1，并直接结束。</p>
<h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int longestDecomposition(string text) &#123;
        auto checkSame &#x3D; [&amp;](int i, int j, int k)&#123;
            while(k--)
                if(text[i++] !&#x3D; text[j++])
                    return false;
            return true;
        &#125;;
        int res &#x3D; 0;
        for(int i &#x3D; 0, j &#x3D; text.length() - 1; i &lt;&#x3D; j;)&#123;
            bool flag &#x3D; false;
            for(int k &#x3D; 1; i + k - 1 &lt; j - k + 1; ++k)&#123;
                if(checkSame(i, j - k + 1, k))&#123;
                    res +&#x3D; 2;
                    i +&#x3D; k;
                    j -&#x3D; k;
                    flag &#x3D; true;
                    break;
                &#125;
            &#125;
            if(!flag)&#123;
                res++;
                break;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p><strong>Lambda函数主体：</strong><code>[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;</code></p>
<table>
<thead>
<tr>
<th align="left">捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td align="left">[变量名, …]</td>
<td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
</tr>
<tr>
<td align="left">[this]</td>
<td>以值的形式捕获this指针</td>
</tr>
<tr>
<td align="left">[=]</td>
<td>以值的形式捕获所有外部变量</td>
</tr>
<tr>
<td align="left">[&amp;]</td>
<td>以引用形式捕获所有外部变量</td>
</tr>
<tr>
<td align="left">[=, &amp;x]</td>
<td>变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td align="left">[&amp;, x]</td>
<td>变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody></table>
<ul>
<li>若要<strong>在匿名函数内</strong>修改值引用的外部变量，可以在括号后使用 mutable 关键字（[a] () <strong>mutable</strong> { cout &lt;&lt; ++a; }; 这里a在这个函数内部自加了，但是外部的a的值是<strong>不变的</strong>）。</li>
<li>return type若不指定，编译器会根据内部返回值的类型确定该匿名函数的返回值类型。</li>
</ul>
<h2 id="2023-4-13"><a href="#2023-4-13" class="headerlink" title="2023.4.13"></a>2023.4.13</h2><h3 id="2404-出现最频繁的偶数元素"><a href="#2404-出现最频繁的偶数元素" class="headerlink" title="2404.出现最频繁的偶数元素"></a>2404.出现最频繁的偶数元素</h3><h4 id="题干-19"><a href="#题干-19" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <code>nums</code> ，返回出现最频繁的偶数元素。</p>
<p>如果存在多个满足条件的元素，只需要返回 <strong>最小</strong> 的一个。如果不存在这样的元素，返回 <code>-1</code> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [0,1,2,2,4,4,1]
输出：2</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [29,47,21,41,13,37,25,7]
输出：-1</code></pre>

<h4 id="解法-24"><a href="#解法-24" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<p>用哈希表统计每个偶数元素出现的次数，然后遍历哈希表找到次数最多的元素中值最小的。</p>
<h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int mostFrequentEven(vector&lt;int&gt;&amp; nums) &#123;
        unordered_map&lt;int, int&gt;  cnt;
        for(int n : nums)&#123;
            if(n % 2 &#x3D;&#x3D; 0)
                cnt[n]++;
        &#125;
        if(cnt.empty())
            return -1;
        int maxNum &#x3D; 0, minVal &#x3D; INT_MAX;
        for(auto c : cnt)&#123;
            if(c.second &gt; maxNum || c.second &#x3D;&#x3D; maxNum &amp;&amp; c.first &lt; minVal)&#123;
                maxNum &#x3D; c.second;
                minVal &#x3D; c.first;
            &#125;   
        &#125;
        return minVal;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-14"><a href="#2023-4-14" class="headerlink" title="2023.4.14"></a>2023.4.14</h2><h3 id="1023-驼峰式匹配"><a href="#1023-驼峰式匹配" class="headerlink" title="1023.驼峰式匹配"></a>1023.驼峰式匹配</h3><h4 id="题干-20"><a href="#题干-20" class="headerlink" title="题干"></a>题干</h4><p>如果我们可以将<strong>小写字母</strong>插入模式串 <strong>pattern</strong> 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在<strong>任何位置</strong>插入每个字符，也可以插入 <strong>0</strong> 个字符。）</p>
<p>给定待查询列表 <strong>queries</strong>，和模式串 <strong>pattern</strong>，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FB&quot;
输出：[true,false,true,true,false]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FoBaT&quot;
输出：[false,true,false,false,false]</code></pre>

<h4 id="解法-25"><a href="#解法-25" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>本质其实是字符串比较。规则是：<strong>大写字符必须全部匹配</strong>。</p>
<p>双指针i、j指向query和pattern，以pattern为循环体，字符比较</p>
<ul>
<li>若不同</li>
<li>——小写字符，i++继续比较；</li>
<li>——大写字符直接false，不能有匹配不上的大写字符；</li>
<li>若相同</li>
<li>——i++、j++。</li>
</ul>
<p>如果j没结束时i就遍历完了，说明 j 有没匹配到的，false。</p>
<p>如果j先遍历完了，遍历剩下的i，若有大写的false，全小写true。</p>
<h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;bool&gt; camelMatch(vector&lt;string&gt;&amp; queries, string pattern) &#123;
        vector&lt;bool&gt; res;
        auto check &#x3D; [](string s, string t)&#123;
            int i &#x3D; 0, j &#x3D; 0;
            for(; j &lt; t.length(); ++i, ++j)&#123;
                while(i &lt; s.length() &amp;&amp; s[i] !&#x3D; t[j] &amp;&amp; s[i] &gt; 96)
                    ++i;
                if(i &#x3D;&#x3D; s.length() || s[i] !&#x3D; t[j])
                    return false;
            &#125;
            while(i &lt; s.length() &amp;&amp; s[i] &gt; 96)
                ++i;
            return i &#x3D;&#x3D; s.length();
        &#125;;
        for(auto str : queries)
            res.push_back(check(str, pattern));
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-17"><a href="#2023-4-17" class="headerlink" title="2023.4.17"></a>2023.4.17</h2><h3 id="2409-统计共同度过的日子数"><a href="#2409-统计共同度过的日子数" class="headerlink" title="2409.统计共同度过的日子数"></a>2409.统计共同度过的日子数</h3><h4 id="解法-26"><a href="#解法-26" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟、数学计算</strong></p>
<p>简单的日期转换，转换为当年的第多少天，然后求交集。</p>
<h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int getDays(string s)&#123;
        int days[13] &#x3D; &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;
        int res &#x3D; 0;
        int m &#x3D; atoi(s.substr(0, 2).c_str());
        int d &#x3D; atoi(s.substr(3, 2).c_str());
        for(int i &#x3D; 1; i &lt; m; ++i)
            res +&#x3D; days[i];
        return res + d;
    &#125;
    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) &#123;
        int aa &#x3D; getDays(arriveAlice);
        int la &#x3D; getDays(leaveAlice);
        int ab &#x3D; getDays(arriveBob);
        int lb &#x3D; getDays(leaveBob);
        if(aa &gt; lb || ab &gt; la)
            return 0;
        return min(la, lb) - max(aa, ab) + 1;
    &#125;
&#125;;</code></pre>



<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><h4 id="解法-27"><a href="#解法-27" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool isAnagram(string s, string t) &#123;
        if(s.length() !&#x3D; t.length())
            return false;
        vector&lt;int&gt; hash(26, 0);
        for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123;
            hash[s[i] - &#39;a&#39;]++;
            hash[t[i] - &#39;a&#39;]--;
        &#125;
        for(int n : hash)
            if(n)   return false;
        return true;
    &#125;
&#125;;</code></pre>



<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><h4 id="解法-28"><a href="#解法-28" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<p>和上题242.有效的字母异位词一个思路。</p>
<h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool canConstruct(string ransomNote, string magazine) &#123;
        vector&lt;int&gt; hash(26, 0);
        for(char c : magazine)
            hash[c - &#39;a&#39;]++;
        for(char c : ransomNote)
            hash[c - &#39;a&#39;]--;
        for(int n : hash)
            if(n &lt; 0)   return false;
        return true;
    &#125;
&#125;;</code></pre>



<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h3><h4 id="题干-21"><a href="#题干-21" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按<strong>任意顺序</strong>返回结果列表。</p>
<p><strong>字母异位词</strong> 是由<strong>重新排列</strong>源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用<strong>一次</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入: strs &#x3D; [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]
输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入: strs &#x3D; [&quot;&quot;]
输出: [[&quot;&quot;]]</code></pre>

<h4 id="解法-29"><a href="#解法-29" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希</strong></p>
<p>因为所有的异位词在排序后都是相同的，那么就可以用哈希表存储vector保存属于同一种类的字符串。</p>
<h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        vector&lt;vector&lt;string&gt;&gt; res;
        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;
        auto sortStr &#x3D; [](string str)&#123;
            sort(str.begin(), str.end());
            return str;
        &#125;;
        for(string s : strs)
            hash[sortStr(s)].push_back(s);
        for(auto m : hash)
            res.push_back(m.second);
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h3><h4 id="题干-22"><a href="#题干-22" class="headerlink" title="题干"></a>题干</h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的<strong>顺序</strong>。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot;
输出: [0,6]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;
输出: [0,1,2]</code></pre>

<h4 id="解法-30"><a href="#解法-30" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>滑动窗口、双指针、哈希</strong></p>
<p>第一想法是滑动窗口扫一遍，每次将窗口内字符排序后与排序后的p比较。实际是暴力解法，O(n^2)复杂度，其中有很多不必要的操作：</p>
<p>例如[i, j]和[i+1, j+1]两个子串在暴力法第二步中，需要各遍历一次，完全没必要。其实[i+1, j+1]完全可以在[i, j]的基础上做判断，也就是去掉头部的字符（i位置），加上尾部的字符（j+1位置）。这样第一步的复杂度可以降到O(1)，整体复杂度降到O(n)。</p>
<h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; findAnagrams(string s, string p) &#123;
        if(s.length() &lt; p.length())
            return &#123;&#125;;
        vector&lt;int&gt; res;
        vector&lt;int&gt; shash(26, 0);
        vector&lt;int&gt; phash(26, 0);
        for(char c : p)
            phash[c - &#39;a&#39;]++;
        for(int i &#x3D; 0; i &lt; p.length(); ++i)
            shash[s[i] - &#39;a&#39;]++;
        int i &#x3D; p.length(), j &#x3D; 0;
        for(; i &lt; s.length(); ++i, ++j)&#123;
            if(shash &#x3D;&#x3D; phash)
                res.push_back(j);
            shash[s[i] - &#39;a&#39;]++;
            shash[s[j] - &#39;a&#39;]--;
        &#125;
        if(shash &#x3D;&#x3D; phash)
            res.push_back(j);
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-22"><a href="#2023-4-22" class="headerlink" title="2023.4.22"></a>2023.4.22</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><h4 id="解法-31"><a href="#解法-31" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        unordered_set&lt;int&gt; hash;
        vector&lt;int&gt; res;
        for(int n : nums1)
            if(!hash.count(n))
                hash.emplace(n);
        for(int n : nums2)&#123;
            if(hash.count(n))&#123;
                res.push_back(n);
                hash.erase(n);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="350-两个数组的交集Ⅱ"><a href="#350-两个数组的交集Ⅱ" class="headerlink" title="350.两个数组的交集Ⅱ"></a>350.两个数组的交集Ⅱ</h3><h4 id="解法-32"><a href="#解法-32" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        unordered_map&lt;int, int&gt; hash;
        vector&lt;int&gt; res;
        for(int n : nums1)
            ++hash[n];
        for(int n : nums2)&#123;
            if(hash.count(n) &amp;&amp; hash[n] &gt; 0)&#123;
                res.push_back(n);
                --hash[n];
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><h4 id="解法-33"><a href="#解法-33" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<p>这题的关键在于找到什么情况下是无解的？<strong>当某次平方和的值重复出现的时候</strong>，那么用哈希表做个判断即可。</p>
<h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool isHappy(int n) &#123;
        unordered_set&lt;int&gt; hash;
        int sum &#x3D; 0, unit;
        while(1)&#123;
            unit &#x3D; n % 10;
            sum +&#x3D; unit * unit;
            n &#x2F;&#x3D; 10;
            if(n &#x3D;&#x3D; 0)&#123;
                n &#x3D; sum;
                if(sum &#x3D;&#x3D; 1)
                    return true;
                if(hash.count(sum))
                    return false;
                hash.emplace(sum);
                sum &#x3D; 0;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;</code></pre>



<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><h4 id="解法-34"><a href="#解法-34" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希表</strong></p>
<p>将数组元素依次加入哈希表，并判断target - 当前元素的值是否在哈希表中。</p>
<h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        unordered_map&lt;int, int&gt; hashs; 
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            auto iter &#x3D; hashs.find(target - nums[i]);
            if (iter !&#x3D; hashs.end()) return &#123;iter-&gt;second, i&#125;;
            hashs.insert(&#123;nums[i], i&#125;);
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;</code></pre>



<h3 id="454-四数相加Ⅱ"><a href="#454-四数相加Ⅱ" class="headerlink" title="454.四数相加Ⅱ"></a>454.四数相加Ⅱ</h3><h4 id="题干-23"><a href="#题干-23" class="headerlink" title="题干"></a>题干</h4><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<ul>
<li><p>0 &lt;= i, j, k, l &lt; n</p>
</li>
<li><p>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
</li>
</ul>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]
输出：2</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]
输出：1</code></pre>

<h4 id="解法-35"><a href="#解法-35" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>哈希</strong></p>
<p>因为所有的异位词在排序后都是相同的，那么就可以用哈希表存储vector保存属于同一种类的字符串。</p>
<p>乍一看有点懵，实际就是转换一下条件，变成：<strong>nums1[i] + nums2[j] == -(nums3[k] + nums4[l]）</strong></p>
<p>也就是先记录每一对1、2的和的数量存入哈希，然后将3、4的和放入哈希去找，若存在，直接增加记录的数量（因为和为该值的每一对1、2都能与这对3、4相匹配，所以直接加数量）。</p>
<h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;
        unordered_map&lt;int, int&gt; hash;
        int res &#x3D; 0;
        for(int i : nums1)
            for(int j : nums2)
                ++hash[i+j];
        for(int i : nums3)
            for(int j : nums4)
                if(hash.count(-i-j))
                    res +&#x3D; hash[-i-j];
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-23"><a href="#2023-4-23" class="headerlink" title="2023.4.23"></a>2023.4.23</h2><h3 id="1105-填充书架"><a href="#1105-填充书架" class="headerlink" title="1105.填充书架"></a>1105.填充书架</h3><h4 id="题干-24"><a href="#题干-24" class="headerlink" title="题干"></a>题干</h4><p>给定一个数组 <strong>books</strong> ，其中 <strong>books[i] = [thicknessi, heighti]</strong> 表示第 i 本书的厚度和高度。你也会得到一个整数 <strong>shelfWidth</strong> 。</p>
<p>按<strong>顺序</strong> 将这些书摆放到总宽度为 <strong>shelfWidth</strong> 的书架上。</p>
<p>先选几本书放在书架上（它们的<strong>厚度</strong>之和<strong>小于等于</strong>书架的宽度 shelfWidth ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。</p>
<p>每一层所摆放的书的最大高度为这一层书架的层高，书架整体高度为各层高之和。以这种方式布置书架，返回书架整体可能的<strong>最小高度</strong>。</p>
<p><strong>示例</strong></p>
<img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/shelves.png" alt="img" style="zoom: 50%;">

<pre class="language-none"><code class="language-none">示例 1：
输入：books &#x3D; [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth &#x3D; 4
输出：6</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入: books &#x3D; [[1,3],[2,4],[3,2]], shelfWidth &#x3D; 6
输出: 4</code></pre>

<h4 id="解法-36"><a href="#解法-36" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p>设前i本书摆放完成后的总高度为 <strong>f[i]</strong> ,答案为 <strong>f[n]</strong> 。那么对于第i本书的w和h：1.若单独拜访一层有  <strong>f[i] = f[i - 1] + h</strong> ；2.若与之前 ？本书一起放，则需要找到这些书的最大高度作为该层层高。</p>
<p>从第 i - 1 本书开始向前遍历，停止条件为累加书的w大于了shelfWidth。找到这些书中 的最大高度，那么可得 <strong>f[i] = min(f[i], f[j - 1] + h)</strong></p>
<h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) &#123;
        int n &#x3D; books.size();
        vector&lt;int&gt; f(n + 1, 0);
        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;
            int w &#x3D; books[i - 1][0], h &#x3D; books[i - 1][1];
            f[i] &#x3D; f[i - 1] + h;
            for(int j &#x3D; i - 1; j &gt; 0; --j)&#123;
                w +&#x3D; books[j - 1][0];
                if(w &gt; shelfWidth)  break;
                h &#x3D; max(h, books[j - 1][1]);
                f[i] &#x3D; min(f[i], f[j - 1] + h);
            &#125;
        &#125;
        return f[n];
    &#125;
&#125;;</code></pre>



<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><h4 id="解法-37"><a href="#解法-37" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针、swap</strong></p>
<p>swap的实现方法有两种：1.是通过临时变量存储交换；2.是通过位运算(异或)交换。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">a ^&#x3D; b;
b ^&#x3D; a;
a ^&#x3D; b;</code></pre>

<h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void reverseString(vector&lt;char&gt;&amp; s) &#123;
        int l &#x3D; 0, r &#x3D; s.size() - 1;
        while(l &lt; r)
            swap(s[l++], s[r--]);
    &#125;
&#125;;</code></pre>



<h3 id="541-反转字符串Ⅱ"><a href="#541-反转字符串Ⅱ" class="headerlink" title="541.反转字符串Ⅱ"></a>541.反转字符串Ⅱ</h3><h4 id="解法-38"><a href="#解法-38" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针、swap</strong></p>
<p>在上题344.反转字符串的基础上，判断每段要反转的部分的两端位置即可。</p>
<h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string reverseStr(string s, int k) &#123;
        auto revStr &#x3D; [&amp;s](int l, int r)&#123;
            while(l &lt; r)
                swap(s[l++], s[r--]);
        &#125;;
        int cnt &#x3D; s.length() &#x2F; (2 * k);
        int unit &#x3D; s.length() % (2 * k);
        for(int i &#x3D; 0; i &lt; cnt; ++i)
            revStr(i * k * 2, i * k * 2 + k - 1);
        if(unit &gt;&#x3D; k)
            revStr(cnt * k * 2, cnt * k * 2 + k - 1);
        else
            revStr(cnt * k * 2, s.length() - 1);
        return s;
    &#125;
&#125;;</code></pre>



<h3 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05.替换空格"></a>剑指offer 05.替换空格</h3><h4 id="解法-39"><a href="#解法-39" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针、string::resize()函数</strong></p>
<p>先统计空格数量，计算出要扩充的空间（cnt * 2）。</p>
<p>扩充之后使用双指针分别指向原字符串的末尾和现在的末尾，将原来的依次填入，碰到空格填入”%20”即可。</p>
<p><code>resize(size_t n, char c)</code></p>
<p>c为可选参数，表示扩充后的位置填入的字符。</p>
<p>n为扩充后的字符串长度。若n小于原长，删除 [0, n) 范围外的所有字符；若n大于原长，有c填入c，无c参数填入null。</p>
<h4 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string replaceSpace(string s) &#123;
        int cnt &#x3D; 0;
        for(char c : s)
            cnt +&#x3D; c &#x3D;&#x3D; &#39; &#39;;
        int l &#x3D; s.length() - 1;
        s.resize(s.length() + cnt * 2);
        int r &#x3D; s.length() - 1;
        while(l &gt;&#x3D; 0)&#123;
            if(s[l] !&#x3D; &#39; &#39;)	s[r--] &#x3D; s[l];
            else&#123;
                s[r--] &#x3D; &#39;0&#39;;
                s[r--] &#x3D; &#39;2&#39;;
                s[r--] &#x3D; &#39;%&#39;;
            &#125;
            l--;
        &#125;
        return s;
    &#125;
&#125;;</code></pre>



<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h3><h4 id="题干-25"><a href="#题干-25" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串 s ，请你反转字符串中 <strong>单词</strong> 的顺序。<strong>单词</strong> 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。返回 单词 <strong>顺序颠倒</strong>且 单词 之间用<strong>单个空格</strong>连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：s &#x3D; &quot;the sky is blue&quot;
输出：&quot;blue is sky the&quot;</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：s &#x3D; &quot;a good   example&quot;
输出：&quot;example good a&quot;</code></pre>

<h4 id="解法-40"><a href="#解法-40" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>整体思路就是先处理掉多余空格，然后整体反转字符串，此时单词也是反的，再反转回来即可。</p>
<h4 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string reverseWords(string s) &#123;
        int cnt &#x3D; 0;
        for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123;
            &#x2F;&#x2F; 只处理有字符的（每个单词的第一个字符）
            if(s[i] !&#x3D; &#39; &#39;)&#123;	
                &#x2F;&#x2F; 如果已经有单词填入了，那这时候进来说明找到下一个个词了，需用空格隔开
                if(cnt !&#x3D; 0)   s[cnt++] &#x3D; &#39; &#39;;			
                while(i &lt; s.length() &amp;&amp; s[i] !&#x3D; &#39; &#39;)	&#x2F;&#x2F; 双指针cnt和i，cnt是修改后的字符位置
                    s[cnt++] &#x3D; s[i++];					&#x2F;&#x2F; 把一个完整单词填入
            &#125;
        &#125;
        s.resize(cnt);						&#x2F;&#x2F; 重置长度
        auto revStr &#x3D; [&amp;s](int l, int r)&#123;	&#x2F;&#x2F; 反转函数
            while(l &lt; r)
                swap(s[l++], s[r--]);
        &#125;;
        revStr(0, s.length() - 1);			&#x2F;&#x2F; 先整体反转
        int start &#x3D; 0;
        for(int i &#x3D; 0; i &lt;&#x3D; s.length(); ++i)&#123;
            if(s[i] &#x3D;&#x3D; &#39; &#39; || i &#x3D;&#x3D; s.length())&#123;			&#x2F;&#x2F; 最后一个单词后没有空格，因此要多加一个判定条件
                revStr(start, i - 1);		&#x2F;&#x2F; 把每个单词再单独反转回来
                start &#x3D; i + 1;
            &#125;
        &#125;
        return s;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-24"><a href="#2023-4-24" class="headerlink" title="2023.4.24"></a>2023.4.24</h2><h3 id="1163-按字典序排在最后的子串"><a href="#1163-按字典序排在最后的子串" class="headerlink" title="1163.按字典序排在最后的子串"></a>1163.按字典序排在最后的子串</h3><h4 id="题干-26"><a href="#题干-26" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串 <code>s</code> ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：s &#x3D; &quot;abab&quot;
输出：&quot;bab&quot;</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：s &#x3D; &quot;leetcode&quot;
输出：&quot;tcode&quot;</code></pre>

<h4 id="解法-41"><a href="#解法-41" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>首先要明白如何判断是排最后的：<strong>字母越大越靠后</strong>、<strong>子串末尾一定是s末尾</strong>（假如存在非后缀的子串，那么再往后延伸一个字符一定更大）。</p>
<p>维护快慢指针slow和fast，slow表示当前最大的子串，fast向后遍历找有无更大的子串。</p>
<p>因为双指针指向两个子串的头部，因此如果判断相同位置字符相同时，往后移动判断需要另维护一个idx变量。</p>
<h4 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string lastSubstring(string s) &#123;
        int slow &#x3D; 0, fast &#x3D; 1, idx &#x3D; 0;
        while(fast + idx &lt; s.length())&#123;
            if(s[slow + idx] &#x3D;&#x3D; s[fast + idx])&#123;
                ++idx;
            &#125;
            else if(s[slow + idx] &lt; s[fast + idx])&#123;
                slow +&#x3D; idx + 1;
                idx &#x3D; 0;
                if(slow &gt;&#x3D; fast)
                    fast &#x3D; slow + 1;
            &#125;
            else&#123;
                fast +&#x3D; idx + 1;
                idx &#x3D; 0;
            &#125;
        &#125;
        return s.substr(slow);
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-25"><a href="#2023-4-25" class="headerlink" title="2023.4.25"></a>2023.4.25</h2><h3 id="2418-按身高排序"><a href="#2418-按身高排序" class="headerlink" title="2418.按身高排序"></a>2418.按身高排序</h3><h4 id="解法-42"><a href="#解法-42" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>排序</strong></p>
<h4 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;string&gt; sortPeople(vector&lt;string&gt;&amp; names, vector&lt;int&gt;&amp; heights) &#123;
        int n &#x3D; heights.size();
        vector&lt;int&gt; idx(n);
        for(int i &#x3D; 0; i &lt; n; ++i)
            idx[i] &#x3D; i;
        sort(idx.begin(), idx.end(), [&amp;heights](int i, int j)&#123;return heights[i] &gt; heights[j];&#125;);
        vector&lt;string&gt; res;
        for(int i : idx)
            res.push_back(names[i]);
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-4-26"><a href="#2023-4-26" class="headerlink" title="2023.4.26"></a>2023.4.26</h2><h3 id="剑指offer-58-Ⅱ-左旋转字符串"><a href="#剑指offer-58-Ⅱ-左旋转字符串" class="headerlink" title="剑指offer 58.Ⅱ 左旋转字符串"></a>剑指offer 58.Ⅱ 左旋转字符串</h3><h4 id="解法-43"><a href="#解法-43" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>双指针</strong></p>
<p>在344.反转字符串的基础上，做多次反转。</p>
<h4 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string reverseLeftWords(string s, int n) &#123;
        auto revStr &#x3D; [&amp;s](int l, int r)&#123;	
            while(l &lt; r)
                swap(s[l++], s[r--]);
        &#125;;
        revStr(0, n - 1);
        revStr(n, s.length() - 1);
        revStr(0, s.length() - 1);
        return s;
    &#125;
&#125;;</code></pre>



<h3 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28.找出字符串中第一个匹配项的下标"></a>28.找出字符串中第一个匹配项的下标</h3><h4 id="题干-27"><a href="#题干-27" class="headerlink" title="题干"></a>题干</h4><p>给你两个字符串 <strong>haystack</strong> 和 <strong>needle</strong> ，请你在 <strong>haystack</strong> 字符串中找出 <strong>needle</strong> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  <strong>-1</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：haystack &#x3D; &quot;sadbutsad&quot;, needle &#x3D; &quot;sad&quot;
输出：0</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：haystack &#x3D; &quot;leetcode&quot;, needle &#x3D; &quot;leeto&quot;
输出：-1</code></pre>

<h4 id="解法-44"><a href="#解法-44" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>字符串匹配、KMP</strong></p>
<h4 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; getNextArr(string p)&#123;
        vector&lt;int&gt; next(p.length());
        next[0] &#x3D; -1;
        int k &#x3D; -1, j &#x3D; 0;
        while(j &lt; p.length() - 1)&#123;
            if(k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k])
                next[++j] &#x3D; ++k;
            else
                k &#x3D; next[k];
        &#125;
        return next;
    &#125;

    int kmp(string pattern, string word)&#123;
        int i &#x3D; 0, j &#x3D; 0;
        int pLen &#x3D; pattern.length(), wLen &#x3D; word.length();
        vector&lt;int&gt; next &#x3D; getNextArr(pattern);
        while(i &lt; wLen &amp;&amp; j &lt; pLen)&#123;
            if(j &#x3D;&#x3D; -1 || word[i] &#x3D;&#x3D; pattern[j])&#123;
                ++i;
                ++j;
            &#125;
            else
                j &#x3D; next[j];
            if(j &#x3D;&#x3D; pLen)
                return i - pLen;
        &#125;
        return -1;
    &#125;

    int strStr(string haystack, string needle) &#123;
        return kmp(needle, haystack);
    &#125;
&#125;;</code></pre>



<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h3><h4 id="解法-45"><a href="#解法-45" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>字符串匹配、KMP</strong></p>
<p>对于最小重复子串的理解：</p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/20220728212157.png" alt="图四"></p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/image-20230426205832524.png" alt="image-20230426205832524"></p>
<p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p>
<p>需要注意，如下的前缀表计算方式，存储的值是后移一位的，即next[2]对应的是到下标1（0~1）处的最长相同前后缀，因此在主程序中计算时做了特殊处理。</p>
<h4 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; getNextArr(string p)&#123;
        vector&lt;int&gt; next(p.length());
        next[0] &#x3D; -1;
        int k &#x3D; -1, j &#x3D; 0;
        while(j &lt; p.length() - 1)&#123;
            if(k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k])
                next[++j] &#x3D; ++k;
            else
                k &#x3D; next[k];
        &#125;
        return next;
    &#125;
    bool repeatedSubstringPattern(string s) &#123;
        if(s.size() &#x3D;&#x3D; 0)
            return false;
        vector&lt;int&gt; next &#x3D; getNextArr(s+&#39; &#39;);
        int l &#x3D; next.size();
        return next[l - 1] &gt; 0 &amp;&amp; (l - 1) % (l - 1 - next[l - 1]) &#x3D;&#x3D; 0;
    &#125;
&#125;;</code></pre>



<h1 id="打卡5月LeetCode"><a href="#打卡5月LeetCode" class="headerlink" title="打卡5月LeetCode"></a>打卡5月LeetCode</h1><h2 id="2023-5-3"><a href="#2023-5-3" class="headerlink" title="2023.5.3"></a>2023.5.3</h2><h3 id="1003-检查替换后的词是否有效"><a href="#1003-检查替换后的词是否有效" class="headerlink" title="1003.检查替换后的词是否有效"></a>1003.检查替换后的词是否有效</h3><h4 id="题干-28"><a href="#题干-28" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串 s ，请你判断它是否 <strong>有效</strong> 。<br>字符串 s <strong>有效</strong> 需要满足：假设开始有一个<strong>空</strong>字符串 t = “” ，你可以执行 <strong>任意次</strong> 下述操作将 t 转换为 s ：</p>
<ul>
<li>将字符串 “<strong>abc</strong>“ 插入到 t 中的<strong>任意位置</strong>。形式上，t 变为 tleft + “abc” + tright，其中 t == tleft + tright 。注意，tleft 和 tright 可能为 <strong>空</strong> 。</li>
</ul>
<p>如果字符串 s 有效，则返回 true；否则，返回 false。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：s &#x3D; &quot;abcabcababcc&quot;
输出：true</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：s &#x3D; &quot;abccba&quot;
输出：false</code></pre>

<h4 id="解法-46"><a href="#解法-46" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟、栈</strong></p>
<p>用string模拟栈，出栈用erase。</p>
<p>将源字符串逐个入栈，直到入一个c，会同时消去上两个入的a、b。</p>
<p>如果前两个不是a、b，说明这个c出现的顺序是有问题的，字符串是无效的，直接false了。</p>
<p>如果最后栈空了，说明都消去了，字符串有效。</p>
<h4 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool isValid(string s) &#123;
        if(s.length() % 3 !&#x3D; 0)
            return false;
        string tmp &#x3D; &quot;&quot;;
        for(int i &#x3D; 0; i &lt; s.length(); ++i)&#123;
            tmp +&#x3D; s[i];
            if(tmp.length() &gt; 2 &amp;&amp; s[i] &#x3D;&#x3D; &#39;c&#39;)
                if(tmp.substr(tmp.length() - 3, 3) &#x3D;&#x3D; &quot;abc&quot;)
                    tmp.erase(tmp.end() - 3, tmp.end());
                else
                    return false;
        &#125;
        return tmp.empty();
    &#125;
&#125;;</code></pre>



<h2 id="2023-5-16"><a href="#2023-5-16" class="headerlink" title="2023.5.16"></a>2023.5.16</h2><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><h4 id="解法-47"><a href="#解法-47" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟、栈</strong></p>
<p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p>
<h4 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class MyQueue &#123;
public:
    MyQueue() &#123;&#125;
    void push(int x) &#123;
        In.push(x);
    &#125;
    int pop() &#123;
        if(Out.empty())&#123;
            while(!In.empty())&#123;
                Out.push(In.top());
                In.pop();
            &#125;
        &#125;
        int res &#x3D; Out.top();
        Out.pop();
        return res;
    &#125;
    int peek() &#123;
        if(Out.empty())&#123;
            while(!In.empty())&#123;
                Out.push(In.top());
                In.pop();
            &#125;
        &#125;
        return Out.top();
    &#125;
    bool empty() &#123;
        return In.empty() &amp;&amp; Out.empty();
    &#125;
private:
    stack&lt;int&gt; In;
    stack&lt;int&gt; Out;
&#125;;</code></pre>



<h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h3><h4 id="解法-48"><a href="#解法-48" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟、队列</strong></p>
<p>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</p>
<h4 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class MyStack &#123;
public:
    MyStack() &#123; &#125;
    
    void push(int x) &#123;
        Q.push(x);
    &#125;
    
    int pop() &#123;
        int len &#x3D; Q.size() - 1;
        while(len--)&#123;
            Q.push(Q.front());
            Q.pop();
        &#125;
        int res &#x3D; Q.front();
        Q.pop();
        return res;
    &#125;
    
    int top() &#123;
        return Q.back();
    &#125;
    
    bool empty() &#123;
        return Q.empty();
    &#125;
private:
    queue&lt;int&gt; Q;
&#125;;</code></pre>



<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><h4 id="解法-49"><a href="#解法-49" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>栈</strong></p>
<p>因为右括号消去的必然是一组中最后出现的左括号，因此本质就是后进先出的栈。</p>
<h4 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool isValid(string s) &#123;
        stack&lt;char&gt; st;
        for(char c : s)&#123;
            if(st.empty())	st.push(c);
            else&#123;
                if(c - st.top() &#x3D;&#x3D; 1 || c - st.top() &#x3D;&#x3D; 2)
                    st.pop();
                else
                    st.push(c);
            &#125;
        &#125;
        return st.empty();
    &#125;
&#125;;</code></pre>



<h2 id="2023-5-17"><a href="#2023-5-17" class="headerlink" title="2023.5.17"></a>2023.5.17</h2><h3 id="2446-判断两个事件是否存在冲突"><a href="#2446-判断两个事件是否存在冲突" class="headerlink" title="2446.判断两个事件是否存在冲突"></a>2446.判断两个事件是否存在冲突</h3><h4 id="解法-50"><a href="#解法-50" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>字符串比较</strong></p>
<p>不需要转换成int值，直接字符串比较即可。</p>
<h4 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool haveConflict(vector&lt;string&gt;&amp; event1, vector&lt;string&gt;&amp; event2) &#123;
        return !(event1[0] &gt; event2[1] || event1[1] &lt; event2[0]);
    &#125;
&#125;;</code></pre>



<h2 id="2023-5-18"><a href="#2023-5-18" class="headerlink" title="2023.5.18"></a>2023.5.18</h2><h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h3><h4 id="解法-51"><a href="#解法-51" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟、栈、字符串</strong></p>
<p>依旧是模拟栈LIFO的模式，直接用字符串实现，节约空间和时间。</p>
<h4 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    string removeDuplicates(string s) &#123;
        string res &#x3D; &quot;&quot;;
        for(char c : s)&#123;
            if(res.empty() || res.back() !&#x3D; c)	
                res +&#x3D; c;
            else
                res.pop_back();
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-5-19"><a href="#2023-5-19" class="headerlink" title="2023.5.19"></a>2023.5.19</h2><h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h3><h4 id="题干-29"><a href="#题干-29" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串数组 <strong>tokens</strong> ，表示一个根据 <strong>逆波兰表示法</strong> 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>注意：</p>
<ul>
<li><p>有效的算符为 ‘+’、’-‘、’*’ 和 ‘/‘ 。</p>
</li>
<li><p>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</p>
</li>
<li><p>两个整数之间的除法总是 向零截断 。</p>
</li>
<li><p>表达式中不含除零运算。</p>
</li>
<li><p>输入是一个根据逆波兰表示法表示的算术表达式。</p>
</li>
<li><p>答案及所有中间计算结果可以用 32 位 整数表示。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]
输出：6</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
输出：22</code></pre>

<h4 id="解法-52"><a href="#解法-52" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟、栈</strong></p>
<p>逆波兰表达式（后缀表达式）转常用的中缀表达式，实际就是每找到一个计算符号就将其前两个字符取出来进行符号运算，体现在代码中就是从栈中连取两个数字出来。</p>
<h4 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        stack&lt;int&gt; st;
        for(string s : tokens)&#123;
            if(s &#x3D;&#x3D; &quot;+&quot; || s &#x3D;&#x3D; &quot;-&quot; || s &#x3D;&#x3D; &quot;*&quot; || s &#x3D;&#x3D; &quot;&#x2F;&quot;)&#123;
                int sec &#x3D; st.top();
                st.pop();
                int fir &#x3D; st.top();
                st.pop();
                if(s &#x3D;&#x3D; &quot;+&quot;)    st.push(sec + fir);
                else if (s &#x3D;&#x3D; &quot;-&quot;)  st.push(fir - sec);
                else if (s &#x3D;&#x3D; &quot;*&quot;)  st.push(fir * sec);
                else if (s &#x3D;&#x3D; &quot;&#x2F;&quot;)  st.push(fir &#x2F; sec);
            &#125;
            else
                st.push(stoi(s));
        &#125;
        return st.top();
    &#125;
&#125;;</code></pre>

<p>后缀表达式对于计算机来说更友好，计算机可以利用栈来顺序处理，不需要考虑优先级、不用回退了。</p>
<h2 id="2023-5-26"><a href="#2023-5-26" class="headerlink" title="2023.5.26"></a>2023.5.26</h2><h3 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091.二进制矩阵中的最短路径"></a>1091.二进制矩阵中的最短路径</h3><h4 id="题干-30"><a href="#题干-30" class="headerlink" title="题干"></a>题干</h4><p>给你一个 <strong>n x n</strong> 的二进制矩阵 <strong>grid</strong> 中，返回矩阵中<strong>最短</strong> <strong>畅通路径</strong> 的长度。如果不存在这样的路径，返回 <strong>-1</strong> 。</p>
<p>二进制矩阵中的 <strong>畅通路径</strong> 是一条从 <strong>左上角</strong> 单元格（即，(0, 0)）到 <strong>右下角</strong> 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：</p>
<ul>
<li>路径途经的所有单元格的值都是 <strong>0</strong> 。</li>
<li>路径中所有相邻的单元格应当在 <strong>8</strong> 个方向之一 上<strong>连通</strong>（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li>
</ul>
<p><strong>畅通路径</strong>的<strong>长度</strong> 是该路径途经的<strong>单元格总数</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：grid &#x3D; [[0,0,0],[1,1,0],[1,1,0]]
输出：4</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：grid &#x3D; [[1,0,0],[1,1,0],[1,1,0]]
输出：-1</code></pre>

<h4 id="解法-53"><a href="#解法-53" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>广度优先遍历、队列</strong></p>
<p>首先排除左上角是1的情况。</p>
<p>BFS通常使用队列和标记数组实现，本题中直接在原数组上修改值为1，那么可以同时作为已标记和路径为1 的判断处理。</p>
<p>首先将左上角置1并加入队列。</p>
<p>每轮搜索后，结果都会是路径长度+1（搜索轮数+1）。而使得路径长度+1的节点可能不止一个，也就是8邻域中有不止一个可通行节点，因此需要将这些节点均遍历一遍才能算完成一轮搜索；这些节点的数量就是本轮搜索开始时队列内的元素数。</p>
<p>每次取出队首节点后，若该节点为右下角，直接返回统计的轮数；若不是，则判断其8邻域：若未越界且值为0（可通行且未被标记），则将其加入队列并标记。</p>
<p>若循环结束仍未return，说明无法到达，返回-1。</p>
<h4 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        if(grid[0][0]) return -1;
        int n &#x3D; grid.size() - 1;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push(&#123;0, 0&#125;);
        grid[0][0] &#x3D; 1;
        int res &#x3D; 1;
        while(!q.empty())&#123;
            for(int num &#x3D; q.size(); num; --num)&#123;	&#x2F;&#x2F; 这一层
                pair&lt;int, int&gt; item &#x3D; q.front();
                int x &#x3D; item.first;
                int y &#x3D; item.second;
                q.pop();
                if(x &#x3D;&#x3D; n &amp;&amp; y &#x3D;&#x3D; n)
                    return res;
                for(int row &#x3D; x-1; row &lt;&#x3D; x+1; ++row)&#123;
                    for(int col &#x3D; y-1; col &lt;&#x3D; y+1; ++col)&#123;
                        if(row &lt; 0 || row &gt; n || col &lt; 0 || col &gt; n || grid[row][col])
                            continue;
                        grid[row][col] &#x3D; 1;
                        q.push(&#123;row, col&#125;);
                    &#125;
                &#125;
            &#125;
            res++;
        &#125;
        return -1;
    &#125;
&#125;;</code></pre>



<h1 id="打卡6月LeetCode"><a href="#打卡6月LeetCode" class="headerlink" title="打卡6月LeetCode"></a>打卡6月LeetCode</h1><h2 id="2023-6-5"><a href="#2023-6-5" class="headerlink" title="2023.6.5"></a>2023.6.5</h2><h3 id="2460-对数组执行操作"><a href="#2460-对数组执行操作" class="headerlink" title="2460.对数组执行操作"></a>2460.对数组执行操作</h3><h4 id="解法-54"><a href="#解法-54" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟</strong></p>
<h4 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; applyOperations(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        vector&lt;int&gt; res(n, 0);
        int cnt &#x3D; 0;
        for(int i &#x3D; 0; i &lt; n-1; ++i)&#123;
            if(nums[i] &#x3D;&#x3D; nums[i+1])&#123;
                nums[i] *&#x3D; 2;
                nums[i+1] &#x3D; 0;
            &#125;
            if(nums[i]) res[cnt++] &#x3D; nums[i];
        &#125;
        res[cnt] &#x3D; nums[n - 1];
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><h4 id="题干-31"><a href="#题干-31" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <strong>nums</strong>，有一个大小为 <strong>k</strong> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的<strong>最大值</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3
输出：[3,3,5,5,6,7]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [1], k &#x3D; 1
输出：[1]</code></pre>

<h4 id="解法-55"><a href="#解法-55" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>单调队列、双向队列</strong></p>
<p>维护一个单调的从大到小的双向队列（可以同时操作队首和队尾），<strong>用于存储当次滑动窗口中可能是最大值的数的下标</strong>。</p>
<p>如何维护单调：</p>
<p>每当窗口右移，将新加入的数与队尾下标所在元素比较，更大则将队尾下标出队，继续跟队尾比较，直至队列空或满足单调性质为止，将其入队。</p>
<p>如何获取最大值：</p>
<p>判断队首下标是否在滑动窗口区间内（存储下标而不是值的原因，值可以通过nums数组获取），若不在则出队，继续下一个队首，找到在区间内的第一个队首下标所在值，即为最大值。</p>
<h4 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;
        vector&lt;int&gt; res;
        deque&lt;int&gt; q;
        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;
            while(!q.empty() &amp;&amp; nums[i] &gt;&#x3D; nums[q.back()])
                    q.pop_back();
            q.emplace_back(i);
            if(i &gt; k - 2)&#123;
                while(q.front() &lt;&#x3D; i - k)
                    q.pop_front();
                res.push_back(nums[q.front()]);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="347-前K个高频元素"><a href="#347-前K个高频元素" class="headerlink" title="347.前K个高频元素"></a>347.前K个高频元素</h3><h4 id="题干-32"><a href="#题干-32" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2
输出: [1,2]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [1], k &#x3D; 1
输出：[1]</code></pre>

<h4 id="解法-56"><a href="#解法-56" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>优先队列、堆、哈希</strong></p>
<p>先用哈希表统计每个元素出现的数量，再用优先队列按照出现数从大到小排序，优先队列长度维持在 K （当有元素入队时，队首元素出队，这就要求优先队列为从小到大排序，即小顶堆），最后将队列中剩下的元素记入vector。</p>
<h4 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;
        struct cmp&#123;
            bool operator()(pair&lt;int, int&gt; a,pair&lt;int, int&gt; b)&#123;	return a.second &gt; b.second;	&#125;
        &#125;;
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; q;
        unordered_map&lt;int, int&gt; cnt;
        vector&lt;int&gt; res;
        for(int n : nums)   cnt[n]++;
        for(pair&lt;int, int&gt; p : cnt)&#123;
            q.push(p);
            if(q.size() &gt; k)    q.pop();
        &#125;
        while(!q.empty())&#123;
            res.push_back(q.top().first);
            q.pop();
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-7"><a href="#2023-6-7" class="headerlink" title="2023.6.7"></a>2023.6.7</h2><h3 id="2611-老鼠和奶酪"><a href="#2611-老鼠和奶酪" class="headerlink" title="2611.老鼠和奶酪"></a>2611.老鼠和奶酪</h3><h4 id="题干-33"><a href="#题干-33" class="headerlink" title="题干"></a>题干</h4><p>有两只老鼠和 <strong>n</strong> 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。下标为 <strong>i</strong> 处的奶酪被吃掉的得分为：</p>
<ul>
<li><p>如果第一只老鼠吃掉，则得分为 <strong>reward1[i]</strong> 。</p>
</li>
<li><p>如果第二只老鼠吃掉，则得分为 <strong>reward2[i]</strong> 。</p>
</li>
</ul>
<p>给你一个正整数数组 <strong>reward1</strong> ，一个正整数数组 <strong>reward2</strong> ，和一个非负整数 <strong>k</strong> 。请你返回<strong>第一只</strong>老鼠恰好吃掉 <strong>k</strong> 块奶酪的情况下，<strong>最大</strong> 得分为多少。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：reward1 &#x3D; [1,1,3,4], reward2 &#x3D; [4,4,1,1], k &#x3D; 2
输出：15</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：reward1 &#x3D; [1,1], reward2 &#x3D; [1,1], k &#x3D; 2
输出：2</code></pre>

<h4 id="解法-57"><a href="#解法-57" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>因为要求第一只老鼠吃的数量，那么假设先全被第二只吃了，总得分为 **sum(reward2)**。</p>
<p>当把第 i 块奶酪分给鼠1时，可以发现得分的变化量为 **reward1[i] - reward2[i]**。这意味着要想得到最高得分，分给鼠1的k块奶酪产生的变化量都是越大越好。那么将 **reward1[i] - reward2[i]**按照从大到小排序，数组的前 k 个值加上 sum，就是最大值了。</p>
<p>注：sort排序中，若使用rbegin() 、rend()逆向迭代器，则为从大到小排序。</p>
<h4 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) &#123;
        int res &#x3D; 0;
        for(int i &#x3D; 0; i &lt; reward1.size(); ++i)&#123;
            res +&#x3D; reward2[i];
            reward1[i] -&#x3D; reward2[i];
        &#125;
        sort(reward1.rbegin(), reward1.rend());
        for(int i &#x3D; 0; i &lt; k; ++i)
            res +&#x3D; reward1[i];
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-13"><a href="#2023-6-13" class="headerlink" title="2023.6.13"></a>2023.6.13</h2><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3><h4 id="解法-58"><a href="#解法-58" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归、栈</strong></p>
<h4 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h4><p><strong>递归</strong>：前、中、后序都差不多，无非是<strong>push_back</strong>的位置换了一下。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void travelsal(TreeNode* cur, vector&lt;int&gt;&amp; res) &#123;
        if(cur &#x3D;&#x3D; nullptr) return;
        res.push_back(cur-&gt;val);
        travelsal(cur-&gt;left, res);
        travelsal(cur-&gt;right, res);
    &#125;
    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        travelsal(root, res);
        return res;
    &#125;
&#125;;</code></pre>

<p><strong>迭代：</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; res;
        if(root &#x3D;&#x3D; nullptr) return res;
        st.push(root);
        while(!st.empty())&#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            res.push_back(node-&gt;val);
            if(node-&gt;right) st.push(node-&gt;right);
            if(node-&gt;left) st.push(node-&gt;left);
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3><h4 id="解法-59"><a href="#解法-59" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、栈</strong></p>
<p>中序属于<strong>访问节点（遍历节点）和处理节点（将元素放进结果集）不一致</strong>的情况。</p>
<p>因为中序是左中右的顺序，所以需要先遍历到最左侧的左节点（<strong>没下一个左节点时</strong>），加入结果中。此时该节点为局部根节点（相当于中），然后就访问右节点。（右节点可能存在左节点和右节点，所以跟根节点的遍历一样处理）。</p>
<h4 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur &#x3D; root;
        if(root &#x3D;&#x3D; nullptr) return res;
        while(!st.empty() || cur)&#123;
            if(cur)&#123;
                st.push(cur);
                cur &#x3D; cur-&gt;left;
            &#125;
            else &#123;
                cur &#x3D; st.top();
                st.pop();
                res.push_back(cur-&gt;val);
                cur &#x3D; cur-&gt;right;
            &#125;            
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3><h4 id="解法-60"><a href="#解法-60" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、栈</strong></p>
<p>可以发现，前序是中左右，但是把前序先左后右的顺序反一下，就是中右左。后序是左右中，刚好反过来。</p>
<p>实现相比于中序更加简单。</p>
<h4 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; res;
        if(root &#x3D;&#x3D; nullptr) return res;
        st.push(root);
        while(!st.empty())&#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            res.push_back(node-&gt;val);
            if(node-&gt;left) st.push(node-&gt;left);
            if(node-&gt;right) st.push(node-&gt;right);
        &#125;
        reverse(res.begin(), res.end());
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><h3 id="107-二叉树的层序遍历Ⅱ"><a href="#107-二叉树的层序遍历Ⅱ" class="headerlink" title="107.二叉树的层序遍历Ⅱ"></a>107.二叉树的层序遍历Ⅱ</h3><h4 id="题干-34"><a href="#题干-34" class="headerlink" title="题干"></a>题干</h4><p>1.给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p>2.给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：root &#x3D; [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：root &#x3D; []
输出：[]</code></pre>

<h4 id="解法-61"><a href="#解法-61" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>广度优先、队列</strong></p>
<p>1.如下</p>
<p>2.返回前反转res数组即可。</p>
<h4 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(root &#x3D;&#x3D; nullptr)  return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while(!q.empty())&#123;
            vector&lt;int&gt; layer;
            int n &#x3D; q.size();
            for(int i &#x3D; 0; i &lt; n; ++i)&#123;
                TreeNode* node &#x3D; q.front();
                q.pop();
                layer.push_back(node-&gt;val);
                if(node-&gt;left)  q.push(node-&gt;left);
                if(node-&gt;right)  q.push(node-&gt;right);
            &#125;
            res.push_back(layer);
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-14"><a href="#2023-6-14" class="headerlink" title="2023.6.14"></a>2023.6.14</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><h4 id="解法-62"><a href="#解法-62" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、栈、前序</strong></p>
<p>只需要在前序的时候，先交换节点再往下压栈即可。</p>
<h4 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">res.push_back(node-&gt;val);	&#x2F;&#x2F; old
swap(node-&gt;left, node-&gt;right);	&#x2F;&#x2F; new</code></pre>



<h3 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589.N叉树的前序遍历"></a>589.N叉树的前序遍历</h3><h3 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590.N叉树的后序遍历"></a>590.N叉树的后序遍历</h3><h4 id="解法-63"><a href="#解法-63" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、栈、前序</strong></p>
<ol>
<li>2变N，顺序一样都是前序，那就是从左到右，所以遍历vector压栈时从后往前即可。</li>
<li>对于后序，跟二叉树一样，先把遍历顺序改为从右到左（也就是从前往后遍历vector），最后反转结果数组即可。</li>
</ol>
<h4 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; old
if(node-&gt;right) st.push(node-&gt;right);
if(node-&gt;left) st.push(node-&gt;left);   
&#x2F;&#x2F; new
for(int i &#x3D; nd-&gt;children.size() - 1; i &gt;&#x3D; 0; --i)
    st.push(nd-&gt;children[i]);</code></pre>



<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><h4 id="题干-35"><a href="#题干-35" class="headerlink" title="题干"></a>题干</h4><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入: []
输出: []</code></pre>

<h4 id="解法-64"><a href="#解法-64" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、队列、层序</strong></p>
<p>在层序遍历的过程中，只将每一层最右边的节点（<strong>每层队列的队尾</strong>）加入结果数组即可。</p>
<h4 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">layer.push_back(node-&gt;val);		&#x2F;&#x2F; old
if(i &#x3D;&#x3D; n - 1)  res.push_back(node-&gt;val);	&#x2F;&#x2F; new</code></pre>



<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><h4 id="解法-65"><a href="#解法-65" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、队列、层序</strong></p>
<p>用层序遍历，sum要注意越界问题。</p>
<h4 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">double sum &#x3D; 0;
sum +&#x3D; node-&gt;val;
res.push_back(sum &#x2F; n);</code></pre>



<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><h4 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; old
if(node-&gt;left)  q.push(node-&gt;left);
if(node-&gt;right)  q.push(node-&gt;right);
&#x2F;&#x2F; new
for(auto nd : node-&gt;children)
	q.push(nd);</code></pre>



<h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h3><h4 id="解法-66"><a href="#解法-66" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、队列、层序</strong></p>
<p>每层维护一个最大值即可。</p>
<h4 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">int maxNum &#x3D; INT_MIN;
if(maxNum &lt; node-&gt;val) maxNum &#x3D; node-&gt;val;</code></pre>



<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h3><h3 id="117-填充每个节点的下一个右侧节点指针-Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针-Ⅱ" class="headerlink" title="117.填充每个节点的下一个右侧节点指针 Ⅱ"></a>117.填充每个节点的下一个右侧节点指针 Ⅱ</h3><h4 id="题干-36"><a href="#题干-36" class="headerlink" title="题干"></a>题干</h4><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;</code></pre>

<p>填充它的每个 <strong>next</strong> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <strong>next</strong> 指针设置为 <strong>NULL</strong>。</p>
<p>初始状态下，所有 <strong>next</strong> 指针都被设置为 <strong>NULL</strong>。</p>
<h4 id="解法-67"><a href="#解法-67" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、队列、层序</strong></p>
<p>在层序遍历中，维护一个Node*指针，指向每层上一个节点，将其next指针赋为当前指针。</p>
<p>每层n个节点，需要设置的为 <strong>[0, n - 2]</strong> ，因此可以用 <strong>[1, n - 1]</strong> 的节点来设置上一个。</p>
<p>两题一样的代码。</p>
<h4 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Node* pre &#x3D; NULL;
if(pre) pre-&gt;next &#x3D; node;
pre &#x3D; node;</code></pre>



<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><h4 id="解法-68"><a href="#解法-68" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、队列、层序</strong></p>
<p>计数层序遍历一共遍历了多少层即可。</p>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><h4 id="解法-69"><a href="#解法-69" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、队列、层序</strong></p>
<p>计数层序遍历的层数。维护一个标志位，当某层出现叶子节点时，直接break循环返回计数值即可。</p>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><h4 id="解法-70"><a href="#解法-70" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>迭代、队列；递归</strong></p>
<p>迭代和递归的思路都是一样的，这里遍历不需要去考虑用前中后和层序哪种遍历，是独有的，但可以参考层序中队列的用法。</p>
<p>1.通过队列存储一对需要比较的节点（<strong>左子树和右子树的内侧、外侧</strong>）。因为存储的节点是对应的，那么它们的<strong>下一层采用相同的方式存储后，取出的两个节点依旧是对应的</strong>，这是循环的必要条件。</p>
<p>2.每次出队两个节点，设立判定条件：</p>
<ul>
<li>若两个节点<strong>均为空</strong>，进入下一对节点判断</li>
<li>若只有<strong>一个空</strong>或都不空但<strong>不相等</strong>，直接return false</li>
<li>若循环<strong>结束</strong>了，那么就是遍历完了所有都没出问题，return true</li>
</ul>
<p>递归也是一样的思路：</p>
<p>1.先<strong>确立递归函数的参数和返回值</strong>：左右子节点，bool。</p>
<p>2.确定<strong>中止条件</strong>：同上2</p>
<p>3.确定<strong>单层递归的逻辑</strong>：顺序也和迭代一样</p>
<ul>
<li>先取一对节点（递归省略了这个过程）</li>
<li>判定条件（这里和迭代不同的点在于条件1直接返回了true，这是因为会调用多次递归函数，直接返回true表示这条路径走到头了都没有问题）</li>
<li>最后的总return要综合一对节点下的两对节点的判断情况（递归了）作为结果。</li>
</ul>
<h4 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 迭代
class Solution &#123;
public:
    bool isSymmetric(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; q;
        q.push(root-&gt;left);
        q.push(root-&gt;right);
        while(!q.empty()) &#123;
            TreeNode* ln &#x3D; q.front();	q.pop();
            TreeNode* rn &#x3D; q.front();	q.pop();
            if(!ln &amp;&amp; !rn) continue;
            if(!ln || !rn || (ln-&gt;val !&#x3D; rn-&gt;val))  return false;
            q.push(ln-&gt;left);
            q.push(rn-&gt;right);
            q.push(ln-&gt;right);
            q.push(rn-&gt;left);
        &#125;
        return true;
    &#125;
&#125;;</code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 递归
class Solution &#123;
public:
    bool recursion(TreeNode* left, TreeNode* right) &#123;
        if(!left &amp;&amp; !right) return true;
        if(!left || !right || (left-&gt;val !&#x3D; right-&gt;val))  return false;
        return recursion(left-&gt;left, right-&gt;right) &amp;&amp; recursion(left-&gt;right, right-&gt;left);
    &#125;
    bool isSymmetric(TreeNode* root) &#123;
        return recursion(root-&gt;left, root-&gt;right);
    &#125;
&#125;;</code></pre>

<h4 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h4><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h3><p>解法和上述相同，甚至题目本身提供的函数就是一个递归函数的样子，直接写递归即可。</p>
<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572.另一个树的子树"></a>572.另一个树的子树</h3><p>在100.相同的树的基础上，以自身为递归函数再实现一个dfs即可。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool isSameTree(TreeNode* p, TreeNode* q) &#123;
        if(!p &amp;&amp; !q)    return true;
        if(!p || !q || (p-&gt;val !&#x3D; q-&gt;val))  return false;
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    &#125;
    bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;
        return root &amp;&amp; (isSameTree(root, subRoot) || isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot));
    &#125;
&#125;;</code></pre>



<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><h4 id="题干-37"><a href="#题干-37" class="headerlink" title="题干"></a>题干</h4><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <strong>root</strong> ，求出该树的<strong>节点个数</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：root &#x3D; [1,2,3,4,5,6]
输出：6</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入: []
输出: 0</code></pre>

<h4 id="解法-71"><a href="#解法-71" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>后序（递归）、层序（迭代）</strong></p>
<ol>
<li>最容易想到的解法就是<strong>层序遍历</strong>，得到深度h后，前 <strong>h - 1</strong> 就是满二叉树直接计算节点数，再加上最后一层队列中的元素数量即可。</li>
<li>另一种简单的写法就是<strong>后续遍历</strong>，用迭代的方式遍历一遍。</li>
<li>最后就是利用完全二叉树叶子节点均靠左的特性，<strong>仅遍历部分节点</strong>即可：分别向左节点的左侧和右节点的右侧向下遍历，来判断当前子树是否为满二叉树，直至找到一个满二叉子树时，结束递归（依旧是方法2的思路），返回该子树的节点数（直接计算可得）。</li>
</ol>
<h4 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h4><p><strong>方法2</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int countNodes(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; NULL) return 0;
        &#x2F;&#x2F; 这里求了左子树的节点数 + 右子树节点数 + 中间节点数（1），实际是一个后序遍历过程
        return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);	
    &#125;
&#125;;</code></pre>

<p><strong>方法3</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int calcDepth(TreeNode* cur, bool isLeft) &#123;
        int cnt &#x3D; 0;
        while(cur) &#123;
            cur &#x3D; isLeft ? cur-&gt;left : cur-&gt;right;
            ++cnt;
        &#125;
        return cnt;
    &#125;
    int countNodes(TreeNode* root) &#123;
        if(root &#x3D;&#x3D; nullptr) return 0;
        int lchildDep &#x3D; calcDepth(root-&gt;left, true);
        int rchildDep &#x3D; calcDepth(root-&gt;right, false);
        if(lchildDep &#x3D;&#x3D; rchildDep)
            return (2 &lt;&lt; lchildDep) - 1;
        return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
    &#125;
&#125;;</code></pre>



<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><h4 id="题干-38"><a href="#题干-38" class="headerlink" title="题干"></a>题干</h4><p><strong>平衡二叉树</strong>定义为：一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
<h4 id="解法-72"><a href="#解法-72" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>后序（递归）</strong></p>
<p><strong>凡是求高度的，都是后序遍历；求深度的，都是前序遍历。</strong></p>
<p>理论上，<strong>层序遍历</strong>都可实现，但是效率较低，尤其涉及回溯问题，不如迭代效果好。</p>
<h4 id="代码-71"><a href="#代码-71" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int treeHeight(TreeNode* cur) &#123;
        if(cur &#x3D;&#x3D; nullptr)  return 0;
        int lheight &#x3D; treeHeight(cur-&gt;left);
        if(lheight &#x3D;&#x3D; -1)   return -1;
        int rheight &#x3D; treeHeight(cur-&gt;right);
        if(rheight &#x3D;&#x3D; -1)   return -1;
        return abs(lheight - rheight) &gt; 1 ? -1 : max(lheight, rheight) + 1;
    &#125;
    bool isBalanced(TreeNode* root) &#123;
        return treeHeight(root) !&#x3D; -1;
    &#125;
&#125;;</code></pre>



<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h3><h4 id="题干-39"><a href="#题干-39" class="headerlink" title="题干"></a>题干</h4><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：root &#x3D; [1,2,3,null,5]
输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：root &#x3D; [1]
输出：[&quot;1&quot;]</code></pre>

<h4 id="解法-73"><a href="#解法-73" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>前序（递归）、回溯</strong></p>
<p>从根节点到叶子节点，自然用到了<strong>前序遍历</strong>：中左右的顺序——递归中先判断当前节点的终止条件，再进入左右子节点递归。</p>
<p>递归参数：除了节点指针，最后<strong>记录完整路径</strong>的数组（res），还需要一个用于回溯的数组（path），记录从根节点到当前节点经过的节点（记录值方便加入res）。当到达叶子节点后，需要数组回退一位，拐入父节点的另一个子节点（如果存在）。</p>
<p>终止条件：遇到叶子节点（左右子节点均为空），将回溯数组中经过的节点打印为字符串，加入res。</p>
<p>单层逻辑：回溯数组的压入和弹出。</p>
<h4 id="代码-72"><a href="#代码-72" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; res) &#123;
        path.push_back(cur-&gt;val);
        if(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;
            string pth &#x3D; &quot;&quot;;
            for(int i &#x3D; 0; i &lt; path.size() - 1; ++i)
                pth +&#x3D; to_string(path[i]) + &quot;-&gt;&quot;;
            pth +&#x3D; to_string(path[path.size() - 1]);
            res.push_back(pth);
            return;
        &#125;
        if(cur-&gt;left) &#123;
            traversal(cur-&gt;left, path, res);
            path.pop_back();
        &#125;
        if(cur-&gt;right) &#123;
            traversal(cur-&gt;right, path, res);
            path.pop_back();
        &#125;
    &#125;
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; res;
        vector&lt;int&gt; path;
        traversal(root, path, res);
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-15"><a href="#2023-6-15" class="headerlink" title="2023.6.15"></a>2023.6.15</h2><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h3><h4 id="解法-74"><a href="#解法-74" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>后序（递归）</strong></p>
<p>因为遍历的是叶子节点，所以用后序。终止条件为左叶子节点（判定条件需要在父节点上进行）。</p>
<h4 id="代码-73"><a href="#代码-73" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        if(!root || !root-&gt;left &amp;&amp; !root-&gt;right)  return 0;			&#x2F;&#x2F; 终止条件
        int lLeaf &#x3D; sumOfLeftLeaves(root-&gt;left);					&#x2F;&#x2F; 左
        if(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)	&#x2F;&#x2F; 返回值是0不能直接递归，要把值取出来
            lLeaf &#x3D; root-&gt;left-&gt;val;
        return lLeaf + sumOfLeftLeaves(root-&gt;right);				&#x2F;&#x2F; 右 -&gt; 中
    &#125;
&#125;;</code></pre>



<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h3><h4 id="题干-40"><a href="#题干-40" class="headerlink" title="题干"></a>题干</h4><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<h4 id="解法-75"><a href="#解法-75" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>层序（迭代）</strong></p>
<p>在计算深度的同时，找最左侧的节点，很容易想到层序的队列，更加方便。</p>
<h4 id="代码-74"><a href="#代码-74" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">res &#x3D; q.front()-&gt;val;	&#x2F;&#x2F; 在每次进入下一层时取队首值即可</code></pre>



<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h3><h4 id="题干-41"><a href="#题干-41" class="headerlink" title="题干"></a>题干</h4><p>给你二叉树的根节点 <strong>root</strong> 和一个表示目标和的整数 <strong>targetSum</strong> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <strong>targetSum</strong> 。如果存在，返回 <strong>true</strong> ；否则，返回 <strong>false</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22
输出：true</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：root &#x3D; [], targetSum &#x3D; 0
输出：false</code></pre>

<h4 id="解法-76"><a href="#解法-76" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>前序（递归）、回溯</strong></p>
<p>参考<strong>257.二叉树的所有路径</strong>，在其基础上计算一个和。不同的是，用于回溯的数组可以直接用这个和来代替。</p>
<p>递归参数：节点指针，<strong>去掉当前节点后</strong>的目标和（计算求和并不好处理，需要额外开辟变量，可以用当前和减去当前值，直接利用输入参数处理）</p>
<p>终止条件：遇到叶子节点（左右子节点均为空），且 <strong>当前剩余目标和被减到0</strong> 时，返回 true</p>
<p>单层逻辑：分别向左右子节点递归，有一个返回true就是true。</p>
<p><strong>回溯：</strong></p>
<p>代码中的回溯表现不明显，实际上当我们使用 <strong>去掉当前节点后</strong>的目标和 时，回溯表现在：当前叶子节点不是正确路径时，需要退回父节点进入其另一个子节点，此时 <strong>targetSum</strong>需要回溯至上一个状态（加回当前节点值）。</p>
<p>而这里直接将 <strong>targetSum - root-&gt;val</strong> 输入递归函数，省去了这一加减过程，从一个节点退出来可以直接进入另一个。d熬制在递归中不能直接减去当前值  <strong>targetSum - root-&gt;val</strong> 后判断是否等于0，而是直接判断两者是否相等，更加省事儿。</p>
<h4 id="代码-75"><a href="#代码-75" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool hasPathSum(TreeNode* root, int targetSum) &#123;
        if(root &#x3D;&#x3D; nullptr) return false;
        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; root-&gt;val)
            return true;
        return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);
    &#125;
&#125;;</code></pre>



<h3 id="113-路径总和-Ⅱ"><a href="#113-路径总和-Ⅱ" class="headerlink" title="113.路径总和 Ⅱ"></a>113.路径总和 Ⅱ</h3><h4 id="题干-42"><a href="#题干-42" class="headerlink" title="题干"></a>题干</h4><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22
输出：[[5,4,11,2],[5,8,4,5]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：root &#x3D; [], targetSum &#x3D; 1
输出：[]</code></pre>

<h4 id="解法-77"><a href="#解法-77" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>前序（递归）、回溯</strong></p>
<p>这题纯是<strong>257.二叉树的所有路径</strong> 和<strong>112.路径总和</strong>的结合体，因为要找到所有的路径而不是判断有没有，就不能只用sum作为回溯条件了，需要开数组存路径。</p>
<h4 id="代码-76"><a href="#代码-76" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void traversal(TreeNode* cur, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;
        path.push_back(cur-&gt;val);
        if(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; cur-&gt;val &#x3D;&#x3D; targetSum) &#123;
            res.push_back(path);
            return;
        &#125;
        if(cur-&gt;left) &#123;
            traversal(cur-&gt;left, targetSum - cur-&gt;val, res, path);
            path.pop_back();		&#x2F;&#x2F; 回溯
        &#125;
        if(cur-&gt;right) &#123;
            traversal(cur-&gt;right, targetSum - cur-&gt;val, res, path);
            path.pop_back();
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(root &#x3D;&#x3D; nullptr) return res;
        vector&lt;int&gt; path;
        traversal(root, targetSum, res, path);
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="106-从中序和后序遍历序列构造二叉树"><a href="#106-从中序和后序遍历序列构造二叉树" class="headerlink" title="106.从中序和后序遍历序列构造二叉树"></a>106.从中序和后序遍历序列构造二叉树</h3><h4 id="题干-43"><a href="#题干-43" class="headerlink" title="题干"></a>题干</h4><p>给定两个整数数组 <strong>inorder</strong> 和 <strong>postorder</strong> ，其中 <strong>inorder</strong> 是二叉树的<strong>中序</strong>遍历， <strong>postorder</strong> 是同一棵树的<strong>后序</strong>遍历，请你构造并返回这颗 <strong>二叉树</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：inorder &#x3D; [-1], postorder &#x3D; [-1]
输出：[-1]</code></pre>

<h4 id="解法-78"><a href="#解法-78" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归</strong></p>
<p>根据中序和后序来构造二叉树，分为如下几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 </li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组（切割后的两个数组长度依旧和中序的相等）</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<p>确定参数：在代码随想录中，切割数组后新开辟了数组来存储子数组，但这样较为浪费空间，实际只需要传入原数组和每次分割时的下标即可。又因为任意子树的中序和后序数组长度均相等，最后仅需五个参数用于递归即可（后序采用<strong>尾部下标</strong>是为了便于取当前子树根节点的值）</p>
<p>终止条件：传入的数组长度为0（<strong>len == 0</strong>）说明节点为空；为1表示该节点是叶子节点，没有子节点了，直接返回。</p>
<p>单层逻辑：计算当前节点在中序数组中的位置，以此为凭分割中序数组（分割为两个子树），再分割后序数组，分别传入数组下标构造子树，开始递归。</p>
<p>在分割数组时，始终遵从<strong>左闭右开</strong>原则。</p>
<h4 id="代码-77"><a href="#代码-77" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* buildChild(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int inHead, int postTail, int len) &#123;
        if(len &#x3D;&#x3D; 0)    return nullptr;
        TreeNode* node &#x3D; new TreeNode(postorder[postTail]);
        if(len &#x3D;&#x3D; 1)    return node;
        int seg;
        for(seg &#x3D; inHead; seg &lt; inHead + len; ++seg) 
            if(inorder[seg] &#x3D;&#x3D; node-&gt;val)
                break;
        int rightLen &#x3D; inHead + len - seg - 1;
        node-&gt;left &#x3D; buildChild(inorder, postorder, inHead, postTail - rightLen - 1, seg - inHead);
        node-&gt;right &#x3D; buildChild(inorder, postorder, seg + 1, postTail - 1, rightLen);
        return node;
    &#125;
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        return buildChild(inorder, postorder, 0, postorder.size() - 1, postorder.size());
    &#125;
&#125;;</code></pre>

<h4 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h4><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><h4 id="解法-79"><a href="#解法-79" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归</strong></p>
<p>和106一样的，就是前序是从序列头部取值作为当前节点值。</p>
<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h3><h4 id="题干-44"><a href="#题干-44" class="headerlink" title="题干"></a>题干</h4><p>给定一个<strong>不重复</strong>的整数数组 <strong>nums</strong> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <strong>nums</strong> 递归地构建:</p>
<ul>
<li><p>创建一个根节点，其值为 <strong>nums</strong> 中的最大值。</p>
</li>
<li><p>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</p>
</li>
<li><p>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</p>
</li>
</ul>
<p>返回 <strong>nums</strong> 构建的 <strong>最大</strong>二叉树 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入：nums &#x3D; [3,2,1]
输出：[3,null,2,null,1]</code></pre>

<h4 id="解法-80"><a href="#解法-80" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归</strong></p>
<p>递归思路同上，但是简化了操作，仅从一个数组中构建，也就少了一个参数。</p>
<h4 id="代码-78"><a href="#代码-78" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* buildChild(vector&lt;int&gt;&amp; nums, int head, int len) &#123;
        if(len &#x3D;&#x3D; 0)    return nullptr;
        int idx &#x3D; head + 1, maxIdx &#x3D; head;
        for(; idx &lt; head + len; ++idx) 
            if(nums[idx] &gt; nums[maxIdx])
                maxIdx &#x3D; idx;
        TreeNode* node &#x3D; new TreeNode(nums[maxIdx]);
        node-&gt;left &#x3D; buildChild(nums, head, maxIdx - head);
        node-&gt;right &#x3D; buildChild(nums, maxIdx + 1, len - (maxIdx - head) - 1);
        return node;
    &#125;
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;
        return buildChild(nums, 0, nums.size());
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-18"><a href="#2023-6-18" class="headerlink" title="2023.6.18"></a>2023.6.18</h2><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><h4 id="解法-81"><a href="#解法-81" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>前序（递归）</strong></p>
<p>遍历两棵树和一棵树都一样，哪种遍历应该都可以，例如前序就遵从中左右的方式。</p>
<p>确立终止条件：<strong>两个节点有一个为空就直接返回另一个</strong>（另一个也空正好返回nullptr）。</p>
<h4 id="代码-79"><a href="#代码-79" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;
        if(root1 &#x3D;&#x3D; nullptr)    return root2;
        if(root2 &#x3D;&#x3D; nullptr)    return root1;
        root1-&gt;val +&#x3D; root2-&gt;val;
        root1-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left);
        root1-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right);
        return root1;
    &#125;
&#125;;</code></pre>



<h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h3><h4 id="解法-82"><a href="#解法-82" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归、BST</strong></p>
<p>类似二分查找，做一个递归即可。</p>
<h4 id="代码-80"><a href="#代码-80" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        if(root &#x3D;&#x3D; nullptr || root-&gt;val &#x3D;&#x3D; val)    
            return root;
        else if(root-&gt;val &lt; val)     
            return searchBST(root-&gt;right, val);
        else
            return searchBST(root-&gt;left, val);
        return nullptr;
    &#125;
&#125;;</code></pre>



<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><h4 id="题干-45"><a href="#题干-45" class="headerlink" title="题干"></a>题干</h4><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个<strong>有效</strong>的二叉搜索树。</p>
<h4 id="解法-83"><a href="#解法-83" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>中序、递归、BST</strong></p>
<p>在BST中，通过中序遍历得到的数组必然是有序的，可以以此来判断。递归时记录上一个节点的指针，用于比较。</p>
<h4 id="代码-81"><a href="#代码-81" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
private:
    TreeNode* pre &#x3D; nullptr;
public:
    bool isValidBST(TreeNode* root) &#123;
        if(root &#x3D;&#x3D; nullptr) return true;
        bool left &#x3D; isValidBST(root-&gt;left);
        if(pre &amp;&amp; pre-&gt;val &gt;&#x3D; root-&gt;val)    
            return false;
        pre &#x3D; root;
        bool right &#x3D; isValidBST(root-&gt;right);
        return left &amp;&amp; right;
    &#125;
&#125;;</code></pre>



<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h3><h4 id="题干-46"><a href="#题干-46" class="headerlink" title="题干"></a>题干</h4><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小绝对差值</strong> 。</p>
<h4 id="解法-84"><a href="#解法-84" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>中序、递归、BST</strong></p>
<p>思路和上题98一致，只是比较大小改为了计算差值。</p>
<p>这里需要注意递归的第一步是确定递归参数，因为主函数要返回int，和void简单递归相比较为麻烦，因此不直接用主函数递归。</p>
<h4 id="代码-82"><a href="#代码-82" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
private:
    int minSub &#x3D; INT_MAX; 
    TreeNode* pre &#x3D; nullptr;
public:
    void traversal(TreeNode* cur) &#123;
        if(cur &#x3D;&#x3D; nullptr)  return;
        traversal(cur-&gt;left);
        if(pre) minSub &#x3D; min(minSub, cur-&gt;val - pre-&gt;val);
        pre &#x3D; cur;
        traversal(cur-&gt;right);
    &#125;
    int getMinimumDifference(TreeNode* root) &#123;
        traversal(root);
        return minSub;
    &#125;
&#125;;</code></pre>



<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h3><h4 id="题干-47"><a href="#题干-47" class="headerlink" title="题干"></a>题干</h4><p>给你一个<strong>含重复值</strong>的二叉搜索树（BST）的根节点 <strong>root</strong> ，找出并返回 BST 中的所有 <strong>众数</strong>（即，<strong>出现频率最高的元素</strong>）。</p>
<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>
<h4 id="解法-85"><a href="#解法-85" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>中序、递归、BST</strong></p>
<p>依旧承接上两题98、530的思路，中间操作改为了维护众数数组。</p>
<h4 id="代码-83"><a href="#代码-83" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
private:
    TreeNode* pre &#x3D; nullptr;
    int cnt &#x3D; 0, maxNum &#x3D; 0;
public:
    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; res) &#123;
        if(cur &#x3D;&#x3D; nullptr)  return;
        traversal(cur-&gt;left, res);
        if(pre &#x3D;&#x3D; nullptr)  cnt &#x3D; 1;
        else if(pre-&gt;val &#x3D;&#x3D; cur-&gt;val)   ++cnt;
        else    cnt &#x3D; 1;
        pre &#x3D; cur;
        if(cnt &#x3D;&#x3D; maxNum)   res.push_back(cur-&gt;val);
        else if (cnt &gt; maxNum) &#123;
            maxNum &#x3D; cnt;
            res.clear();
            res.push_back(cur-&gt;val);
        &#125;
        traversal(cur-&gt;right, res);
    &#125;
    vector&lt;int&gt; findMode(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        traversal(root, res);
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h3><h4 id="题干-48"><a href="#题干-48" class="headerlink" title="题干"></a>题干</h4><p>最近公共祖先定义为：<strong>对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大</strong>（一个节点也可以是它自己的祖先）。</p>
<h4 id="解法-86"><a href="#解法-86" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>后序、递归</strong></p>
<p>最大深度——&gt;高度尽可能低——&gt;从下往上（后序）。</p>
<p><strong>确定递归参数</strong>：可以直接使用主函数。</p>
<p><strong>确定终止条件</strong>：这里需要和单层逻辑一起思考，遇到p、q就返回的作用是什么？</p>
<p><strong>单层递归逻辑</strong>：</p>
<p>回溯的最开始就是深入到了最左叶子节点，此时<strong>递归往下时左右均为空，返回NULL</strong>（状态1）；那么该叶节点的父节点得到的左节点递归返回值就是NULL；同理右节点也是如此；也就是父节点也处于状态1，返回NULL；也就是说一路向上回溯时，只有找到p、q，返回值才不为空。</p>
<p>假设找到了 <strong>q</strong>，此时 <strong>q</strong>的父节点接到的其中一个子节点不为NULL了，又延伸出了两种情况：</p>
<ol>
<li>另一个子节点是 <strong>p</strong>，那么最近公共祖先就是该节点，单层逻辑的第一步：左右都不空，直接返回当前递归中的root节点。</li>
<li><strong>p</strong>还在上面，此时为单层逻辑的另一步：有一个子节点不空，就返回这个不空的节点。</li>
</ol>
<p>注意这里返回只是传递给了上层递归的left和right。那么接着往下走，还是两种情况：</p>
<ol>
<li>对于1，公共祖先已经找到了，那么对于整棵树的根节点，也就是第一层递归来说，拿到的必然是一个子节点空一个不空的递归结果，最后顺利返回不空的那个节点，就是一路传上来的root。</li>
<li>对于2，在往上的过程中，找到了 <strong>p</strong>，那么p的父节点此时得到了两个非空返回值，那么就等同于情况1了，返回当前这个root，也就是最近公共祖先了。</li>
</ol>
<p>上述情况均为p、q在不同分支上时。若p、q在同一分支时，应取两者高度高的为最近公共祖先。这也是要把 <strong>当前节点 == p、q</strong>设为终止条件的原因：若处于同一分支，在找到的一开始可以跳过再往这个分支下遍历的动作，因为已经找到了祖先。那么回到第一层递归时，也<strong>只有一个分支</strong>返回非空，也就返回了正确的公共祖先。</p>
<h4 id="代码-84"><a href="#代码-84" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(root &#x3D;&#x3D; p || root &#x3D;&#x3D; q || root &#x3D;&#x3D; NULL)    return root;
        TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);
        if(left &amp;&amp; right)   return root;
        if(left &#x3D;&#x3D; NULL)    return right;
        return left;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-19"><a href="#2023-6-19" class="headerlink" title="2023.6.19"></a>2023.6.19</h2><h3 id="235-二叉搜索树的公共祖先"><a href="#235-二叉搜索树的公共祖先" class="headerlink" title="235.二叉搜索树的公共祖先"></a>235.二叉搜索树的公共祖先</h3><h4 id="解法-87"><a href="#解法-87" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>LCA（Lowest Common Ancestor）、BST</strong></p>
<p>根据BST的性质，对于任意节点x，其左子树中的所有节点值都小于x的值，右子树中的所有节点值都大于x的值。因此，如果两个目标节点分别位于x的左右子树中，那么x就是它们的LCA。</p>
<h4 id="代码-85"><a href="#代码-85" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)
            return lowestCommonAncestor(root-&gt;left, p, q);
        else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)
            return lowestCommonAncestor(root-&gt;right, p, q);
        else
            return root;
    &#125;
&#125;;</code></pre>



<h3 id="701-二叉搜索树的插入操作"><a href="#701-二叉搜索树的插入操作" class="headerlink" title="701.二叉搜索树的插入操作"></a>701.二叉搜索树的插入操作</h3><h4 id="解法-88"><a href="#解法-88" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归、迭代、BST</strong></p>
<p>根据BST性质，一直比较要插入节点的值与当前节点的值的大小，大了往右小了往左，直至碰到空节点，那就是该呆的地方了。</p>
<p>这里用递归的返回值实现父子节点赋值操作，正常情况，在进入分支时，该分支的返回值都是root，即子节点本身，不影响树结构，直至空节点时，才构建要插入的节点连上。</p>
<p>迭代则需要记录父节点的指针，才能完成插入操作。</p>
<h4 id="代码-86"><a href="#代码-86" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
        if(root &#x3D;&#x3D;nullptr)  return new TreeNode(val);
        if(root-&gt;val &gt; val) root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);
        else  				root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);
        return 				root;
    &#125;
&#125;;</code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
        if(root &#x3D;&#x3D; nullptr) return new TreeNode(val);
        TreeNode* cur &#x3D; root;
        TreeNode* parent &#x3D; root;
        while(cur) &#123;
            parent &#x3D; cur;
            if(cur-&gt;val &gt; val)  cur &#x3D; cur-&gt;left;
            else    cur &#x3D; cur-&gt;right;
        &#125;
        if(parent-&gt;val &gt; val)  parent-&gt;left &#x3D; new TreeNode(val);
        else    parent-&gt;right &#x3D; new TreeNode(val);
        return root;
    &#125;
&#125;;</code></pre>



<h3 id="450-删除二叉搜索树的节点"><a href="#450-删除二叉搜索树的节点" class="headerlink" title="450.删除二叉搜索树的节点"></a>450.删除二叉搜索树的节点</h3><h4 id="解法-89"><a href="#解法-89" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归、迭代、BST</strong></p>
<p>递归思路和上题701相同，只是插入节点变为删除，涉及到了结构调整，情况复杂一些。</p>
<h4 id="代码-87"><a href="#代码-87" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* deleteNode(TreeNode* root, int key) &#123;
        if(root &#x3D;&#x3D; nullptr) return root;
        if(root-&gt;val &gt; key)
            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);
        else if(root-&gt;val &lt; key)
            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);
        else &#123;
            if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;	&#x2F;&#x2F; 全空，叶子节点不用调整结构
                delete root;
                return nullptr;
            &#125;
            if(!root-&gt;left) &#123;					&#x2F;&#x2F; 只有右子树，把右子树挪上来
                TreeNode* tmp &#x3D; root-&gt;right;
                delete root;
                return tmp;
            &#125;
            if(!root-&gt;right) &#123;					&#x2F;&#x2F; 只有左子树，把左子树挪上来
                TreeNode* tmp &#x3D; root-&gt;left;
                delete root;
                return tmp;
            &#125;
            else &#123;								&#x2F;&#x2F; 左右子树均有，左子树归入右子树的最左侧叶子节点下，右子树上挪
                TreeNode* cur &#x3D; root-&gt;right;
                while(cur-&gt;left)
                    cur &#x3D; cur-&gt;left;
                cur-&gt;left &#x3D; root-&gt;left;
                TreeNode* tmp &#x3D; root-&gt;right;
                delete root;
                return tmp;
            &#125;
        &#125;
        return root;
    &#125;
&#125;;</code></pre>



<h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669.修剪二叉搜索树"></a>669.修剪二叉搜索树</h3><h4 id="题干-49"><a href="#题干-49" class="headerlink" title="题干"></a>题干</h4><p>给你二叉搜索树的根节点 <strong>root</strong> ，同时给定最小边界<strong>low</strong> 和最大边界 <strong>high</strong>。通过修剪二叉搜索树，使得所有节点的值在**[low, high]<strong>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的</strong>相对结构** (即如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在<strong>唯一的答案</strong> 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的<strong>新的根节点</strong>。注意，根节点可能会根据给定的边界发生改变。</p>
<h4 id="解法-90"><a href="#解法-90" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归、迭代、BST</strong></p>
<p>思路还是上两题701和450的思路，但其实比450操作要少很多，因为只保留范围内，意味着左边某个小于low的节点开始，只保留它的右子树，右边同理。那么只需<strong>把子树接到原本节点的位置</strong>即可。</p>
<p>迭代也是相同的思路，但是比递归要多处理一步，即<strong>先确定root节点在范围内</strong>。</p>
<h4 id="代码-88"><a href="#代码-88" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;
        if(root &#x3D;&#x3D; nullptr) return root;
        if(root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);
        if(root-&gt;val &gt; high)    return trimBST(root-&gt;left, low, high);
        root-&gt;left &#x3D; trimBST(root-&gt;left, low, high);
        root-&gt;right &#x3D; trimBST(root-&gt;right, low, high);
        return root;
    &#125;
&#125;;</code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;
        if(root &#x3D;&#x3D; nullptr) return nullptr;
        while(root &amp;&amp; (root-&gt;val &lt; low || root-&gt;val &gt; high)) &#123;
            if(root-&gt;val &lt; low) root &#x3D; root-&gt;right;
            else root &#x3D; root-&gt;left;
        &#125;
        TreeNode* cur &#x3D; root;
        while(cur) &#123;
            while(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; low) &#123;
                cur-&gt;left &#x3D; cur-&gt;left-&gt;right;
            &#125;
            cur &#x3D; cur-&gt;left;
        &#125;
        cur &#x3D; root;
        while(cur) &#123;
            while(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; high) &#123;
                cur-&gt;right &#x3D; cur-&gt;right-&gt;left;
            &#125;
            cur &#x3D; cur-&gt;right;
        &#125;
        return root;
    &#125;
&#125;;</code></pre>



<h3 id="108-将有序数组转化为二叉搜索树"><a href="#108-将有序数组转化为二叉搜索树" class="headerlink" title="108.将有序数组转化为二叉搜索树"></a>108.将有序数组转化为二叉搜索树</h3><h4 id="题干-50"><a href="#题干-50" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<h4 id="解法-91"><a href="#解法-91" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归、BST</strong></p>
<p>类似于二分查找的递归的反向操作。取中间值为节点，然后分为两个子数组，继续在子数组中取中间值为子节点……直至为空。</p>
<p>这题用迭代法会较为麻烦，因为需要开辟多个队列存储数组下标和节点信息。</p>
<h4 id="代码-89"><a href="#代码-89" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    TreeNode* sortedArrayToSubBST(vector&lt;int&gt;&amp; nums, int l, int r) &#123;
        if(l &gt; r)   return nullptr;
        int mid &#x3D; l + (r - l) &#x2F; 2;
        TreeNode* nd &#x3D; new TreeNode(nums[mid]);
        nd-&gt;left &#x3D; sortedArrayToSubBST(nums, l, mid - 1);
        nd-&gt;right &#x3D; sortedArrayToSubBST(nums, mid + 1, r);
        return nd;
    &#125;
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        return sortedArrayToSubBST(nums, 0, nums.size() - 1);
    &#125;
&#125;;</code></pre>



<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h3><h4 id="题干-51"><a href="#题干-51" class="headerlink" title="题干"></a>题干</h4><p>给出二叉搜索树的根节点，该树的节点值<strong>各不相同</strong>，请你将其转换为<strong>累加树</strong>（Greater Sum Tree），使每个节点 <strong>node</strong> 的新值等于原树中<strong>大于或等于 node.val 的值之和</strong>。</p>
<h4 id="解法-92"><a href="#解法-92" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>递归、BST、反中序</strong></p>
<p>需要理解累加的顺序，BST是有序的，也就是最大的值（右下角）不用累加，之后是其父节点，再后是父节点的左子树的最右节点，都是在前面和的基础上加上自身值。可以发现遍历顺序为<strong>右——&gt;中——&gt;左</strong>，也就是中序的反过来，在递归中很好写，换下处理顺序即可。</p>
<p>迭代也是类似于中序的迭代写法，更换左右顺序，替换处理方式即可。</p>
<h4 id="代码-90"><a href="#代码-90" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
private:
    int preSum &#x3D; 0;
public:
    void traversal(TreeNode* cur) &#123;
        if(cur &#x3D;&#x3D; nullptr)  return;
        traversal(cur-&gt;right);
        preSum +&#x3D; cur-&gt;val;
        cur-&gt;val &#x3D; preSum; 
        traversal(cur-&gt;left);
    &#125;
    TreeNode* convertBST(TreeNode* root) &#123;
        preSum &#x3D; 0;
        traversal(root);
        return root;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-20"><a href="#2023-6-20" class="headerlink" title="2023.6.20"></a>2023.6.20</h2><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><h4 id="题干-52"><a href="#题干-52" class="headerlink" title="题干"></a>题干</h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按 <strong>任何顺序</strong> 返回答案。</p>
<h4 id="解法-93"><a href="#解法-93" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>回溯、Lambda</strong></p>
<p>组合问题，常用回溯算法解决，即递归暴力枚举。这里用的是Lambda函数的递归写法，注意这里的 <code>++idx</code> 和普通函数中传参 <code>idx + 1</code> 的区别。</p>
<h4 id="代码-91"><a href="#代码-91" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; path;
        auto backTracking &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123;
                if(path.size() &#x3D;&#x3D; k) &#123;
                    res.push_back(path);
                    return;
                &#125;
                for(int i &#x3D; idx; i &lt;&#x3D; n; ++i) &#123;
                    path.push_back(i);
                    self(self, ++idx);
                    path.pop_back();
                &#125;
            &#125;
        ]() &#123; circle(circle, 1); &#125;;
        backTracking();
        return res;
    &#125;
&#125;;</code></pre>

<h4 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h4><h3 id="216-组合总和-Ⅲ"><a href="#216-组合总和-Ⅲ" class="headerlink" title="216.组合总和 Ⅲ"></a>216.组合总和 Ⅲ</h3><h4 id="解法-94"><a href="#解法-94" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>回溯、Lambda</strong></p>
<p>跟77思路一样，无非是递归的终止条件改为： <strong>path</strong> 元素数为k时，该数组和为n。循环改为固定9。</p>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><h4 id="解法-95"><a href="#解法-95" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>回溯、Lambda</strong></p>
<p>相比于上两题77和216，这题稍微复杂一些，因为是一个双层的循环，这里注意的是 <code>idx++</code> 的位置，因为控制的是外层循环的下标（即递归函数看作外层循环），因此要加在for循环前。</p>
<h4 id="代码-92"><a href="#代码-92" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    const string numMap[8] &#x3D; &#123;
        &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;
    &#125;;
    vector&lt;string&gt; letterCombinations(string digits) &#123;
        if(digits.length() &#x3D;&#x3D; 0)    return &#123;&#125;;
        vector&lt;string&gt; res;
        string path;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123;
                if(path.length() &#x3D;&#x3D; digits.length()) &#123;
                    res.push_back(path);
                    return;
                &#125;
                string str &#x3D; numMap[digits[idx++] - &#39;2&#39;];
                for(int i &#x3D; 0; i &lt; str.length(); ++i) &#123;
                    path.push_back(str[i]);
                    self(self, idx);
                    path.pop_back();
                &#125;
            &#125;
        ]() &#123; circle(circle, 0); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h3><h4 id="题干-53"><a href="#题干-53" class="headerlink" title="题干"></a>题干</h4><p>给你一个 <strong>无重复元素</strong> 的整数数组 <strong>candidates</strong> 和一个目标整数 <strong>target</strong> ，找出 <strong>candidates</strong> 中可以使数字<strong>和</strong>为目标数 <strong>target</strong> 的 <strong>所有</strong> 不同组合 ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p>candidates 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<h4 id="解法-96"><a href="#解法-96" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>回溯、Lambda</strong></p>
<p>跟上面三题同样思路，区别仅在于递归参数的传入上，因为可以重复选取，就不用自加idx了。但是依旧要注意，当最外层使用第二个数时，后面的也只能从第二个开始往后找，因为第一个数的组合已经列完了，再列是重复的，所以以for循环的 <strong>i</strong> 作为 <strong>idx</strong>的输入来控制搜索范围。</p>
<p>若觉得 <strong>accumulate</strong>计算和会慢，也可以将 <strong>target</strong>加入回溯中，在 <strong>self</strong>前后自减自加即可，终止条件就只需要比较 <code>== 0</code> 和 <code> &lt; 0</code> 了。</p>
<h4 id="代码-93"><a href="#代码-93" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
        vector&lt;vector&lt;int&gt; &gt; res;
        vector&lt;int&gt; path;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123;
                if(accumulate(path.begin(), path.end(), 0) &gt; target)
                    return;
                if(accumulate(path.begin(), path.end(), 0) &#x3D;&#x3D; target) &#123;
                    res.push_back(path);
                    return;
                &#125;
                for(int i &#x3D; idx; i &lt; candidates.size(); ++i) &#123;
                    path.push_back(candidates[i]);
                    self(self, i);
                    path.pop_back();
                &#125;
            &#125;
        ]() &#123; circle(circle, 0); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="40-组合总和-Ⅱ"><a href="#40-组合总和-Ⅱ" class="headerlink" title="40.组合总和 Ⅱ"></a>40.组合总和 Ⅱ</h3><h4 id="题干-54"><a href="#题干-54" class="headerlink" title="题干"></a>题干</h4><p>给定一个候选人编号的集合 <strong>candidates</strong> 和一个目标数 <strong>target</strong> ，找出 <strong>candidates</strong> 中所有可以使数字<strong>和为 target</strong> 的组合。<strong>candidates</strong> 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：<strong>解集不能包含重复的组合。</strong> </p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1：
输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,
输出:
[ [1,1,6], [1,2,5], [1,7], [2,6] ]</code></pre>

<pre class="language-none"><code class="language-none">示例 2：
输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,
输出:
[ [1,2,2], [5] ]</code></pre>

<h4 id="解法-97"><a href="#解法-97" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>回溯、Lambda</strong></p>
<p>这题有些绕，数组中有重复的数字，不同位置数字相同的元素是可以在一个组合内使用的，但是解集中不能有重复的组合。如示例1，有俩1，按照正常只往后遍历，可以有116，125，但也会出现215这种重复情况。因此需要去重。</p>
<p>针对乱序数组，又要下标又要数值判断过于麻烦，可以先对原数组排序。那么在只往后遍历的原则下，组合必然也是有序的，那么如果存在相同数字，在该数字开头的组合已经列完的情况下，后面相同的都直接跳过： <code>candidates[i] == candidates[i - 1]</code> 。但如果只有这一个条件，会发现，116这样的情况会被舍去，因此还需要加上限定条件，表明为<strong>同层使用</strong>（组合的同一个位置）而非同枝（即递归的深度中相同），也就是 <code>i &gt; idx</code>，说明是同一层的循环改变里跳过的。</p>
<p>但是一提交还是超时的，那就需要继续剪枝：</p>
<p>可以发现，当数组很大，但是和很小时，如果不在很早的地方结束递归，会出现非常多次无效递归，因此在循环中用 <code>target &gt; 0</code> 中止掉。</p>
<h4 id="代码-94"><a href="#代码-94" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; path;
        sort(candidates.begin(), candidates.end());
        auto backTracking &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123;
                if(0 &#x3D;&#x3D; target) &#123;
                    res.push_back(path);
                    return;
                &#125;
                for(int i &#x3D; idx; i &lt; candidates.size() &amp;&amp; target &gt; 0; ++i) &#123;
                    if(i &gt; idx &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1])
                        continue;
                    path.push_back(candidates[i]);
                    target -&#x3D; candidates[i];
                    self(self, i + 1);
                    target +&#x3D; candidates[i];
                    path.pop_back();
                &#125;
            &#125;
        ]() &#123; circle(circle, 0); &#125;;
        backTracking();
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-21"><a href="#2023-6-21" class="headerlink" title="2023.6.21"></a>2023.6.21</h2><h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><h4 id="题干-55"><a href="#题干-55" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<h4 id="解法-98"><a href="#解法-98" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>分割、回溯、Lambda</strong></p>
<p>分割问题和组合问题其实是一样的：对字符串aab，先分a出来，然后在ab中继续分；然后分ab出来，在a中继续分。。。相当于之前思路中的for循环对应第一层分割，即先分a、ab、aab，用idx控制，递归用于深层遍历。</p>
<p>判断回文串用双指针法，如果不是回文串直接跳过当层遍历，实现剪枝。</p>
<h4 id="代码-95"><a href="#代码-95" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        vector&lt;vector&lt;string&gt;&gt; res;
        vector&lt;string&gt; path;
        auto isPalStr &#x3D; [](string str, int l, int r) -&gt; bool &#123;
            for(int i &#x3D; l, j &#x3D; r; i &lt; j; ++i, --j)
                if(str[i] !&#x3D; str[j]) 
                    return false;
            return true;
        &#125;;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123;
                if(idx &gt;&#x3D; s.size()) &#123;
                    res.push_back(path);
                    return;
                &#125;
                for(int i &#x3D; idx; i &lt; s.size(); ++i) &#123;
                    if(isPalStr(s, idx, i)) 
                        path.push_back(s.substr(idx, i - idx + 1));
                    else continue;
                    self(self, i + 1);
                    path.pop_back();
                &#125;
            &#125;
        ]() &#123; circle(circle, 0); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><h4 id="题干-56"><a href="#题干-56" class="headerlink" title="题干"></a>题干</h4><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>给定一个只包含数字的字符串 <strong>s</strong> ，用以表示一个 IP 地址，返回<strong>所有可能</strong>的<strong>有效</strong> IP 地址，这些地址可以通过<strong>在 s 中插入 ‘.’</strong> 来形成。你 <strong>不能 重新排序或删除 s 中的任何数字</strong>。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<h4 id="解法-99"><a href="#解法-99" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>分割、回溯、Lambda</strong></p>
<p>for循环用于控制层中遍历，即在字符串上遍历；维护一个计数器cnt，用于计算深度，作为终止条件（到第四层就应该结束了，此时 <code>cnt == 3</code>）。</p>
<p>每次选取子串时，都需要判断有效性，若当前子串无效，那么同层遍历当前子串和递归后续子串就都没必要了，直接break，继续遍历上一个子串。</p>
<p>判断有效性时，要对字符串首的0做出判断（长度不为1时）；以及当前三个子串就将字符串中的数字占满时，第四个子串为空，按照递归的传参来说，会出现 <code>l == r + 1</code>的情况，也需要排除避免越界。</p>
<p>最开头排除长度在4-12之外的字符串，算作剪枝。</p>
<h4 id="代码-96"><a href="#代码-96" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;string&gt; restoreIpAddresses(string s) &#123;
        if(s.size() &lt; 4 || s.size() &gt; 12)   return &#123;&#125;;
        vector&lt;string&gt; res;
        auto isValid &#x3D; [](string str, int l, int r) -&gt; bool &#123;
            if(l &gt; r)   return false;
            if(str[l] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; l !&#x3D; r)
                return false;
            int num &#x3D; stoi(str.substr(l, r - l + 1));
            return num &gt;&#x3D; 0 &amp;&amp; num &lt; 256;
        &#125;;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx, int cnt) -&gt; void &#123;
                if(cnt &#x3D;&#x3D; 3) &#123;
                    if(isValid(s, idx, s.size() - 1))
                        res.push_back(s);
                    return;
                &#125;
                for(int i &#x3D; idx; i &lt; s.size(); ++i) &#123;
                    if(isValid(s, idx, i)) &#123;
                        s.insert(s.begin() + i + 1, &#39;.&#39;);
                        ++cnt;
                        self(self, i + 2, cnt);
                        --cnt;
                        s.erase(s.begin() + i + 1);
                    &#125;
                    else break;
                &#125;
            &#125;
        ]() &#123; circle(circle, 0, 0); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-22"><a href="#2023-6-22" class="headerlink" title="2023.6.22"></a>2023.6.22</h2><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><h4 id="题干-57"><a href="#题干-57" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<h4 id="解法-100"><a href="#解法-100" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>子集、回溯、Lambda</strong></p>
<p>子集问题本质和组合分割是差不多的，都是for循环横向控制层中遍历，递归纵向控制深度遍历。</p>
<p>区别就在于子集不再是递归到叶子节点终止了才要将结果加入数组，而是合适的都要加，也就是处理部分放在for循环和终止条件外执行。</p>
<h4 id="代码-97"><a href="#代码-97" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; path;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123;
                res.push_back(path);
                if(idx &gt; nums.size())   return;
                for(int i &#x3D; idx; i &lt; nums.size(); ++i) &#123;
                    path.push_back(nums[i]);
                    self(self, i + 1);
                    path.pop_back();
                &#125;
            &#125;
        ]() &#123; circle(circle, 0); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>

<h4 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h4><h3 id="90-子集-Ⅱ"><a href="#90-子集-Ⅱ" class="headerlink" title="90.子集 Ⅱ"></a>90.子集 Ⅱ</h3><h4 id="题干-58"><a href="#题干-58" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含<strong>重复</strong>元素 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<h4 id="解法-101"><a href="#解法-101" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>子集、回溯、Lambda</strong></p>
<p>这题类似于之前的40.组合 Ⅱ，都需要对重复数字去重。因此先对数组排序，之后在for循环中加入判断即可。</p>
<h4 id="代码-98"><a href="#代码-98" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">sort(nums.begin(), nums.end());
if(i &gt; idx &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1])	continue;</code></pre>



<h3 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h3><h4 id="题干-59"><a href="#题干-59" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <strong>nums</strong> ，找出并返回所有该数组中不同的<strong>递增子序列</strong>，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p>数组中可能含有<strong>重复</strong>元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<h4 id="解法-102"><a href="#解法-102" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>子集、回溯、Lambda</strong></p>
<p>因为要找递增子序列，所以不能对原数组直接排序了，需要采用其他方式去重：</p>
<p>可以在递归开始前先做预处理——找到 **nums[i]**上一次出现的位置，记为 **pre[i]**。</p>
<p>那么在同层遍历中，只需要判断 <strong>nums[i]</strong> 是否在当前位置 <strong>i</strong> 和本层的起始位置 <strong>idx</strong> 之间出现过，即 <code>idx &lt;= pre[i] &amp;&amp; pre[i] &lt; i</code>。</p>
<h4 id="代码-99"><a href="#代码-99" class="headerlink" title="代码"></a>代码</h4><p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/491.png" alt="491"></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; path;
        int pre[15];
        for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;
            pre[i] &#x3D; -1;
            for(int j &#x3D; i - 1; j &gt;&#x3D; 0; --j) &#123;
                if(nums[i] &#x3D;&#x3D; nums[j]) &#123;
                    pre[i] &#x3D; j;
                    break;
                &#125;
            &#125;
        &#125;
        auto isRepeat &#x3D; [pre](int l, int r) -&gt; bool &#123;
            return l &lt;&#x3D; pre[r] &amp;&amp; pre[r] &lt; r;
        &#125;;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int idx) -&gt; void &#123;
                if(path.size() &gt; 1)
                    res.push_back(path);
                for(int i &#x3D; idx; i &lt; nums.size(); ++i) &#123;
                    if(!path.empty() &amp;&amp; nums[i] &lt; path.back() || isRepeat(idx, i))
                        continue;
                    path.push_back(nums[i]);
                    self(self, i + 1);
                    path.pop_back();
                &#125;
            &#125;
        ]() &#123; circle(circle, 0); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="46-全排列-1"><a href="#46-全排列-1" class="headerlink" title="46.全排列"></a>46.全排列</h3><h4 id="题干-60"><a href="#题干-60" class="headerlink" title="题干"></a>题干</h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<h4 id="解法-103"><a href="#解法-103" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>排列、回溯、Lambda</strong></p>
<p>排列会用到数组中所有元素，因此直到递归到最后一层才会得到返回结果——<strong>由此可以确立终止条件</strong>。</p>
<p>在同层遍历时，数组中位置在当前元素之前的元素同样会被用到——<strong>for循环从0开始</strong>，而不是维护idx。</p>
<p>在纵向递归时，上层已经加入结果的元素<strong>需要被标记</strong>，从而可以在当前层的for循环中被跳过。</p>
<h4 id="代码-100"><a href="#代码-100" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; path;
        vector&lt;bool&gt; used(nums.size(), false);
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self) -&gt; void &#123;
                if(path.size() &#x3D;&#x3D; nums.size()) &#123;
                    res.push_back(path);
                    return;
                &#125;
                for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;
                    if(used[i]) continue;
                    used[i] &#x3D; true;
                    path.push_back(nums[i]);
                    self(self);
                    path.pop_back();
                    used[i] &#x3D; false;
                &#125;
            &#125;
        ]() &#123; circle(circle); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>

<h4 id="相关题目-3"><a href="#相关题目-3" class="headerlink" title="相关题目"></a>相关题目</h4><h3 id="47-全排列-Ⅱ"><a href="#47-全排列-Ⅱ" class="headerlink" title="47.全排列 Ⅱ"></a>47.全排列 Ⅱ</h3><h4 id="题干-61"><a href="#题干-61" class="headerlink" title="题干"></a>题干</h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<h4 id="解法-104"><a href="#解法-104" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>排列、回溯、Lambda</strong></p>
<p>在包含重复数字的情况下，都需要<strong>去重</strong>。在46.全排列的基础上，先对数组排序以便于去重。</p>
<p>然后增加判定条件，注意在判断相同元素之外，前提是<strong>上一个元素是没被使用</strong>的情况下。</p>
<h4 id="代码-101"><a href="#代码-101" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">sort(nums.begin(), nums.end());
if(used[i] || i &gt; 0 &amp;&amp; !used[i - 1] &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;</code></pre>



<h3 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h3><h4 id="题干-62"><a href="#题干-62" class="headerlink" title="题干"></a>题干</h4><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li>
</ul>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 示例1：
输入：tickets &#x3D; [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</code></pre>

<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 示例2：
输入：tickets &#x3D; [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]
解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</code></pre>

<h4 id="解法-105"><a href="#解法-105" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>排列、回溯、Lambda</strong></p>
<p>代码随想录中，使用了 <code>unordered_map</code> 来记录映射关系，其中包含 <code>map</code>自动实现排序。但实际上可以更节省空间——直接按照目的地大小对输入数组进行排序，之后的操作可以看作是一个<strong>全排列</strong>过程，并且只需要找到第一个结果就一定是最佳结果，直接return就行。</p>
<p>首先将起始地 <strong>“JKF”</strong> 加入路径，之后遍历每张票，跳过已经使用过的或是出发地和路径末尾地点不符的，之后就是回溯流程了，路径直接添加目的地即可。直至找到第一个叶节点，就结束了。</p>
<p><strong>终止条件：</strong>因为每张票都需要使用，因此一共 <strong>n</strong> 条路径，必然连接了 <strong>n + 1</strong> 个城市，因此 <code>path.size() == tickets.size() + 1</code> 。</p>
<h4 id="代码-102"><a href="#代码-102" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;
        sort(tickets.begin(), tickets.end(),
            [](vector&lt;string&gt;&amp; a, vector&lt;string&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125;  
        );
        vector&lt;string&gt; path;
        vector&lt;bool&gt; used(tickets.size(), false);
        path.push_back(&quot;JFK&quot;);
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self) -&gt; bool &#123;
                if(path.size() &#x3D;&#x3D; tickets.size() + 1) 
                    return true;
                for(int i &#x3D; 0; i &lt; tickets.size(); ++i) &#123;
                    if(used[i] || tickets[i][0] !&#x3D; path.back()) continue;
                    used[i] &#x3D; true;
                    path.push_back(tickets[i][1]);
                    if(self(self))  return true;
                    path.pop_back();
                    used[i] &#x3D; false;
                &#125;
                return false;
            &#125;
        ]() &#123; circle(circle); &#125;;
        backTrack();
        return path;
    &#125;
&#125;;</code></pre>



<h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51.N皇后"></a>51.N皇后</h3><h4 id="题干-63"><a href="#题干-63" class="headerlink" title="题干"></a>题干</h4><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 示例1：
输入：n &#x3D; 4
输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]
解释：如上图所示，4 皇后问题存在两个不同的解法。</code></pre>

<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 示例2：
输入：n &#x3D; 1
输出：[[&quot;Q&quot;]]</code></pre>

<h4 id="解法-106"><a href="#解法-106" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>排列、回溯、Lambda</strong></p>
<p>依旧是排列的思想——for循环控制横向遍历，递归控制纵向递归。</p>
<p>因为每到下一行，四个位置都需要判断可能性，因此是排列，for循环 0 - n 。递归需要一个额外参数 <code>row</code>记录当前所在行。那么<strong>终止条件</strong>显然是n行都遍历完—— <code>row == n</code>（row从0开始，便于下标取值）。</p>
<p>每次都先进行有效判断（对正上方和左右45°上方判断有无q即可），有效才能进入下层递归。</p>
<h4 id="代码-103"><a href="#代码-103" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;
        vector&lt;vector&lt;string&gt;&gt; res;
        vector&lt;string&gt; path(n, string(n, &#39;.&#39;));
        auto isValid &#x3D; [&amp;path, n](int row, int col) -&gt; bool &#123;
            for(int i &#x3D; 0; i &lt; row; ++i)
                if(path[i][col] &#x3D;&#x3D; &#39;Q&#39;) return false;
            for(int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0; --i, --j)
                if(path[i][j] &#x3D;&#x3D; &#39;Q&#39;) return false;
            for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; --i, ++j)
                if(path[i][j] &#x3D;&#x3D; &#39;Q&#39;) return false;
            return true;
        &#125;;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self, int row) -&gt; void &#123;
                if(row &#x3D;&#x3D; n) &#123;
                    res.push_back(path);
                    return;
                &#125;
                for(int i &#x3D; 0; i &lt; n; ++i) &#123;
                    if(isValid(row, i)) &#123;
                        path[row][i] &#x3D; &#39;Q&#39;;
                        self(self, row+1);
                        path[row][i] &#x3D; &#39;.&#39;;
                    &#125;
                &#125;
            &#125;
        ]() &#123; circle(circle, 0); &#125;;
        backTrack();
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h3><h4 id="题干-64"><a href="#题干-64" class="headerlink" title="题干"></a>题干</h4><p>编写一个程序，通过填充空格来解决数独问题。数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><strong>示例</strong></p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 示例1：
输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</code></pre>

<h4 id="解法-107"><a href="#解法-107" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>二维递归、回溯、Lambda</strong></p>
<p>这题是回溯合集中最抽象的一题，跟之前的全都不在一个模式。之前的问题都是在<strong>一维</strong>数组上进行二维操作，在横向选择的基础上向纵向推进。例如排列，可以看作是从一维数组中选取一个数，放在一个<strong>相同长度的一维数组</strong>的第一位，然后再从剩下数中选取一个放在新数组第二位……以此类推，最后填满表示产生一个结果，然后回溯去生成其他结果。</p>
<p>本题实则为一种另类的二维操作：从 <strong>[1, 9]</strong> 的一维数组中选取一个数，放在一个<strong>二维数组</strong>的第一位，然后再九个数中选取一个放在二维数组第二位……以此类推，最后填满表示产生一个结果。</p>
<p>但因为在遍历过程中是会对填入数字进行有效判断的，因此产生的结果必然是正确的，就不需要接着回溯，直接return即可（最外层循环外的 <code>return true</code>），因此递归函数需要有 <strong>bool</strong> 返回值，用于一层层向上中断递归过程（递归函数判断的 <code>return true</code>）。因此本题递归也不需要终止条件，这就是终止条件了。</p>
<p>显然还存在一个问题，<strong>当某个格子9个数字都不是有效数字时</strong>，说明作为判断条件之一的前面某一格的数字填错了，需要回去改，那么直接 <code>return false</code> ，回溯修改之前的数字。</p>
<h4 id="代码-104"><a href="#代码-104" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        auto isValid &#x3D; [&amp;](int row, int col, char num) -&gt; bool &#123;
            for(char c : board[row])    
                if(c &#x3D;&#x3D; num)    
                    return false;
            for(int i &#x3D; 0; i &lt; 9; ++i)    
                if(board[i][col] &#x3D;&#x3D; num)    
                    return false;
            int idy &#x3D; row &#x2F; 3 * 3, idx &#x3D; col &#x2F; 3 * 3;
            for(int i &#x3D; idy; i &lt; idy + 3; ++i)
                for(int j &#x3D; idx; j &lt; idx + 3; ++j)
                    if(board[i][j] &#x3D;&#x3D; num)
                        return false;
            return true;
        &#125;;
        auto backTrack &#x3D; [
            circle &#x3D; [&amp;](auto&amp;&amp; self) -&gt; bool &#123;
                for(int i &#x3D; 0; i &lt; 9; ++i) &#123;
                    for(int j &#x3D; 0; j &lt; 9; ++j) &#123;
                        if(board[i][j] !&#x3D; &#39;.&#39;) continue;
                        for(char k &#x3D; &#39;1&#39;; k &lt;&#x3D; &#39;9&#39;; ++k) &#123;
                            if(isValid(i, j, k)) &#123;
                                board[i][j] &#x3D; k;
                                if(self(self)) return true;
                                board[i][j] &#x3D; &#39;.&#39;;
                            &#125;
                        &#125;
                        return false;	&#x2F;&#x2F; 核心
                    &#125;
                &#125;
                return true;
            &#125;
        ]() &#123; circle(circle); &#125;;
        backTrack();
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-24"><a href="#2023-6-24" class="headerlink" title="2023.6.24"></a>2023.6.24</h2><h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h3><h4 id="解法-108"><a href="#解法-108" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心、双指针</strong></p>
<p>贪心思路：小的饼干尽可能喂给最小胃口的孩子（局部），以达到喂最多小孩的目的（全局）。</p>
<h4 id="代码-105"><a href="#代码-105" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int res &#x3D; 0;
        for(int i &#x3D; 0; i &lt; s.size(); ++i)
            if(res &lt; g.size() &amp;&amp; g[res] &lt;&#x3D; s[i])
                ++res;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h3><h4 id="题干-65"><a href="#题干-65" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p>
<h4 id="解法-109"><a href="#解法-109" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>贪心就贪在here这里。因为当此时的连续和为负数时，加上下一个数只会拉低总和，因此不如直接从下一个数开始重新累加，反而更大，这就是局部最优。</p>
<p>但这里要注意每一步都需要保存当前的连续和（在重置之前），因为存在最大和为负数的情况。</p>
<h4 id="代码-106"><a href="#代码-106" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int res &#x3D; INT_MIN, cnt &#x3D; 0;
        for(int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;
            cnt +&#x3D; nums[i];
            if(cnt &gt; res)   res &#x3D; cnt;
            if(cnt &lt; 0)     cnt &#x3D; 0;	&#x2F;&#x2F; here
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-25"><a href="#2023-6-25" class="headerlink" title="2023.6.25"></a>2023.6.25</h2><h3 id="122-买卖股票的最佳时机"><a href="#122-买卖股票的最佳时机" class="headerlink" title="122.买卖股票的最佳时机"></a>122.买卖股票的最佳时机</h3><h4 id="解法-110"><a href="#解法-110" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心、数学</strong></p>
<p>首先需要找到一个规律：如果第一天买，第三天卖，收益为 <strong>prices[2] - prices[0] = （prices[2] - prices[1]）+（prices[1] - prices[0]）</strong>。也就是说，无论哪天买卖，<strong>一次买卖的收益是持有期间的每日收益的总和</strong>。</p>
<p>贪心思路：负数会降低收益，因此只选每日收益为正的时间段持有，就是最高收益。</p>
<h4 id="代码-107"><a href="#代码-107" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int res &#x3D; 0;
        for(int i &#x3D; 0; i &lt; prices.size() - 1; ++i) 
            if(prices[i+1] - prices[i] &gt; 0)
                res +&#x3D; prices[i+1] - prices[i];
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h3><h4 id="解法-111"><a href="#解法-111" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>贪心思路：将问题转化为判断移动范围能否覆盖至终点，循环每移动一个单位，就尝试更新最大的覆盖范围。</p>
<p>不用考虑如何到那个覆盖最大范围的点，只要知道最大范围是哪儿。在这个范围内就可以继续向后遍历。不用担心数组越界，当覆盖范围超过数组长度时，直接return。若因为0卡在原地不动，到 <strong>maxRange</strong> 直接就结束循环了。</p>
<h4 id="代码-108"><a href="#代码-108" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool canJump(vector&lt;int&gt;&amp; nums) &#123;
        int maxRange &#x3D; 0;
        for(int i &#x3D; 0; i &lt;&#x3D; maxRange; ++i) &#123;
            maxRange &#x3D; max(maxRange, nums[i] + i);
            if(maxRange &gt;&#x3D; nums.size() - 1)  return true;
        &#125;
        return false;
    &#125;
&#125;;</code></pre>



<h3 id="45-跳跃游戏-Ⅱ"><a href="#45-跳跃游戏-Ⅱ" class="headerlink" title="45.跳跃游戏 Ⅱ"></a>45.跳跃游戏 Ⅱ</h3><h4 id="解法-112"><a href="#解法-112" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>贪心思路：同55，依旧是更新最大的覆盖范围。</p>
<p>区别在于要统计最小步数，也就是每一步要走的尽可能大——&gt;<strong>更新覆盖范围的最小次数</strong>。也就是在每一个覆盖范围内走的尽可能多（尽量走到范围边缘再更新）。</p>
<p>for循环是从头到尾的，max函数用于统计下一步的最优情况，当遍历到达本次边界时，再增加步数（可能不是在这个下标处跳的，但是没有区别不需要关心）。</p>
<h4 id="代码-109"><a href="#代码-109" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int jump(vector&lt;int&gt;&amp; nums) &#123;
        int res &#x3D; 0, cur &#x3D; 0, next &#x3D; 0;
        for(int i &#x3D; 0; i &lt; nums.size() - 1; ++i) &#123;
            next &#x3D; max(next, nums[i] + i);
            if(i &#x3D;&#x3D; cur) &#123;
                cur &#x3D; next;
                ++res;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005.K 次取反后最大化的数组和"></a>1005.K 次取反后最大化的数组和</h3><h4 id="解法-113"><a href="#解法-113" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>贪心思路：存在两种情况的贪心。</p>
<ol>
<li>若是 <strong>k &lt;= 负数的数量</strong>，那么每次取当前最大的负数变正；</li>
<li>若k大于负数数量，则每次取最小的非负数变负：这里存在优化，当变负了后，若k还大于0，此时应按照1的贪心来，将负数变正。那么可以得到结论——当剩余k值为偶数时，可以直接忽略，为奇数则将最小非负数变负。</li>
</ol>
<p>我的代码相比代码随想录做了进一步优化：<strong>将求和和修改同步进行。那么若k最后剩余为奇数，只需要和减去最小非负数的两倍即可。</strong></p>
<h4 id="代码-110"><a href="#代码-110" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;
        int res &#x3D; 0;
        sort(nums.begin(), nums.end(), [](int a, int b) &#123; return abs(a) &gt; abs(b); &#125;);
        for(int&amp; n : nums) &#123;
            if(n &lt; 0 &amp;&amp; k-- &gt; 0)
                n *&#x3D; -1;
            res +&#x3D; n;
        &#125;
        if(k % 2)   res -&#x3D; nums[nums.size() - 1] * 2;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134.加油站"></a>134.加油站</h3><h4 id="解法-114"><a href="#解法-114" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>首先明确：只有总油量大于等于总消耗，才能跑完一圈；当前油量小于下一路程消耗油量时，跑不过去。</p>
<p>抽象为数学计算就是：设第 <strong>i</strong>站到 <strong>i+1</strong>站剩余油量 <strong>gas[i] - cost[i]</strong> ，只有所有的剩余油量和大于等于0才能跑完。从第0站作为出发点开始累加剩余油量的和，一旦到第 <strong>i+1</strong>站时和小于0了，说明从<strong>之前的任意站出发都是到不了这一站</strong>的（可证明）。那么就只能以第 <strong>i+1</strong>站重新作为出发点，重新累加和。</p>
<p><strong>局部最优：</strong>每走一段，累加和一定大于等于0。</p>
<h4 id="代码-111"><a href="#代码-111" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int res &#x3D; 0, sum &#x3D; 0, total &#x3D; 0;
        for(int i &#x3D; 0, n &#x3D; gas.size(); i &lt; n; ++i) &#123;
            sum +&#x3D; gas[i] - cost[i];
            total +&#x3D; gas[i] - cost[i];
            if(sum &lt; 0) &#123;
                res &#x3D; i + 1;
                sum &#x3D; 0;
            &#125;
        &#125;
        return total &lt; 0 ? -1 : res;
    &#125;
&#125;;</code></pre>



<h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a>135.分发糖果</h3><h4 id="解法-115"><a href="#解法-115" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>先确定一边（假设左边）</p>
<p><strong>局部最优：</strong>只要比左边的分数高，糖果数就为左边的+1。</p>
<p>再确定另一边（此时循环的方向必须反过来，因为数组中分数存在递增和递减两种情况，假设两遍都是左到右的循环，第二次当碰到递减段时，段中的前几个值都是不对的，因为都比右面的大，都会+1，而左边的已经遍历过了不能继续加了。<strong>遍历方向仅能解决递增段</strong>，要不出错就需要双向遍历。）</p>
<p><strong>局部最优：</strong>此时糖果数已经比左边大了，取 <strong>糖果数</strong> 和 **右边糖果数+1 **中最大的，就一定比两边都大。</p>
<h4 id="代码-112"><a href="#代码-112" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int candy(vector&lt;int&gt;&amp; ratings) &#123;
        vector&lt;int&gt; candy(ratings.size(), 1);
        for(int i &#x3D; 1; i &lt; ratings.size(); ++i)
            if(ratings[i] &gt; ratings[i - 1])
                candy[i] +&#x3D; candy[i - 1]; 
        for(int i &#x3D; ratings.size() - 2; i &gt;&#x3D; 0; --i)
            if(ratings[i] &gt; ratings[i + 1])
                candy[i] &#x3D; max(candy[i], candy[i + 1] + 1); 
        return accumulate(candy.begin(), candy.end(), 0);       
    &#125;
&#125;;</code></pre>



<h3 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h3><h4 id="解法-116"><a href="#解法-116" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心、模拟</strong></p>
<p>基本就是模拟判断，用到贪心的地方大概是20找零？</p>
<p><strong>局部最优：</strong>尽量用大面额的10去找，因为5还需要用于给10找零。</p>
<h4 id="代码-113"><a href="#代码-113" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;
        int five &#x3D; 0, ten &#x3D; 0;
        for(int i &#x3D; 0; i &lt; bills.size(); ++i) &#123;
            if(bills[i] &#x3D;&#x3D; 5)   ++five;
            else if(bills[i] &#x3D;&#x3D; 10) &#123;
                if(five &lt;&#x3D; 0) return false;
                --five;
                ++ten;
            &#125;
            else &#123;
                if(ten &gt; 0 &amp;&amp; five &gt; 0) &#123;
                    --five;
                    --ten;
                &#125;
                else if(five &gt; 2) five -&#x3D; 3;
                else    return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;</code></pre>



<h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h3><h4 id="解法-117"><a href="#解法-117" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心、list</strong></p>
<p>当存在两个维度需要处理时，先确定一个基本维度再处理另一个。这里显然是按照身高排序更合适，k排序结束依旧是不符合k条件的序列。那么首先按照<strong>身高从大到小排序，相等的k小的在前面</strong>。</p>
<p><strong>局部最优：</strong>优先按身高更高的人的k来插入，<strong>后续的插入不会影响之前已完成的</strong>，因为都比已完成的更矮。</p>
<h4 id="代码-114"><a href="#代码-114" class="headerlink" title="代码"></a>代码</h4><p>这里先用 <strong>list</strong>存而非 <strong>vector</strong>的原因在于 <strong>vector</strong>的插入操作是 O(n) 时间，而 <strong>list</strong>底层为链表，插入为 O(1) 。并且 <strong>vector</strong>在插入时，通过重新申请一个二倍空间大小的数组并将原数组<strong>拷贝</strong>过去实现扩容，这样会很慢。</p>
<p>注意 <strong>list</strong>的迭代器是<strong>双向迭代器</strong>，而不是随机访问迭代器，只支持指针逐一迭代寻址。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;
        sort(people.begin(), people.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;
            return a[0] &gt; b[0] || (a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1]);
        &#125;);
        list&lt;vector&lt;int&gt;&gt; res;
        for(int i &#x3D; 0; i &lt; people.size(); ++i) &#123;
            int pos &#x3D; people[i][1];
            auto iter &#x3D; res.begin();
            while(pos--)    ++iter;
            res.insert(iter, people[i]);
        &#125;
        return vector&lt;vector&lt;int&gt;&gt;(res.begin(), res.end());
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-26"><a href="#2023-6-26" class="headerlink" title="2023.6.26"></a>2023.6.26</h2><h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452.用最少数量的箭引爆气球"></a>452.用最少数量的箭引爆气球</h3><h4 id="解法-118"><a href="#解法-118" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>其实就是求有交集的范围的最小组合数。</p>
<p><strong>局部最优：</strong>让尽可能多的范围处于同一组合中。即<strong>在按左边界升序排序的情况下，维护范围的最小右边界。</strong></p>
<h4 id="代码-115"><a href="#代码-115" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;
        sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;
            return a[0] &lt; b[0] || a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1];
        &#125;);
        int res &#x3D; 1;
        for(int i &#x3D; 1; i &lt; points.size(); ++i) &#123;
            if(points[i][0] &gt; points[i - 1][1])
                ++res;
            else 
                points[i][1] &#x3D; min(points[i][1], points[i - 1][1]);
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a>435.无重叠区间</h3><h4 id="解法-119"><a href="#解法-119" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>同上452题的思路。在按左边界升序排序的情况下，只需维护右边界为较小值即可。</p>
<p><strong>局部最优：</strong>每次都去掉较大的区间，尽可能保留小范围的区间。</p>
<h4 id="代码-116"><a href="#代码-116" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;
            return a[0] &lt; b[0] || a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1];
        &#125;);
        int res &#x3D; 0;
        for(int i &#x3D; 1; i &lt; intervals.size(); ++i) &#123;
            if(intervals[i][0] &lt; intervals[i - 1][1]) &#123;
                ++res;
                intervals[i][1] &#x3D; min(intervals[i][1], intervals[i - 1][1]);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h3><h4 id="解法-120"><a href="#解法-120" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>模拟？</strong></p>
<p>先统计每个字母最后出现的位置。然后从第一个字母开始，在遍历到最后出现位置的过程中不断更新区间内所有字母最后出现位置中的最大值（即<strong>最大右边界</strong>），直至达到右边界时，说明这个区间内的字母没有在后面出现了，可以划分出来了。记录分割的位置，后面以此类推。</p>
<h4 id="代码-117"><a href="#代码-117" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;int&gt; partitionLabels(string s) &#123;
        int hash[26] &#x3D; &#123;0&#125;;
        for(int i &#x3D; 0; i &lt; s.length(); ++i)
            hash[s[i] - &#39;a&#39;] &#x3D; i;
        vector&lt;int&gt; res;
        int right &#x3D; 0, left &#x3D; 0;
        for(int i &#x3D; 0; i &lt; s.length(); ++i) &#123;
            right &#x3D; max(right, hash[s[i] - &#39;a&#39;]);
            if(i &#x3D;&#x3D; right) &#123;
                res.push_back(i + 1 - left);
                left &#x3D; i + 1;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="56-合并区间-1"><a href="#56-合并区间-1" class="headerlink" title="56.合并区间"></a>56.合并区间</h3><h4 id="解法-121"><a href="#解法-121" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p>和452、435一样的思路，左边界始终更新为最小的（最开始的），右边界取每次相邻区间右边界的最大值。一旦出现不重叠的区间，就将上一个区间加入结果集，最后将最后一个也加入即可。</p>
<h4 id="代码-118"><a href="#代码-118" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123;
            return a[0] &lt; b[0] || a[0] &#x3D;&#x3D; b[0] &amp;&amp; a[1] &lt; b[1];
        &#125;);
        vector&lt;vector&lt;int&gt;&gt; res;
        for(int i &#x3D; 1; i &lt; intervals.size(); ++i) &#123;
            if(intervals[i][0] &lt;&#x3D; intervals[i - 1][1]) &#123;
                intervals[i][0] &#x3D; intervals[i - 1][0];
                intervals[i][1] &#x3D; max(intervals[i][1], intervals[i - 1][1]);
            &#125;
            else
                res.push_back(intervals[i - 1]);
        &#125;
        res.push_back(intervals[intervals.size() - 1]);
        return res;
    &#125;
&#125;;</code></pre>



<h3 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h3><h4 id="解法-122"><a href="#解法-122" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>贪心</strong></p>
<p><strong>局部最优：</strong>当某一位不符合要求时，将<strong>自身变为9，高一位减一</strong>是最优解。</p>
<p>主要是选择遍历的方向，若是从高位往低位遍历，例如332，第二个3 &gt; 2，结果为329，但不符合要求。后面的比较会影响到之前已经确认了的顺序。而从低位开始遍历，不符合递增时会直接设为9，向高位遍历时不会影响到已经确立的低位（都是9）。</p>
<h4 id="代码-119"><a href="#代码-119" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int monotoneIncreasingDigits(int n) &#123;
        string str &#x3D; to_string(n);
        int idx &#x3D; str.length();
        for(int i &#x3D; str.length() - 1; i &gt; 0; --i) &#123;
            if(str[i] &lt; str[i - 1]) &#123;
                idx &#x3D; i;
                --str[i - 1];
            &#125;
        &#125;
        for(; idx &lt; str.length(); ++idx)
            str[idx] &#x3D; &#39;9&#39;;
        return stoi(str);
    &#125;
&#125;;</code></pre>



<h3 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.监控二叉树</h3><h4 id="解法-123"><a href="#解法-123" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>二叉树、状态递归</strong></p>
<p>二叉树结构为指数增长，因此摄像头不放在叶节点上，就是最少的放法。因此确立了<strong>后序遍历</strong>的顺序。</p>
<p>那如何确定当前节点放不放呢？需要依靠子节点返回的状态判断。因此需要先确立节点所有的状态：</p>
<ul>
<li>未被摄像头覆盖，0（说明子节点属于被覆盖状态2）</li>
<li>有摄像头，1（说明子节点属于未被覆盖状态0）</li>
<li>已被覆盖，2（说明子节点有摄像头，<strong>或是空节点</strong>（因为叶节点不能放摄像头，所以状态必须为0，因此两个空子节点都设为2，即可完成递归逻辑））</li>
</ul>
<p>之后便是先递归左右子节点，然后根据子节点状态返回当前节点状态：有一个0就返回1，并计数；有一个1就返回2；全是2就返回0。最后结束递归后，根节点的状态是需要单独处理的（如果是状态0，就+1）</p>
<h4 id="代码-120"><a href="#代码-120" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int res &#x3D; 0;
    int traversal(TreeNode* cur) &#123;
        if(cur &#x3D;&#x3D; nullptr)  return 2;
        int left &#x3D; traversal(cur-&gt;left);
        int right &#x3D; traversal(cur-&gt;right);
        if(left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123;
            ++res;
            return 1;
        &#125;
        else if(left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1)
            return 2;
        return 0;
    &#125;
    int minCameraCover(TreeNode* root) &#123;
        return traversal(root) &#x3D;&#x3D; 0 ? res + 1 : res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-6-27"><a href="#2023-6-27" class="headerlink" title="2023.6.27"></a>2023.6.27</h2><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h3><h4 id="解法-124"><a href="#解法-124" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p>状态转移方程：<strong>F(n) = F(n - 1) - F(n - 2)</strong></p>
<h4 id="代码-121"><a href="#代码-121" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int fib(int n) &#123;
        if(n &lt; 2)   return n;
        int one &#x3D; 0, two &#x3D; 1, cur;
        for(int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;
            cur &#x3D; one + two;
            one &#x3D; two;
            two &#x3D; cur;
        &#125;
        return cur;
    &#125;
&#125;;</code></pre>

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><h4 id="解法-125"><a href="#解法-125" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p>第一道真正的动态规划题，上题状态转移方程算直接给出了。按照五部曲往下走：</p>
<p><strong>1.确定dp数组及含义</strong>——dp[i]： 爬到第i层楼梯，有dp[i]种方法</p>
<p><strong>2.确定递推公式</strong></p>
<p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>所以<strong>dp[i] = dp[i - 1] + dp[i - 2]</strong> 。</p>
<p><strong>3.dp数组初始化</strong></p>
<p>因为n取值&gt;=1，那么显然应该从1开始，即<strong>dp[1] = 1，dp[2] = 2</strong>，那么循环从3开始递推。</p>
<p><strong>4.确定遍历顺序</strong>——从前向后，求dp[n]。</p>
<p><strong>5.举例推导</strong></p>
<p>最终发现写法和509基本是完全一致的。</p>
<h4 id="代码-122"><a href="#代码-122" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int climbStairs(int n) &#123;
        if(n &lt;&#x3D; 2)   return n;
        int one &#x3D; 1, two &#x3D; 2, cur;
        for(int i &#x3D; 3; i &lt;&#x3D; n; ++i) &#123;
            cur &#x3D; one + two;
            one &#x3D; two;
            two &#x3D; cur;
        &#125;
        return cur;
    &#125;
&#125;;</code></pre>

<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3><h4 id="解法-126"><a href="#解法-126" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p><strong>1.确定dp数组及含义</strong>——dp[i]： 爬到第i层楼梯的最低消费</p>
<p><strong>2.确定递推公式</strong></p>
<p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p>
<p>首先是dp[i - 1]，在i-1层，花费cost[i - 1]到达 i。其次是dp[i - 2]，在i-2层，花费cost[i - 2]到达 i。</p>
<p>选最小值就是：<strong>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</strong> 。</p>
<p><strong>3.dp数组初始化</strong></p>
<p>初始可以在0或1层，即<strong>dp[0] = 0，dp[1] = 0</strong>，那么循环从2开始递推。</p>
<p><strong>4.确定遍历顺序</strong>——从前向后，求dp[n]。</p>
<h4 id="代码-123"><a href="#代码-123" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;
        int one &#x3D; 0, two &#x3D; 0, cur;
        for(int i &#x3D; 2; i &lt;&#x3D; cost.size(); ++i) &#123;
            cur &#x3D; min(one + cost[i - 2], two + cost[i - 1]);
            one &#x3D; two;
            two &#x3D; cur;
        &#125;
        return cur;
    &#125;
&#125;;</code></pre>

<h2 id="2023-6-28"><a href="#2023-6-28" class="headerlink" title="2023.6.28"></a>2023.6.28</h2><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><h4 id="解法-127"><a href="#解法-127" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p><strong>1.确定dp数组及含义</strong>——dp[i] [j]： 走到（i，j）有 dp[i] [j] 条路径。</p>
<p><strong>2.确定递推公式</strong>——<strong>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]</strong></p>
<p><strong>3.dp数组初始化</strong>（<strong>重点</strong>）——在这个二维表格中，<strong>第一行和第一列都需要初始化为1</strong>。</p>
<p><strong>4.确定遍历顺序</strong>——顺序遍历，求dp[m - 1] [n - 1]。</p>
<h4 id="代码-124"><a href="#代码-124" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int uniquePaths(int m, int n) &#123;
        vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n, 0));
        for(int i &#x3D; 0; i &lt; m; ++i)	dp[i][0] &#x3D; 1;
        for(int i &#x3D; 0; i &lt; n; ++i)	dp[0][i] &#x3D; 1;
        for(int i &#x3D; 1; i &lt; m; ++i)
            for(int j &#x3D; 1; j &lt; n; ++j)
                dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];
        return dp[m - 1][n - 1];
    &#125;
&#125;;</code></pre>

<h3 id="63-不同路径-Ⅱ"><a href="#63-不同路径-Ⅱ" class="headerlink" title="63.不同路径 Ⅱ"></a>63.不同路径 Ⅱ</h3><h4 id="解法-128"><a href="#解法-128" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p><strong>版本1：</strong>重点依旧在于初始化上，在初始化第一行、列时，一旦遇到障碍物，后面都是0，直接停止循环。</p>
<p><strong>版本2：</strong>优化空间——一维数组</p>
<p>可以发现递推公式 **dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]**，其中 **dp[i - 1] [j]**保存的是上一行同一列的状态，即可以理解为先 **dp[i] [j] = dp[i - 1] [j]**，再 <strong>dp[i] [j] = dp[i] [j] + dp[i] [j - 1]</strong>.可以发现 <strong>i</strong> 的存在不必要了。dp数组可以简化为1维，递推公式 **dp[j] = dp[j] + dp[j - 1]**。在按序遍历的情况下，遍历到当前行 的j时，dp[j] 实际为上一行的路径数，只需加上 dp[j - 1]，效果就和版本1完全一致了。</p>
<h4 id="代码-125"><a href="#代码-125" class="headerlink" title="代码"></a>代码</h4><p><strong>版本1：</strong>时间复杂度：O(n × m)，空间复杂度：O(n × m)</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
        int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size();
        if (obstacleGrid[0][0] &#x3D;&#x3D; 1 || obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1)
            return 0;
        vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n, 0));
        for(int i &#x3D; 0; i &lt; m; ++i) &#123;
            if(obstacleGrid[i][0] &#x3D;&#x3D; 1) break;
            dp[i][0] &#x3D; 1;
        &#125;
        for(int i &#x3D; 0; i &lt; n; ++i) &#123;
            if(obstacleGrid[0][i] &#x3D;&#x3D; 1) break;
            dp[0][i] &#x3D; 1;
        &#125;
        for(int i &#x3D; 1; i &lt; m; ++i)
            for(int j &#x3D; 1; j &lt; n; ++j)
                if(obstacleGrid[i][j] &#x3D;&#x3D; 0)
                    dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];
        return dp[m - 1][n - 1];
    &#125;
&#125;;</code></pre>

<p><strong>版本2：</strong>时间复杂度：O(n × m)，空间复杂度：O(m)</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
        int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size();
        vector&lt;int&gt; dp(n, 0);
        for(int i &#x3D; 0; i &lt; n &amp;&amp; obstacleGrid[0][i] &#x3D;&#x3D; 0; ++i)
            dp[i] &#x3D; 1;
        for(int i &#x3D; 1; i &lt; m; ++i) &#123;
            for(int j &#x3D; 0; j &lt; n; ++j) &#123;
                if(obstacleGrid[i][j] &#x3D;&#x3D; 1)
                    dp[j] &#x3D; 0;
                else if(j !&#x3D; 0)
                    dp[j] &#x3D; dp[j] + dp[j - 1];
            &#125;
        &#125;
        return dp[n - 1];
    &#125;
&#125;;</code></pre>

<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3><h4 id="解法-129"><a href="#解法-129" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p>这题重点我认为首先是确定dp数组含义，有什么是可以由更小的相同类型的东西递推得到的？dp的值肯定表示为最大乘积，那么下标 i 表示的是什么呢？只能是 正整数 i 拆分后的最大乘积，也就是求 dp[n] 。</p>
<p>那么递推公式就容易解决了：<strong>dp[i] = dp[i - num] * num</strong>，因为拆出一个num后剩余的也是可以拆分的。但是dp表示的仅是拆分后的最大乘积，不一定比 i 本身大（例：2拆分后为1，小于本身），因此公式应修改为：**dp[i] = max( dp[i - num] * num, (i - num) * num )**。</p>
<p>num怎么取值呢？只能在 <strong>[1, i / 2]</strong> 范围内遍历取值。那么又出现了问题：dp[i] 每次都会被赋值一遍，要取其中的最大值才行，因此公式还应修改：**dp[i] = max(dp[i], max( dp[i - num] * num, (i - num) * num ))**。</p>
<h4 id="代码-126"><a href="#代码-126" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int integerBreak(int n) &#123;
        vector&lt;int&gt; dp(n + 1);
        dp[2] &#x3D; 1;
        for(int i &#x3D; 3; i &lt;&#x3D; n; ++i)
            for(int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; ++j)
                dp[i] &#x3D; max(dp[i], max(j * (i - j), j * dp[i - j]));
        return dp[n];
    &#125;
&#125;;</code></pre>

<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><h4 id="解法-130"><a href="#解法-130" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划</strong></p>
<p>这题dp数组含义很好确定，就是 i 个不同节点组成的BST数量。难在递推公式上。</p>
<img src="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/20210107093226241.png" alt="96.不同的二叉搜索树2" style="zoom: 50%;">

<p>由此，推至n得递推公式：遍历[1,  j]计算<strong>dp[i] += dp[j - 1] * dp[i - j]</strong></p>
<h4 id="代码-127"><a href="#代码-127" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int numTrees(int n) &#123;
        vector&lt;int&gt; dp(n + 1);
        dp[0] &#x3D; 1;
        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)
            for(int j &#x3D; 1; j &lt;&#x3D; i; ++j)
                dp[i] +&#x3D; dp[j - 1] * dp[i - j];
        return dp[n];
    &#125;
&#125;;</code></pre>

<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>卡特兰数</strong></p>
<p>这种递推公式实际为一种数学表达式，名为[卡特兰数](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0">卡特兰数_百度百科 (baidu.com)</a>)。常用于解决以下问题：</p>
<ul>
<li>凸多边形三角划分：输入凸多边形的边数n，求不同划分的方案数f(n)。此处f(2) = f(3) = 1。</li>
<li>给定n个节点组成不同的二叉搜索树</li>
<li>n对括号正确匹配数目</li>
</ul>
<h2 id="2023-6-29"><a href="#2023-6-29" class="headerlink" title="2023.6.29"></a>2023.6.29</h2><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h3><h4 id="解法-131"><a href="#解法-131" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、01背包</strong></p>
<ul>
<li>背包的体积为sum / 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满（dp[target] == target），说明找到了总和为 sum / 2 的子集。</li>
</ul>
<p>代码随想录的代码还可以优化一下空间，dp初始化大小由target决定</p>
<h4 id="代码-128"><a href="#代码-128" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;
        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);
        if(sum % 2) return false;
        int target &#x3D; sum &#x2F; 2;
        vector&lt;int&gt; dp(target + 1, 0);
        for(int i &#x3D; 0; i &lt; nums.size(); ++i)
            for(int j &#x3D; target; j &gt;&#x3D; nums[i]; --j)
                dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);
        return dp[target] &#x3D;&#x3D; target;
    &#125;
&#125;;</code></pre>

<h3 id="1049-最后一块石头的重量-Ⅱ"><a href="#1049-最后一块石头的重量-Ⅱ" class="headerlink" title="1049.最后一块石头的重量 Ⅱ"></a>1049.最后一块石头的重量 Ⅱ</h3><h4 id="解法-132"><a href="#解法-132" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、01背包</strong></p>
<p>和上题416的思路是一致的，返回最小重量就是尽可能均分为两堆重量相差最小的石头，即<strong>背包的体积为总重量的一半</strong>。商品的重量和价值均为 **stones[i]**。</p>
<p>最后得到的 <strong>dp[sum / 2]</strong> 就是能凑到的最接近的重量了，另一堆就是 <strong>sum - dp[sum / 2]<strong>，且因为 sum / 2 向下取整，前者必然小于等于后者，因此最终结果为</strong>后者 - 前者</strong>。</p>
<h4 id="代码-129"><a href="#代码-129" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;
        int sum &#x3D; accumulate(stones.begin(), stones.end(), 0);
        int target &#x3D; sum &#x2F; 2;
        vector&lt;int&gt; dp(target + 1, 0);
        for(int&amp; n : stones)
            for(int i &#x3D; target; i &gt;&#x3D; n; --i)
                dp[i] &#x3D; max(dp[i], dp[i - n] + n);
        return sum - dp[target] * 2;
    &#125;
&#125;;</code></pre>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h3><h4 id="解法-133"><a href="#解法-133" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、01背包</strong></p>
<p>模板都是差不多的，难点在于将具体问题转化为抽象的01背包模板上去。</p>
<p>假设加法部分总和为 x，那么减法部分总和为 sum - x，我们求的是：<strong>x - （sum - x）== target</strong>，于是我们可以得到加法部分的总和 <strong>x = （sum + target）/ 2</strong>。这就是背包的容量了，是可以直接算出来的。</p>
<p>那么 dp[i] 就表示<strong>装满容量为 i 的背包，有几种方法</strong>。</p>
<p><strong>TODO</strong>：(target + sum) / 2 向下取整会产生影响，why？</p>
<p>在组合问题中，递推公式通常不使用max等，而是用+=。</p>
<h4 id="代码-130"><a href="#代码-130" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;
        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);
        if(abs(target) &gt; sum || (target + sum) % 2)   return 0;
        int size &#x3D; (target + sum) &#x2F; 2;
        vector&lt;int&gt; dp(size + 1, 0);
        dp[0] &#x3D; 1;
        for(int&amp; n : nums)
            for(int i &#x3D; size; i &gt;&#x3D; n; --i)
                dp[i] +&#x3D; dp[i - n];
        return dp[size];
    &#125;
&#125;;</code></pre>

<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h3><h4 id="解法-134"><a href="#解法-134" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、01背包</strong></p>
<p>这题和之前的01最大区别在于，背包的容量是二维的 m x n。也就是说之前模板中的内层循环变为了两层。</p>
<h4 id="代码-131"><a href="#代码-131" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;
        vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
        for(string&amp; s : strs) &#123;
            int one &#x3D; 0, zero &#x3D; 0;
            for(char c : s)
                c &#x3D;&#x3D; &#39;0&#39; ? ++zero : ++one;
            for(int i &#x3D; m; i &gt;&#x3D; zero; --i)
                for(int j &#x3D; n; j &gt;&#x3D; one; --j)
                    dp[i][j] &#x3D; max(dp[i][j], dp[i - zero][j - one] + 1);           
        &#125;
        return dp[m][n];
    &#125;
&#125;;</code></pre>

<h2 id="2023-6-30"><a href="#2023-6-30" class="headerlink" title="2023.6.30"></a>2023.6.30</h2><h3 id="518-零钱兑换-Ⅱ"><a href="#518-零钱兑换-Ⅱ" class="headerlink" title="518.零钱兑换 Ⅱ"></a>518.零钱兑换 Ⅱ</h3><h4 id="解法-135"><a href="#解法-135" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、完全背包</strong></p>
<p>在01背包中，内层遍历背包容量顺序为倒序，是为了保证每个物品仅被使用一次。在完全背包中，每个物品都可无限使用，因此需要按<strong>正序</strong>遍历。求组合数则是按 += 方式计算。</p>
<h4 id="代码-132"><a href="#代码-132" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;
        vector&lt;int&gt; dp(amount + 1, 0);
        dp[0] &#x3D; 1;
        for(int&amp; n : coins)
            for(int i &#x3D; n; i &lt;&#x3D; amount; ++i)
                dp[i] +&#x3D; dp[i - n];
        return dp[amount];
    &#125;
&#125;;</code></pre>

<h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377.组合总和 Ⅳ"></a>377.组合总和 Ⅳ</h3><h4 id="解法-136"><a href="#解法-136" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、完全背包</strong></p>
<p>不同于上题518，这里求的是<strong>排列</strong>。排列可能是一个组合的不同排列方式，因此需要将物品遍历置于内层，若是置于外层，比如本题中：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面。</p>
<p><strong>背包容量放在外循环，将物品放在内循环，内循环从前到后遍历</strong>。注意加上 if 判断越界。</p>
<h4 id="代码-133"><a href="#代码-133" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;int&gt; dp(target + 1, 0);
        dp[0] &#x3D; 1;
        for(int i &#x3D; 0; i &lt;&#x3D; target; ++i)
            for(int n : nums)
                if(i - n &gt;&#x3D; 0 &amp;&amp; dp[i] &lt; INT_MAX - dp[i - n])
                    dp[i] +&#x3D; dp[i - n];
        return dp[target];
    &#125;
&#125;;</code></pre>

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h3><h4 id="解法-137"><a href="#解法-137" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、完全背包</strong></p>
<p>这题求的是最小值，因此不强调排列或是组合，即正常正序遍历，采用min函数即可。</p>
<p>注意初始化不为0，而是INT_MAX，因为要保留较小的值。dp[0] 需要初始化为0用于累加计算。</p>
<h4 id="代码-134"><a href="#代码-134" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;
        vector&lt;int&gt; dp(amount + 1, INT_MAX);
        dp[0] &#x3D; 0;
        for(int&amp; n : coins)
            for(int i &#x3D; n; i &lt;&#x3D; amount; ++i)
                if(dp[i - n] !&#x3D; INT_MAX)
                    dp[i] &#x3D; min(dp[i], dp[i - n] + 1);
        return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount];
    &#125;
&#125;;</code></pre>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h3><h4 id="解法-138"><a href="#解法-138" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、完全背包</strong></p>
<p>这题思路喝上题322完全一致，更简单些。</p>
<h4 id="代码-135"><a href="#代码-135" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    int numSquares(int n) &#123;
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] &#x3D; 0;
        for(int i &#x3D; 1; i * i &lt;&#x3D; n; ++i)
            for(int j &#x3D; i * i; j &lt;&#x3D; n; ++j)
                dp[j] &#x3D; min(dp[j], dp[j - i * i] + 1);
        return dp[n];
    &#125;
&#125;;</code></pre>

<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h3><h4 id="解法-139"><a href="#解法-139" class="headerlink" title="解法"></a>解法</h4><p>基本思路：<strong>动态规划、完全背包</strong></p>
<p>这题有些抽象。。需要些想象力。</p>
<p>dp含义：<strong>dp[i] : 字符串长度为 i 时，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
<p>递推公式：如果确定dp[j] 是true，且 <strong>[j, i]</strong> 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。所以递推公式是 <strong>if( [j, i] 这个区间的子串出现在数组中 &amp;&amp; dp[j])  dp[i] = true</strong>。</p>
<p>初始化：dp[0] 作为递推根基，需初始化为 true，否则后面都是false。</p>
<p>遍历顺序：本题实则求的是排列中的一种，因为多个单词拼成字符串，那么就会要求<strong>单词的前后顺序</strong>。所以<strong>先遍历背包（字符串长度），再遍历物品（数组）</strong>。</p>
<h4 id="代码-136"><a href="#代码-136" class="headerlink" title="代码"></a>代码</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;
        int size &#x3D; s.length();
        vector&lt;bool&gt; dp(size + 1, false);
        dp[0] &#x3D; true;
        for(int i &#x3D; 1; i &lt;&#x3D; size; ++i)
            for(int j &#x3D; 0; j &lt; i; ++j)
                if(find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) !&#x3D; wordDict.end() &amp;&amp; dp[j])
                    dp[i] &#x3D; true;
        return dp[size];
    &#125;
&#125;;</code></pre>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/CPP/">CPP</a></div><div class="post_share"><div class="social-share" data-image="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常用数据结构和算法的CPP实现</div></div></a></div><div class="next-post pull-right"><a href="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--3%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/"><img class="next-cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LeetCode每日一题--3月及以前</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%E5%8E%9F%E7%90%86/LeetCode--2023Q3/" title="LeetCode--2023Q3"><img class="cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-01</div><div class="title">LeetCode--2023Q3</div></div></a></div><div><a href="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--3%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/" title="LeetCode每日一题--3月及以前"><img class="cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">LeetCode每日一题--3月及以前</div></div></a></div><div><a href="/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/" title="常用数据结构和算法的CPP实现"><img class="cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">常用数据结构和算法的CPP实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Szh</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shen962806862"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临 我的快乐</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%8D%A14%E6%9C%88LeetCode"><span class="toc-text">打卡4月LeetCode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-1"><span class="toc-text">2023.4.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#831-%E9%9A%90%E8%97%8F%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF"><span class="toc-text">831.隐藏个人信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E3%80%81%E5%89%91%E6%8C%87-Offer-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-text">54.螺旋矩阵、剑指 Offer 29. 顺时针打印矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-1"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">11.盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-1"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-2"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-3"><span class="toc-text">2023.4.3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1053-%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97"><span class="toc-text">1053.交换一次的先前排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-2"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-3"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">31.下一个排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-3"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-4"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-4"><span class="toc-text">2023.4.4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">46.全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-4"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-5"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-5"><span class="toc-text">2023.4.5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2427-%E5%85%AC%E5%9B%A0%E5%AD%90%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">2427.公因子的数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-6"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-6"><span class="toc-text">2023.4.6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1017-%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">1017.负二进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-5"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-7"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1"><span class="toc-text">47.全排列Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-6"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-8"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">56.合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-7"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-9"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4"><span class="toc-text">57.插入区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-8"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-10"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE0"><span class="toc-text">73.矩阵置0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-9"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-11"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-8"><span class="toc-text">2023.4.8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-text">203.移除链表元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-12"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-text">707.设计链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-10"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-13"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">206.反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-14"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">24.两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-11"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-15"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-9"><span class="toc-text">2023.4.9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2399-%E6%A3%80%E6%9F%A5%E7%9B%B8%E5%90%8C%E5%AD%97%E6%AF%8D%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="toc-text">2399.检查相同字母间的距离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-16"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-1"><span class="toc-text">24.两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-12"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-17"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-10"><span class="toc-text">2023.4.10</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-text">1019.链表中的下一个更大节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-13"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-18"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-text">面试题 02.07.链表相交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-14"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-19"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-1"><span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E2%85%A1"><span class="toc-text">142.环形链表 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-15"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-20"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-text">287.寻找重复数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-16"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-21"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-11"><span class="toc-text">2023.4.11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1041-%E5%9B%B0%E4%BA%8E%E7%8E%AF%E4%B8%AD%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="toc-text">1041.困于环中的机器人</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-17"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-22"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-12"><span class="toc-text">2023.4.12</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1147-%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87"><span class="toc-text">1147.段式回文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-18"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-23"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-13"><span class="toc-text">2023.4.13</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2404-%E5%87%BA%E7%8E%B0%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%81%B6%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-text">2404.出现最频繁的偶数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-19"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-24"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-14"><span class="toc-text">2023.4.14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1023-%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">1023.驼峰式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-20"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-25"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-17"><span class="toc-text">2023.4.17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2409-%E7%BB%9F%E8%AE%A1%E5%85%B1%E5%90%8C%E5%BA%A6%E8%BF%87%E7%9A%84%E6%97%A5%E5%AD%90%E6%95%B0"><span class="toc-text">2409.统计共同度过的日子数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-26"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">242.有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-27"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-text">383.赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-28"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">49.字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-21"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-29"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">438.找到字符串中所有字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-22"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-30"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-22"><span class="toc-text">2023.4.22</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text">349.两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-31"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E2%85%A1"><span class="toc-text">350.两个数组的交集Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-32"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-text">202.快乐数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-33"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-34"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1"><span class="toc-text">454.四数相加Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-23"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-35"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-23"><span class="toc-text">2023.4.23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1105-%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6"><span class="toc-text">1105.填充书架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-24"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-36"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">344.反转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-37"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1"><span class="toc-text">541.反转字符串Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-38"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-text">剑指offer 05.替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-39"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">151.反转字符串中的单词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-25"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-40"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-24"><span class="toc-text">2023.4.24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1163-%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%9C%A8%E6%9C%80%E5%90%8E%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="toc-text">1163.按字典序排在最后的子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-26"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-41"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-25"><span class="toc-text">2023.4.25</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2418-%E6%8C%89%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F"><span class="toc-text">2418.按身高排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-42"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-4-26"><span class="toc-text">2023.4.26</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87offer-58-%E2%85%A1-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">剑指offer 58.Ⅱ 左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-43"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="toc-text">28.找出字符串中第一个匹配项的下标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-27"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-44"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">459.重复的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-45"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%8D%A15%E6%9C%88LeetCode"><span class="toc-text">打卡5月LeetCode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-5-3"><span class="toc-text">2023.5.3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1003-%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"><span class="toc-text">1003.检查替换后的词是否有效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-28"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-46"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-5-16"><span class="toc-text">2023.5.16</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">232.用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-47"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-text">225.用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-48"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">20.有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-49"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-49"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-5-17"><span class="toc-text">2023.5.17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2446-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E4%BA%8B%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81"><span class="toc-text">2446.判断两个事件是否存在冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-50"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-50"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-5-18"><span class="toc-text">2023.5.18</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">1047.删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-51"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-51"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-5-19"><span class="toc-text">2023.5.19</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">150.逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-29"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-52"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-52"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-5-26"><span class="toc-text">2023.5.26</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">1091.二进制矩阵中的最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-30"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-53"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-53"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%8D%A16%E6%9C%88LeetCode"><span class="toc-text">打卡6月LeetCode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-5"><span class="toc-text">2023.6.5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2460-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-text">2460.对数组执行操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-54"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-54"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">239.滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-31"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-55"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-55"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">347.前K个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-32"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-56"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-56"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-7"><span class="toc-text">2023.6.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2611-%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA"><span class="toc-text">2611.老鼠和奶酪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-33"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-57"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-57"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-13"><span class="toc-text">2023.6.13</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">144.二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-58"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-58"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">94.二叉树的中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-59"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-59"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">145.二叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-60"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-60"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102.二叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E2%85%A1"><span class="toc-text">107.二叉树的层序遍历Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-34"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-61"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-61"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-14"><span class="toc-text">2023.6.14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">226.翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-62"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-62"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">589.N叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">590.N叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-63"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-63"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-text">199.二叉树的右视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-35"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-64"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-64"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-text">637.二叉树的层平均值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-65"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-65"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">429.N叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-66"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">515.在每个树行中找最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-66"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-67"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">116.填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-%E2%85%A1"><span class="toc-text">117.填充每个节点的下一个右侧节点指针 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-36"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-67"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-68"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">104.二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-68"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-text">111.二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-69"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">101.对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-70"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-69"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E9%A2%98%E7%9B%AE"><span class="toc-text">相似题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-text">100.相同的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">572.另一个树的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">222.完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-37"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-71"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-70"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">110.平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-38"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-72"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-71"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">257.二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-39"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-73"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-72"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-15"><span class="toc-text">2023.6.15</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-text">404.左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-74"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-73"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text">513.找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-40"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-75"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-74"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">112.路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-41"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-76"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-75"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-%E2%85%A1"><span class="toc-text">113.路径总和 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-42"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-77"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-76"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">106.从中序和后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-43"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-78"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-77"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-text">相关题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105.从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-79"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">654.最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-44"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-80"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-78"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-18"><span class="toc-text">2023.6.18</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">617.合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-81"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-79"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-text">700.二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-82"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-80"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98.验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-45"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-83"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">530.二叉搜索树的最小绝对差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-46"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-84"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-82"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">501.二叉搜索树中的众数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-47"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-85"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-83"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">236.二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-48"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-86"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-84"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-19"><span class="toc-text">2023.6.19</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">235.二叉搜索树的公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-87"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-85"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">701.二叉搜索树的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-88"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-86"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450.删除二叉搜索树的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-89"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-87"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">669.修剪二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-49"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-90"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-88"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">108.将有序数组转化为二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-50"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-91"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-89"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-text">538.把二叉搜索树转换为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-51"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-92"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-90"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-20"><span class="toc-text">2023.6.20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-text">77.组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-52"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-93"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-91"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-1"><span class="toc-text">相关题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A2"><span class="toc-text">216.组合总和 Ⅲ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-94"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">17.电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-95"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-92"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39.组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-53"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-96"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-93"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A1"><span class="toc-text">40.组合总和 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-54"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-97"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-94"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-21"><span class="toc-text">2023.6.21</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">131.分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-55"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-98"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-95"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-text">93.复原IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-56"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-99"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-96"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-22"><span class="toc-text">2023.6.22</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-text">78.子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-57"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-100"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-97"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-2"><span class="toc-text">相关题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-%E5%AD%90%E9%9B%86-%E2%85%A1"><span class="toc-text">90.子集 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-58"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-101"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-98"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">491.递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-59"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-102"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-99"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-1"><span class="toc-text">46.全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-60"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-103"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-100"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-3"><span class="toc-text">相关题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-%E2%85%A1"><span class="toc-text">47.全排列 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-61"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-104"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-101"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="toc-text">332.重新安排行程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-62"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-105"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-102"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E"><span class="toc-text">51.N皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-63"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-106"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-103"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-text">37.解数独</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-64"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-107"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-104"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-24"><span class="toc-text">2023.6.24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-text">455.分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-108"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-105"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">53.最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-65"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-109"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-106"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-25"><span class="toc-text">2023.6.25</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">122.买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-110"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-107"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">55.跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-111"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-108"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-%E2%85%A1"><span class="toc-text">45.跳跃游戏 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-112"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-109"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1005-K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">1005.K 次取反后最大化的数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-113"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-110"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-text">134.加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-114"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-111"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-text">135.分发糖果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-115"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-112"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-text">860.柠檬水找零</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-116"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-113"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-text">406.根据身高重建队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-117"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-114"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-26"><span class="toc-text">2023.6.26</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-text">452.用最少数量的箭引爆气球</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-118"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-115"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-text">435.无重叠区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-119"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-116"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-text">763.划分字母区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-120"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-117"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-1"><span class="toc-text">56.合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-121"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-118"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">738.单调递增的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-122"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-119"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">968.监控二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-123"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-120"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-27"><span class="toc-text">2023.6.27</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">509.斐波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-124"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-121"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">70.爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-125"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-122"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">746.使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-126"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-123"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-28"><span class="toc-text">2023.6.28</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">62.不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-127"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-124"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E2%85%A1"><span class="toc-text">63.不同路径 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-128"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-125"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-text">343.整数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-129"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-126"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">96.不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-130"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-127"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">相关概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-29"><span class="toc-text">2023.6.29</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416.分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-131"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-128"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-%E2%85%A1"><span class="toc-text">1049.最后一块石头的重量 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-132"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-129"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">494.目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-133"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-130"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-text">474.一和零</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-134"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-131"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-6-30"><span class="toc-text">2023.6.30</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-%E2%85%A1"><span class="toc-text">518.零钱兑换 Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-135"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-132"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-text">377.组合总和 Ⅳ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-136"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-133"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">322.零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-137"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-134"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">279.完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-138"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-135"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-text">139.单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-139"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-136"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/LeetCode--2023Q3/" title="LeetCode--2023Q3"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode--2023Q3"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/LeetCode--2023Q3/" title="LeetCode--2023Q3">LeetCode--2023Q3</a><time datetime="2023-07-01T02:01:40.000Z" title="发表于 2023-07-01 10:01:40">2023-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BACPP/" title="查漏补缺CPP"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="查漏补缺CPP"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BACPP/" title="查漏补缺CPP">查漏补缺CPP</a><time datetime="2023-06-20T08:08:36.000Z" title="发表于 2023-06-20 16:08:36">2023-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/" title="常用数据结构和算法的CPP实现"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用数据结构和算法的CPP实现"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/" title="常用数据结构和算法的CPP实现">常用数据结构和算法的CPP实现</a><time datetime="2023-06-06T01:55:34.000Z" title="发表于 2023-06-06 09:55:34">2023-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Szh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>