<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>LeetCode每日一题 | 小涵的米奇妙妙屋</title><meta name="keywords" content="算法,CPP"><meta name="author" content="Szh"><meta name="copyright" content="Szh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录每日一题2022.11.4754.到达终点数字题干在一根无限长的数轴上，你站在0的位置，终点在target的位置。 你可以做一些数量的移动 numMoves :  每次你可以选择向左或向右移动。 第 i 次移动（从  i &#x3D;&#x3D; 1 开始，到 i &#x3D;&#x3D; numMoves ），在选择的方向上走 i 步。  给定整数 target ，返回：到达目标所需的最小移动次数(即最小 numMoves）">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode每日一题">
<meta property="og:url" content="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/index.html">
<meta property="og:site_name" content="小涵的米奇妙妙屋">
<meta property="og:description" content="记录每日一题2022.11.4754.到达终点数字题干在一根无限长的数轴上，你站在0的位置，终点在target的位置。 你可以做一些数量的移动 numMoves :  每次你可以选择向左或向右移动。 第 i 次移动（从  i &#x3D;&#x3D; 1 开始，到 i &#x3D;&#x3D; numMoves ），在选择的方向上走 i 步。  给定整数 target ，返回：到达目标所需的最小移动次数(即最小 numMoves）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/3.jpg">
<meta property="article:published_time" content="2022-11-04T06:33:06.000Z">
<meta property="article:modified_time" content="2023-03-04T17:31:57.054Z">
<meta property="article:author" content="Szh">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/3.jpg"><link rel="shortcut icon" href="/img/Sign.ico"><link rel="canonical" href="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a8ed5b37dd0aaae924c52eb382109c5d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode每日一题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-05 01:31:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 脚本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/scripts/genshin/"><i class="fa-fw fas fa-gamepad"></i><span> 我焯!原!</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小涵的米奇妙妙屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 脚本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/scripts/genshin/"><i class="fa-fw fas fa-gamepad"></i><span> 我焯!原!</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode每日一题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-04T06:33:06.000Z" title="发表于 2022-11-04 14:33:06">2022-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-04T17:31:57.054Z" title="更新于 2023-03-05 01:31:57">2023-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8E%9F%E7%90%86/">原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.3k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode每日一题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="记录每日一题"><a href="#记录每日一题" class="headerlink" title="记录每日一题"></a>记录每日一题</h1><h2 id="2022-11-4"><a href="#2022-11-4" class="headerlink" title="2022.11.4"></a>2022.11.4</h2><h3 id="754-到达终点数字"><a href="#754-到达终点数字" class="headerlink" title="754.到达终点数字"></a>754.到达终点数字</h3><h4 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h4><p>在一根无限长的数轴上，你站在<strong>0</strong>的位置，终点在<strong>target</strong>的位置。</p>
<p>你可以做一些数量的移动 <strong>numMoves</strong> :</p>
<ul>
<li>每次你可以选择向左或向右移动。</li>
<li>第 <strong>i</strong> 次移动（从  i == <strong>1</strong> 开始，到 i == <strong>numMoves</strong> ），在选择的方向上走 <strong>i</strong> 步。</li>
</ul>
<p>给定整数 <strong>target</strong> ，返回：到达目标所需的最小移动次数(即最小 <strong>numMoves</strong>）</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">输入: target &#x3D; 2
输出: 3
解释:
第一次移动，从 0 到 1; 第二次移动，从 1 到 -1; 第三次移动，从 -1 到 2 。</code></pre>

<pre class="language-none"><code class="language-none">输入: target &#x3D; 3
输出: 2
解释:
第一次移动，从 0 到 1; 第二次移动，从 1 到 3 。</code></pre>

<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>本题主要偏向于数学计算，代码性不强。</p>
<p>首先target关于0对称，因此正负与<strong>numMoves</strong>无关，为便于计算，将<strong>target</strong>统一为正数。</p>
<p>分析从最简单的情况开始：</p>
<ul>
<li><strong>向右走numMoves步</strong></li>
</ul>
<ol>
<li>未达到<strong>target</strong>。那就继续走。</li>
<li>正好达到<strong>target</strong>。此时<strong>numMoves</strong>为最小值，return。</li>
<li>越过了<strong>target</strong>。</li>
</ol>
<ul>
<li><strong>越过target后，到达dist。同有三种情况</strong></li>
</ul>
<ol>
<li><strong>dist</strong>与<strong>target</strong>差值为偶数，最好解决，只需要将某些步的方向变为左，一加变一减，就可以弥补差值，正好到达target。此时返回值不变，仍为 <strong>numMoves</strong> 。</li>
<li>差值为奇数，此时需要 <strong>numMoves++</strong> ，多走一步，若差值变为偶数（<strong>此时差值为奇数，走的步长也为奇数，和就是偶数</strong>），则问题转化为上1，返回值为 <strong>numMoves + 1</strong> 。</li>
<li>多走一步，差值仍为奇数，此时再走一步，差值必然变为偶数（同上，<strong>走两步的步长必然是一奇一偶，奇数+奇数必是偶数</strong>），转化为上1，返回值为<strong>numMoves + 2</strong>。</li>
</ol>
<p>以上，代码转化为判断<strong>numMoves</strong>当前的步长和是否越过了target，以及越过后与target的差值的奇偶。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int reachNumber(int target) &#123;
    target &#x3D; abs(target);
    int dist &#x3D; 0, numMoves &#x3D; 0;
    while(dist &lt; target || (dist - target) % 2)&#123;
        numMoves++;
        dist +&#x3D; numMoves;
    &#125;
    return numMoves;
&#125;</code></pre>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><img src="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20221104152911835.png" alt="image-20221104152911835" style="zoom:67%;">

<pre class="language-c++" data-language="c++"><code class="language-c++">int reachNumber(int target) &#123;
    target &#x3D; abs(target);
    int n &#x3D; ceil((-1 + sqrt(8L * target + 1)) &#x2F; 2); &#x2F;&#x2F; 注意 8*target 会超过 int 范围
    return (n * (n + 1) &#x2F; 2 - target) % 2 &#x3D;&#x3D; 0 ? n : n + 1 + n % 2;
&#125;</code></pre>



<h2 id="2022-11-7"><a href="#2022-11-7" class="headerlink" title="2022.11.7"></a>2022.11.7</h2><h3 id="816-模糊坐标"><a href="#816-模糊坐标" class="headerlink" title="816.模糊坐标"></a>816.模糊坐标</h3><h4 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h4><p>我们有一些二维坐标，如 <strong>“(1, 3)”</strong> 或 “(2, 0.5)”，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。</p>
<p>原始的坐标表示法不会存在多余的零，所以不会出现类似于**”00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”<strong>或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现</strong>“.1”**形式的数字。</p>
<p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入: &quot;(123)&quot;
输出: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入: &quot;(00011)&quot;
输出:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]
解释: 0.0, 00, 0001 或 00.01 是不被允许的。</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入: &quot;(100)&quot;
输出: [(10, 0)]
解释: 1.0 是不被允许的</code></pre>

<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>本题实际是两次二分，先将字符串用 <strong>“, ”</strong> 分为两部分，再用 <strong>“.”</strong> 分别插入到这两部分中的每个位置，判断是否为一个符合要求的字符串。</p>
<p>最简单的暴力解法：</p>
<ol>
<li>for循环从每个位置将字符串分为A、B两部分；</li>
<li>对每个A、B，再次for循环从每个位置插入  <strong>“.”</strong> ，将符合要求的字符串分别存入vector；</li>
<li>最后用双for循环从两个vector中取值排列组合，存入返回值的vector中。</li>
</ol>
<p>仅在插入 <strong>“.”</strong> 时，需要考虑以下异常情况：</p>
<ul>
<li>若A、B为 <strong>“0”</strong> 或<strong>首位非0</strong>，则其整体为一个有效字符串存储。</li>
<li>for循环插入小数点时，若遇到<strong>首位为0</strong>时，仅允许在0后插入。</li>
<li>for循环插入小数点时，若遇到<strong>末位为0</strong>时，不允许插入。</li>
</ul>
<p><strong>有限状态机：</strong></p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/1667803747-acpQEa-%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="状态图.png"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; classifyNumber(string s)&#123;
        vector&lt;string&gt; rst;
        if(s &#x3D;&#x3D; &quot;0&quot; || s[0] !&#x3D; &#39;0&#39;) rst.push_back(s);
        for(int i &#x3D; 1; i &lt; s.size(); ++i)&#123;
            if(i !&#x3D; 1 &amp;&amp; s[0] &#x3D;&#x3D; &#39;0&#39; || s.back() &#x3D;&#x3D; &#39;0&#39;) continue;
            rst.push_back(s.substr(0, i) + &quot;.&quot; + s.substr(i));
        &#125;
        return rst; 
    &#125;
    vector&lt;string&gt; ambiguousCoordinates(string s) &#123;
        vector&lt;string&gt; rst;
        s &#x3D; s.substr(1, s.size() - 2);
        for(int i &#x3D; 1; i &lt; s.size(); ++i)&#123;
            vector&lt;string&gt; lnum &#x3D; classifyNumber(s.substr(0, i));
            if(lnum.empty())    continue;
            vector&lt;string&gt; rnum &#x3D; classifyNumber(s.substr(i));
            if(rnum.empty())    continue;
            for(int i &#x3D; 0; i &lt; lnum.size(); i++)&#123;
                for(int j &#x3D; 0; j &lt; rnum.size(); j++)&#123;
                    rst.push_back(&quot;(&quot; + lnum[i] + &quot;, &quot; + rnum[j] + &quot;)&quot;);
                &#125;
            &#125;
        &#125;
        return rst;
    &#125;
&#125;;</code></pre>

<p>for循环中，相比于**++i<strong>，</strong>i++<strong>需要多开辟一个</strong>临时变量来存储i自加后的值**，因此前者性能更好。</p>
<h2 id="2022-11-8"><a href="#2022-11-8" class="headerlink" title="2022.11.8"></a>2022.11.8</h2><h3 id="1684-统一一致字符串的数目"><a href="#1684-统一一致字符串的数目" class="headerlink" title="1684.统一一致字符串的数目"></a>1684.统一一致字符串的数目</h3><h4 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h4><p>给你一个由不同字符组成的字符串 <strong>allowed</strong> 和一个字符串数组 <strong>words 。如果</strong>一个字符串的每一个字符都在 <strong>allowed</strong> 中，就称这个字符串是 一致字符串 。</p>
<p>请你返回 <strong>words</strong> 数组中 <strong>一致字符串</strong> 的数目。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：allowed &#x3D; &quot;ab&quot;, words &#x3D; [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;]
输出：2
解释：字符串 &quot;aaab&quot; 和 &quot;baa&quot; 都是一致字符串，因为它们只包含字符 &#39;a&#39; 和 &#39;b&#39; 。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：allowed &#x3D; &quot;abc&quot;, words &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;]
输出：7
解释：所有字符串都是一致的。</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：allowed &#x3D; &quot;cad&quot;, words &#x3D; [&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;]
输出：4
解释：字符串 &quot;cc&quot;，&quot;acd&quot;，&quot;ac&quot; 和 &quot;d&quot; 是一致字符串。</code></pre>

<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p>本题实际是如何判断一个字符串中的每个字符是否都在另一个字符串中出现过的问题。</p>
<p>最简单的暴力解法就是循环words中字符串的每个字符与allowed中的每个字符进行比较，看是否都能匹配上，全匹配上了计数加一。有无法匹配到的跳出循环，判断该字符串为不一致。</p>
<p><strong>解法2：位运算</strong></p>
<p>定义一个32位的int变量，26个字符，各占一位，占据低26位；通过将字符与 <strong>‘a’</strong> 作差计算相应字符需要向左移位多少。某一位为1，表示该位对应的字符存在。</p>
<p>计算出<strong>allowed</strong>字符串对应的int值<strong>standard</strong>，和<strong>words</strong>中的每个字符串对应的值作或运算，若仍为<strong>standard</strong>原值，说明该字符串的字符均在<strong>allowed</strong>中，计数num++。</p>
<p><strong>相比于暴力循环，在内存消耗差不多的情况下，提高了1/3速度。</strong></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) &#123;
        int num &#x3D; 0;
        auto convert &#x3D; [](string&amp; str)&#123;
            int rst &#x3D; 0;
            for(int i &#x3D; 0; i &lt; str.length(); ++i)&#123;
                rst |&#x3D; 1 &lt;&lt; (str[i] - &#39;a&#39;);
            &#125;
            return rst;
        &#125;;
        int standard &#x3D; convert(allowed);
        for(int i &#x3D; 0; i &lt; words.size(); ++i)&#123;
            if (standard &#x3D;&#x3D; (standard | convert(words[i])))
                num++;
        &#125;
        return num;
    &#125;
&#125;;</code></pre>

<p>这里使用了匿名函数的方式来封装统一的转换方法。好处是可以免去函数的声明和定义。这样匿名函数<strong>仅在调用函数的时候才会创建函数对象，而调用结束后立即释放</strong>，所以匿名函数比非匿名函数<strong>更节省空间</strong>。</p>
<h2 id="2022-11-9"><a href="#2022-11-9" class="headerlink" title="2022.11.9"></a>2022.11.9</h2><h3 id="764-最大加号标志"><a href="#764-最大加号标志" class="headerlink" title="764.最大加号标志"></a>764.最大加号标志</h3><h4 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h4><p>在一个 <strong>n x n</strong> 的矩阵 <strong>grid</strong> 中，除了在数组 <strong>mines</strong> 中给出的元素为 0，其他每个元素都为 1。**mines[i] = [xi, yi]**表示 <strong>grid[xi][yi] == 0</strong></p>
<p>返回  <strong>grid</strong> 中包含 1 的<strong>最大的 轴对齐 加号标志</strong>的阶数 。如果未找到加号标志，则返回 0 。</p>
<p>一个 <strong>k</strong> 阶由 1 组成的 “轴对称”加号标志 具有中心网格 <strong>grid[r][c] == 1</strong> ，以及4个从中心向上、向下、向左、向右延伸，长度为 <strong>k-1</strong>，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。</p>
<p><strong>示例</strong></p>
<img src="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/plus1-grid.jpg" alt="img" style="zoom:50%;">

<pre class="language-none"><code class="language-none">示例 1:
输入: n &#x3D; 5, mines &#x3D; [[4, 2]]
输出: 2
解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。</code></pre>

<img src="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/plus2-grid.jpg" alt="img" style="zoom:67%;">

<pre class="language-none"><code class="language-none">示例 2:
输入: n &#x3D; 1, mines &#x3D; [[0, 0]]
输出: 0
解释: 没有加号标志，返回 0 。</code></pre>

<h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h4><p>本题实际是一个动态规划问题。动态规划的核心思想就是——<strong>拆分子问题，记住过往，减少重复计算</strong></p>
<p>题中要求十字的最大阶数，但实际上<strong>最大阶数是由中心到四个方向上的连续1数量中的最小值决定的。</strong>那么问题转变为了：先求每个点为中心到四个方向上的连续1数量中的最小值，再从中取最大值。</p>
<p>如何求四个方向的最小值？假设简化一下，只求左方向的值怎么求？只需要计算每个点左边最长的连续1的格子数，那么十字就是上述的四次重复。初始化时先假设每个点连续1的数量均为网格的宽度n（即最大值），维护一个<strong>自加变量left</strong>记录连续1的数量。当在一行中从左向右遍历时，如果<strong>遇到0，自加变量清零，否则left++。</strong>每次自加后与原先该点记录的值取最小值，更新该点的值。</p>
<p>在重复时，同一个点都会经过四个方向的遍历，但只会保留到四个方向里面的最小值了。遍历结束后，得到一个二维的记录每个点最大十字阶数的向量，取里面的最大值即可。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) &#123;
        &#x2F;&#x2F; 初始化矩阵
        vector&lt;vector&lt;int&gt; &gt; grid(n, vector&lt;int&gt;(n, n));
        for(int i &#x3D; 0; i &lt; mines.size(); ++i)
            grid[mines[i][0]][mines[i][1]] &#x3D; 0;
        &#x2F;&#x2F; 遍历
        int left, right, top, bottom;
        for(int i &#x3D; 0; i &lt; n; ++i)&#123;
            left &#x3D; 0; right &#x3D; 0; top &#x3D; 0; bottom &#x3D; 0;
            for(int j &#x3D; 0, k &#x3D; n - 1; j &lt; n; ++j, --k)&#123;
                left &#x3D; grid[i][j] ? left + 1 : 0;
                right &#x3D; grid[i][k] ? right + 1 : 0;
                top &#x3D; grid[j][i] ? top + 1 : 0;
                bottom &#x3D; grid[k][i] ? bottom + 1 : 0;
                grid[i][j] &#x3D; left &lt; grid[i][j] ? left : grid[i][j];
                grid[i][k] &#x3D; right &lt; grid[i][k] ? right : grid[i][k];
                grid[j][i] &#x3D; top &lt; grid[j][i] ? top : grid[j][i];
                grid[k][i] &#x3D; bottom &lt; grid[k][i] ? bottom : grid[k][i];
            &#125;
        &#125;
        int max &#x3D; 0;
        for(int i &#x3D; 0; i &lt; n; ++i)&#123;
            for(int j &#x3D; 0; j &lt; n; ++j)&#123;
                if (max &lt; grid[i][j])   max &#x3D; grid[i][j];
            &#125;
        &#125;
        return max;
    &#125;
&#125;;</code></pre>

<p>注：vector的初始化方式。</p>
<p>vector采用</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(auto&amp; item : vector)</code></pre>

<p>的形式遍历较为方便，但是速度较普通for循环更慢，但是不用担心越界问题。</p>
<h2 id="2022-11-11"><a href="#2022-11-11" class="headerlink" title="2022.11.11"></a>2022.11.11</h2><h3 id="1704-判断字符串的两半是否相似"><a href="#1704-判断字符串的两半是否相似" class="headerlink" title="1704.判断字符串的两半是否相似"></a>1704.判断字符串的两半是否相似</h3><h4 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h4><p>给你一个偶数长度的字符串 <strong>s</strong> 。将其拆分成长度相同的两半，前一半为 <strong>a</strong> ，后一半为 <strong>b</strong> 。</p>
<p>两个字符串 <strong>相似</strong> 的前提是它们都含有<strong>相同数目的元音</strong>（**’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’<strong>）。注意，</strong>s** 可能同时含有大写和小写字母。</p>
<p>如果 <strong>a</strong> 和 <strong>b</strong> 相似，返回 <strong>true</strong> ；否则，返回 <strong>false</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：s &#x3D; &quot;book&quot;
输出：true
解释：a &#x3D; &quot;bo&quot; 且 b &#x3D; &quot;ok&quot; 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：s &#x3D; &quot;textbook&quot;
输出：false
解释：a &#x3D; &quot;text&quot; 且 b &#x3D; &quot;book&quot; 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。</code></pre>

<h4 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h4><p>本题实际就是一次for循环，对字符串s的每个字符判断一次是否为元音即可，中间记录下前后半的元音个数。</p>
<p>可优化的点在于</p>
<p>1.不必for循环整个字符串，由于a、b长度相同，可以只<strong>for循环前一半</strong>（类似双指针？）。</p>
<p>2.只需<strong>维护一个变量</strong>记录元音数量即可，左加右减，节约内存。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool halvesAreAlike(string s) &#123;
        auto isVowel &#x3D; [](char c)&#123;
            int val &#x3D; c - &#39;A&#39;;
            if (val &#x3D;&#x3D; 0 || val &#x3D;&#x3D; 4 || val &#x3D;&#x3D; 8 || val &#x3D;&#x3D; 14 || val &#x3D;&#x3D; 20 
             || val &#x3D;&#x3D; 32 || val &#x3D;&#x3D; 36 || val &#x3D;&#x3D; 40 || val &#x3D;&#x3D; 46 || val &#x3D;&#x3D; 52 )
                return true;
            else
                return false;
        &#125;;
        int cnt &#x3D; 0;
        int len &#x3D; s.length() &#x2F; 2;
        for(int i &#x3D; 0; i &lt; len; ++i)&#123;
            cnt +&#x3D; isVowel(s[i]) ? 1 : 0;
            cnt -&#x3D; isVowel(s[i + len]) ? 1 : 0;
        &#125;
        return cnt &#x3D;&#x3D; 0;
    &#125;
&#125;;</code></pre>

<p>我这里直接写了个匿名函数通过ASCII的差值判断是否为元音，还可以用<strong>集合</strong>。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">unordered_set&lt;char&gt; vowels &#x3D; &#123;&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;, &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;&#125;;
cnt +&#x3D; vowels.count(s[i]);</code></pre>



<h2 id="2022-12-6"><a href="#2022-12-6" class="headerlink" title="2022.12.6"></a>2022.12.6</h2><h3 id="1805-字符串中不同整数的数目"><a href="#1805-字符串中不同整数的数目" class="headerlink" title="1805.字符串中不同整数的数目"></a>1805.字符串中不同整数的数目</h3><h4 id="题干-5"><a href="#题干-5" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串 <strong>word</strong> ，该字符串由<strong>数字</strong>和<strong>小写英文字母</strong>组成。</p>
<p>请你用空格替换每个不是数字的字符。例如，**”a123bc34d8ef34”** 将会变成 <strong>“ 123  34 8  34”</strong> 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：**”123”、”34”、”8”** 和 <strong>“34”</strong> 。</p>
<p>返回对 <strong>word</strong> 完成替换后形成的 <strong>不同</strong> 整数的数目。</p>
<p>只有当两个整数的 <strong>不含前导零</strong> 的十进制表示不同， 才认为这两个整数也不同。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：word &#x3D; &quot;a123bc34d8ef34&quot;
输出：3
解释：不同的整数有 &quot;123&quot;、&quot;34&quot; 和 &quot;8&quot; 。注意，&quot;34&quot; 只计数一次。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：word &#x3D; &quot;leet1234code234&quot;
输出：2</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：word &#x3D; &quot;a1b01c001&quot;
输出：1
解释：&quot;1&quot;、&quot;01&quot; 和 &quot;001&quot; 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</code></pre>

<h4 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h4><p>本题解法就是双指针和C++集合不能有重复项特点的应用。</p>
<p>先用一个头指针 <strong>i</strong> ，for循环遍历字符串的每一项，判断是否为数字（ASCII码值小于58，0<del>9是48</del>57），如果为数字，进行三步操作：</p>
<p>1.使用另一个指针 <strong>j</strong> ，从 <strong>i</strong> 处开始向后扫，直到扫到非数字字符。</p>
<p>2.移动 <strong>i</strong> ，从该串数字的最高位开始判断有无0，有前导0的位全部去掉。</p>
<p>3.将过滤后的字符串加入集合Set中。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int numDifferentIntegers(string word) &#123;
        set&lt;string&gt; nums;
        int j, len &#x3D; word.length();
        for(int i &#x3D; 0; i &lt; len; i++)&#123;
            if(word[i] &lt; 58)&#123;
                j &#x3D; i;
                while(word[j] &lt; 58 &amp;&amp; j &lt; len)  j++;
                while(word[i] &#x3D;&#x3D; 48 &amp;&amp; j - i &gt; 1)  i++;
                nums.insert(word.substr(i, j - i));
                i &#x3D; j;
            &#125;
        &#125;
        return nums.size();
    &#125;
&#125;;</code></pre>



<h2 id="2022-12-7"><a href="#2022-12-7" class="headerlink" title="2022.12.7"></a>2022.12.7</h2><h3 id="1775-通过最少操作次数使数组的和相等"><a href="#1775-通过最少操作次数使数组的和相等" class="headerlink" title="1775.通过最少操作次数使数组的和相等"></a>1775.通过最少操作次数使数组的和相等</h3><h4 id="题干-6"><a href="#题干-6" class="headerlink" title="题干"></a>题干</h4><p>给你两个长度可能不等的整数数组 <strong>nums1</strong> 和 <strong>nums2</strong> 。两个数组中的所有值都在 <strong>1</strong> 到 <strong>6</strong> 之间（<strong>包含 1 和 6</strong>）。</p>
<p>每次操作中，你可以选择 <strong>任意</strong> 数组中的<strong>任意一个整数</strong>，将它变成 <strong>1</strong> 到 <strong>6</strong> 之间 <strong>任意</strong> 的值（<strong>包含 1 和 6</strong>）。</p>
<p>请你返回使 <strong>nums1</strong> 中所有数的和与 <strong>nums2</strong> 中所有数的和<strong>相等的最少操作次数</strong>。如果无法使两个数组的和相等，请返回 <strong>-1</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [1,1,2,2,2,2]
输出：3
解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums2[0] 变为 6 。 nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [6,1,2,2,2,2] 。
- 将 nums1[5] 变为 1 。 nums1 &#x3D; [1,2,3,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。
- 将 nums1[2] 变为 2 。 nums1 &#x3D; [1,2,2,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：nums1 &#x3D; [1,1,1,1,1,1,1], nums2 &#x3D; [6]
输出：-1
解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：nums1 &#x3D; [6,6], nums2 &#x3D; [1]
输出：3
解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。
- 将 nums1[0] 变为 2 。 nums1 &#x3D; [2,6], nums2 &#x3D; [1] 。
- 将 nums1[1] 变为 2 。 nums1 &#x3D; [2,2], nums2 &#x3D; [1] 。
- 将 nums2[0] 变为 4 。 nums1 &#x3D; [2,2], nums2 &#x3D; [4] 。</code></pre>

<h4 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h4><p>本题用到了贪心思想，即<strong>一个问题拆解成多个步骤，每个步骤采用最优的解法。</strong></p>
<p>在本题中，要让两个数组以最少步骤达到和相同，就代表每一步缩小的差距越大越好，也就是**优先把和小的数组里的 1 变成 6 ，把和大的数组中的 6 变成 1.**以此类推，接下来是5、2；4、3······当走到其中一步时差距缩小为非正数时，说明该步就是最后一步了。</p>
<p>并且1变6和6变1的意义是相同的，都是缩小了5的差距，因此从节约空间的角度考虑，可以只维护一个长度为6的1维数组，记录操作的分布情况（缩小543210的差距）。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        int diff &#x3D; accumulate(nums1.begin(), nums1.end(), 0) - accumulate(nums2.begin(), nums2.end(), 0);
        if (diff &lt; 0)    return minOperations(nums2, nums1);
        if (diff &#x3D;&#x3D; 0)   return 0;
        int cnt[6] &#x3D; &#123;0&#125;;
        int i &#x3D; 0, count &#x3D; 0;
        for(;i &lt; nums1.size();++i) ++cnt[nums1[i] - 1];
        for(i &#x3D; 0;i &lt; nums2.size();++i) ++cnt[6 - nums2[i]];
        for(i &#x3D; 5;i &gt; 0; --i)&#123;
            while(cnt[i] &gt; 0 &amp;&amp; diff &gt; 0)&#123;
                diff -&#x3D; i;
                --cnt[i];
                count++;
            &#125;
        &#125;
        return diff &gt; 0 ? -1 : count;
    &#125;
&#125;;</code></pre>

<p>accumulate属于numeric头文件，作用是计算数组或C++容器指定地址范围内的成员的和。</p>
<p>参数1、2分别为 <strong>容器 / 数组 指向要计算的第一个元素和最后一个元素的 迭代器 / 首地址</strong> ，参数3为<strong>累加的初始值</strong>。</p>
<p>这里为了下面for循环存储操作的分布情况，固定了nums1的和要大于nums2；若是小于，就<strong>调换输入顺序重新执行函数</strong>（这里测试过，相比于swap调换两个vector，这种方式要快一些）。这里心机的把 <strong>diff == 0</strong> 的情况放在了 <strong>diff &lt; 0</strong> 下面，大部分情况下应该都是不相等的，这样可以少点计算量（dog）。</p>
<h2 id="2022-12-9"><a href="#2022-12-9" class="headerlink" title="2022.12.9"></a>2022.12.9</h2><h3 id="1780-判断一个数字是否可以表示成三的幂的和"><a href="#1780-判断一个数字是否可以表示成三的幂的和" class="headerlink" title="1780.判断一个数字是否可以表示成三的幂的和"></a>1780.判断一个数字是否可以表示成三的幂的和</h3><h4 id="题干-7"><a href="#题干-7" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数 <strong>n</strong> ，如果你可以将 <strong>n</strong> 表示成若干个<strong>不同的三的幂之和</strong>，请你返回 <strong>true</strong> ，否则请返回 <strong>false</strong> 。</p>
<p>对于一个整数 <strong>y</strong> ，如果存在整数 <strong>x</strong> 满足 <strong>y == 3^x</strong> ，我们称这个整数 <strong>y</strong> 是三的<strong>幂</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：n &#x3D; 12
输出：true
解释：12 &#x3D; 3^1 + 3^2</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：n &#x3D; 91
输出：true
解释：91 &#x3D; 3^0 + 3^2 + 3^4</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：n &#x3D; 21
输出：false </code></pre>

<h4 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>看示例1可知，满足条件的数为3的不同次幂的和，那么必然<strong>能被3整除</strong>，看示例2可知另一情况，<strong>3^0为1</strong>，也就是<strong>除以3余数为1</strong>，但是也满足条件。<strong>当示例1中除以3，得到4，又变成了示例2的情况，即3^0 + 3的幂。</strong></p>
<p>于是得到满足条件的整数一定具有以下性质：</p>
<ol>
<li>除以3以后余数必为1或0；</li>
<li>性质1得到的商依旧满足性质1，直至商为0。</li>
</ol>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool checkPowersOfThree(int n) &#123;
        while(n)&#123;
            if (n % 3 &#x3D;&#x3D; 2) return false;
            n &#x2F;&#x3D; 3;
        &#125;
        return true;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-8"><a href="#2023-2-8" class="headerlink" title="2023.2.8"></a>2023.2.8</h2><h3 id="1233-删除子文件夹（未完结）"><a href="#1233-删除子文件夹（未完结）" class="headerlink" title="1233.删除子文件夹（未完结）"></a>1233.删除子文件夹（未完结）</h3><h4 id="题干-8"><a href="#题干-8" class="headerlink" title="题干"></a>题干</h4><p>你是一位系统管理员，手里有一份文件夹列表 <strong>folder</strong>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p>
<p>如果文件夹 <strong>folder[i]</strong> 位于另一个文件夹 <strong>folder[j]</strong> 下，那么 <strong>folder[i]</strong> 就是 <strong>folder[j]</strong> 的 子文件夹 。</p>
<p>文件夹的<strong>「路径」</strong>是由一个或多个按以下格式串联形成的字符串：**’/‘** 后跟<strong>一个或者多个小写英文字母</strong>。</p>
<p>例如，”<strong>/leetcode</strong>“ 和 “<strong>/leetcode/problems</strong>“ 都是有效的路径，而<strong>空字符串和 “/“ 不是</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：folder &#x3D; [&quot;&#x2F;a&quot;,&quot;&#x2F;a&#x2F;b&quot;,&quot;&#x2F;c&#x2F;d&quot;,&quot;&#x2F;c&#x2F;d&#x2F;e&quot;,&quot;&#x2F;c&#x2F;f&quot;]
输出：[&quot;&#x2F;a&quot;,&quot;&#x2F;c&#x2F;d&quot;,&quot;&#x2F;c&#x2F;f&quot;]
解释：&quot;&#x2F;a&#x2F;b&quot; 是 &quot;&#x2F;a&quot; 的子文件夹，而 &quot;&#x2F;c&#x2F;d&#x2F;e&quot; 是 &quot;&#x2F;c&#x2F;d&quot; 的子文件夹。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：folder &#x3D; [&quot;&#x2F;a&quot;,&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;]
输出：[&quot;&#x2F;a&quot;]
解释：文件夹 &quot;&#x2F;a&#x2F;b&#x2F;c&quot; 和 &quot;&#x2F;a&#x2F;b&#x2F;d&quot; 都会被删除，因为它们都是 &quot;&#x2F;a&quot; 的子文件夹。</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入: folder &#x3D; [&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;ca&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;]
输出: [&quot;&#x2F;a&#x2F;b&#x2F;c&quot;,&quot;&#x2F;a&#x2F;b&#x2F;ca&quot;,&quot;&#x2F;a&#x2F;b&#x2F;d&quot;]</code></pre>

<h4 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>先按照字典序排序（/a，/a/b，/a/b/c，/b），这样在遍历时只需要和上一个被加入的非子文件夹比较（因为相同根文件夹情况下先短后长排序），便于排除。</p>
<p>将第一个文件夹加入输出，遍历<strong>folder</strong>中的剩余文件夹，作如下判断：</p>
<p>1.当前字符串长度比上一个被加入的字符串<strong>短</strong>的，必然是根文件夹名改变了，是非子文件夹，<strong>加入</strong>。</p>
<p>2.当前字符串的前n个字符与上一个被加入的字符串完全相同且<strong>第n+1个字符为 ‘/’ 的</strong>，必然是子文件夹，<strong>排除</strong>。</p>
<p><strong>解法2：字典树</strong></p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) &#123;
        sort(folder.begin(), folder.end());
        vector&lt;string&gt; rst &#x3D; &#123;folder[0]&#125;;
        for(int i &#x3D; 1; i &lt; folder.size(); ++i)&#123;
            int ori_len &#x3D; rst.back().size();
            int cur_len &#x3D; folder[i].size();
            if (ori_len &gt;&#x3D; cur_len || !(rst.back() &#x3D;&#x3D; folder[i].substr(0, ori_len) &amp;&amp; folder[i][ori_len] &#x3D;&#x3D; &#39;&#x2F;&#39;))
                rst.push_back(folder[i]);
        &#125;
        return rst;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-9"><a href="#2023-2-9" class="headerlink" title="2023.2.9"></a>2023.2.9</h2><h3 id="1797-设计一个验证系统"><a href="#1797-设计一个验证系统" class="headerlink" title="1797.设计一个验证系统"></a>1797.设计一个验证系统</h3><h4 id="题干-9"><a href="#题干-9" class="headerlink" title="题干"></a>题干</h4><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <strong>currentTime</strong> 时刻之后 <strong>timeToLive</strong> 秒过期。如果验证码被更新了，那么它会在 <strong>currentTime</strong> （可能与之前的 currentTime 不同）时刻延长 <strong>timeToLive</strong> 秒。</p>
<p>请你实现 <strong>AuthenticationManager 类</strong>：</p>
<ul>
<li>AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。</li>
<li>generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。</li>
<li>renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li>
<li>countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。</li>
<li>如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。</li>
<li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li>
<li>所有函数调用中，<code>currentTime</code> 的值 <strong>严格递增</strong> 。</li>
<li>所有函数的调用次数总共不超过 <code>2000</code> 次。</li>
</ul>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">输入：
[&quot;AuthenticationManager&quot;, &quot;renew&quot;, &quot;generate&quot;, &quot;countUnexpiredTokens&quot;, &quot;generate&quot;, &quot;renew&quot;, &quot;renew&quot;, &quot;countUnexpiredTokens&quot;]
[[5], [&quot;aaa&quot;, 1], [&quot;aaa&quot;, 2], [6], [&quot;bbb&quot;, 7], [&quot;aaa&quot;, 8], [&quot;bbb&quot;, 10], [15]]
输出：
[null, null, null, 1, null, null, null, 0]

解释：
AuthenticationManager authenticationManager &#x3D; new AuthenticationManager(5); &#x2F;&#x2F; 构造 AuthenticationManager ，设置 timeToLive &#x3D; 5 秒。
authenticationManager.renew(&quot;aaa&quot;, 1); &#x2F;&#x2F; 时刻 1 时，没有验证码的 tokenId 为 &quot;aaa&quot; ，没有验证码被更新。
authenticationManager.generate(&quot;aaa&quot;, 2); &#x2F;&#x2F; 时刻 2 时，生成一个 tokenId 为 &quot;aaa&quot; 的新验证码。
authenticationManager.countUnexpiredTokens(6); &#x2F;&#x2F; 时刻 6 时，只有 tokenId 为 &quot;aaa&quot; 的验证码未过期，所以返回 1 。
authenticationManager.generate(&quot;bbb&quot;, 7); &#x2F;&#x2F; 时刻 7 时，生成一个 tokenId 为 &quot;bbb&quot; 的新验证码。
authenticationManager.renew(&quot;aaa&quot;, 8); &#x2F;&#x2F; tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，且 8 &gt;&#x3D; 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。
authenticationManager.renew(&quot;bbb&quot;, 10); &#x2F;&#x2F; tokenId 为 &quot;bbb&quot; 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。
authenticationManager.countUnexpiredTokens(15); &#x2F;&#x2F; tokenId 为 &quot;bbb&quot; 的验证码在时刻 15 过期，tokenId 为 &quot;aaa&quot; 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。</code></pre>

<h4 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>采用<strong>哈希表</strong>存储 [tokenId，过期时间点] 这一键值对，保存信息。</p>
<p>因为提到了currentTime是严格递增的，因此在存储id时可以不用队列，直接用顺序表存储。</p>
<p>因为函数总调用次数不超过2000次，因此甚至不需要对表进行维护（即删除过期id）。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class AuthenticationManager &#123;
public:
    AuthenticationManager(int timeToLive) &#123;
        liveTime &#x3D; timeToLive;
    &#125;
    
    void generate(string tokenId, int currentTime) &#123;
        liveIds[tokenId] &#x3D; currentTime + liveTime;
    &#125;
    
    void renew(string tokenId, int currentTime) &#123;
        if (liveIds[tokenId] &gt; currentTime)
            generate(tokenId, currentTime);
    &#125;
    
    int countUnexpiredTokens(int currentTime) &#123;
        int cnt &#x3D; 0;
        for (auto iter &#x3D; liveIds.begin(); iter !&#x3D; liveIds.end(); ++iter) &#123;
            if (iter-&gt;second &gt; currentTime)
                cnt++;
        &#125;
        return cnt;
    &#125;
private:
    int liveTime;
    unordered_map&lt;string, int&gt; liveIds;
&#125;;

&#x2F;**
 * Your AuthenticationManager object will be instantiated and called as such:
 * AuthenticationManager* obj &#x3D; new AuthenticationManager(timeToLive);
 * obj-&gt;generate(tokenId,currentTime);
 * obj-&gt;renew(tokenId,currentTime);
 * int param_3 &#x3D; obj-&gt;countUnexpiredTokens(currentTime);
 *&#x2F;</code></pre>



<h2 id="2023-2-11"><a href="#2023-2-11" class="headerlink" title="2023.2.11"></a>2023.2.11</h2><h3 id="2335-装满杯子所需的最短总时长"><a href="#2335-装满杯子所需的最短总时长" class="headerlink" title="2335.装满杯子所需的最短总时长"></a>2335.装满杯子所需的最短总时长</h3><h4 id="题干-10"><a href="#题干-10" class="headerlink" title="题干"></a>题干</h4><p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 <strong>不同</strong> 类型的水或者 1 杯<strong>任意类型</strong>的水。</p>
<p>给你一个<strong>下标从 0 开始、长度为 3</strong> 的整数数组 <strong>amount</strong> ，其中 <strong>amount[0]、amount[1] 和 amount[2]</strong> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <strong>最少</strong> 秒数。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：amount &#x3D; [1,4,2]
输出：4
解释：下面给出一种方案：
第 1 秒：装满一杯冷水和一杯温水。
第 2 秒：装满一杯温水和一杯热水。
第 3 秒：装满一杯温水和一杯热水。
第 4 秒：装满一杯温水。
可以证明最少需要 4 秒才能装满所有杯子。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：amount &#x3D; [5,4,4]
输出：7</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：amount &#x3D; [5,0,0]
输出：5</code></pre>

<h4 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>简单的贪心算法。每次循环先排序，取较大的两个各减一，直至全为0.</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int fillCups(vector&lt;int&gt;&amp; amount) &#123;
        int turns &#x3D; 0;
        while(amount[0] + amount[1] + amount[2]) &#123;
            sort(amount.begin(), amount.end());
            turns++;
            amount[2]--;
            if (amount[1] &gt; 0)
                amount[1]--;
        &#125;
        return turns;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-13"><a href="#2023-2-13" class="headerlink" title="2023.2.13"></a>2023.2.13</h2><h3 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234.替换子串得到平衡字符串"></a>1234.替换子串得到平衡字符串</h3><h4 id="题干-11"><a href="#题干-11" class="headerlink" title="题干"></a>题干</h4><p>有一个只含有 <strong>‘Q’, ‘W’, ‘E’, ‘R’</strong> 四种字符，且长度为 <strong>n</strong> 的字符串。</p>
<p>假如在该字符串中，这四个字符都恰好出现 <strong>n/4</strong> 次，那么它就是一个<strong>「平衡字符串」</strong>。</p>
<p>给你一个这样的字符串 <strong>s</strong>，请通过<strong>「替换一个子串」</strong>的方式，使原字符串 <strong>s</strong> 变成一个<strong>「平衡字符串」</strong>。</p>
<p>你可以用和<strong>「待替换子串」</strong>长度相同的 <strong>任何</strong> 其他字符串来完成替换。</p>
<p>请返回待替换子串的<strong>最小可能长度</strong>。</p>
<p>如果原字符串自身就是一个平衡字符串，则返回 <strong>0</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：s &#x3D; &quot;QWER&quot;
输出：0
解释：s 已经是平衡的了。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：s &#x3D; &quot;QQWE&quot;
输出：1
解释：我们需要把一个 &#39;Q&#39; 替换成 &#39;R&#39;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：s &#x3D; &quot;QQQQ&quot;
输出：3
解释：我们可以替换后 3 个 &#39;Q&#39;，使 s &#x3D; &quot;QWER&quot;。</code></pre>

<h4 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>最终目标是四个字符的数量都达到 <strong>n/4</strong> 个时，改动字符串的长度怎么取最短。很容易想到双指针来控制应该改动的部分的首尾。</p>
<p>因为替换字符串内的字符都可以任选，那么只要保证该子串外的字符数达标即可。那么判断条件就是子串外的四个字符数均小于等于 <strong>n/4</strong> 个。</p>
<p>先统计一遍原字符串中的四个字符数。</p>
<p>移动右指针时将子串外对应字符数-1，移动左指针+1。</p>
<p>以右指针为基准进行for循环，通过左指针右移压缩改动字符串的长度，找出符合标准的最小值即可。</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int balancedString(string s) &#123;
        int len &#x3D; s.length();
        int num &#x3D; len &#x2F; 4, cnt[&#39;X&#39;] &#x3D; &#123;0&#125;;
        for (char&amp; c : s) &#123;
            cnt[c]++;
        &#125;
        if (cnt[&#39;Q&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;W&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;E&#39;] &#x3D;&#x3D; num &amp;&amp; cnt[&#39;R&#39;] &#x3D;&#x3D; num)
            return 0;
        int res &#x3D; len, left &#x3D; 0;
        for (int right &#x3D; 0; right &lt; len; ++right) &#123;
            cnt[s[right]]--;
            while (left &lt;&#x3D; right &amp;&amp; cnt[&#39;Q&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;W&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;E&#39;] &lt;&#x3D; num &amp;&amp; cnt[&#39;R&#39;] &lt;&#x3D; num) &#123;
                res &#x3D; min(res, right - left + 1);
                cnt[s[left++]]++;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-18"><a href="#2023-2-18" class="headerlink" title="2023.2.18"></a>2023.2.18</h2><h3 id="1237-找出给定方程的正整数解"><a href="#1237-找出给定方程的正整数解" class="headerlink" title="1237.找出给定方程的正整数解"></a>1237.找出给定方程的正整数解</h3><h4 id="题干-12"><a href="#题干-12" class="headerlink" title="题干"></a>题干</h4><p>给你一个函数  <strong>f(x, y)</strong> 和一个目标结果 <strong>z</strong>，函数公式未知，请你计算方程 <strong>f(x,y) == z</strong> 所有可能的<strong>正整数</strong> <strong>数对 x 和 y</strong>。满足条件的结果数对可以按任意顺序返回。</p>
<p>尽管函数的具体式子未知，但它是<strong>单调递增</strong>函数，也就是说：</p>
<p><strong>f(x, y) &lt; f(x + 1, y)</strong><br><strong>f(x, y) &lt; f(x, y + 1)</strong></p>
<p>函数接口定义如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">interface CustomFunction &#123;
public:
  &#x2F;&#x2F; Returns some positive integer f(x, y) for two positive integers x and y based on a formula.
  int f(int x, int y);
&#125;;</code></pre>

<p>你的解决方案将按如下规则进行评判：</p>
<ol>
<li>判题程序有一个由 CustomFunction 的 9 种实现组成的列表，以及一种为特定的 z 生成所有有效数对的答案的方法。</li>
<li>判题程序接受两个输入：function_id（决定使用哪种实现测试你的代码）以及目标结果 z 。</li>
<li>判题程序将会调用你实现的 findSolution 并将你的结果与答案进行比较。</li>
<li>如果你的结果与答案相符，那么解决方案将被视作正确答案，即 Accepted 。</li>
</ol>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：function_id &#x3D; 1, z &#x3D; 5
输出：[[1,4],[2,3],[3,2],[4,1]]
解释：function_id &#x3D; 1 暗含的函数式子为 f(x, y) &#x3D; x + y
以下 x 和 y 满足 f(x, y) 等于 5：
x&#x3D;1, y&#x3D;4 -&gt; f(1, 4) &#x3D; 1 + 4 &#x3D; 5
x&#x3D;2, y&#x3D;3 -&gt; f(2, 3) &#x3D; 2 + 3 &#x3D; 5
x&#x3D;3, y&#x3D;2 -&gt; f(3, 2) &#x3D; 3 + 2 &#x3D; 5
x&#x3D;4, y&#x3D;1 -&gt; f(4, 1) &#x3D; 4 + 1 &#x3D; 5</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：function_id &#x3D; 2, z &#x3D; 5
输出：[[1,5],[5,1]]
解释：function_id &#x3D; 2 暗含的函数式子为 f(x, y) &#x3D; x * y
以下 x 和 y 满足 f(x, y) 等于 5：
x&#x3D;1, y&#x3D;5 -&gt; f(1, 5) &#x3D; 1 * 5 &#x3D; 5
x&#x3D;5, y&#x3D;1 -&gt; f(5, 1) &#x3D; 5 * 1 &#x3D; 5</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= function_id &lt;= 9</li>
<li>1 &lt;= z &lt;= 100</li>
<li>题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。</li>
<li>在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。</li>
</ul>
<h4 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>这个题目我觉得题干有非常多的无效信息，因为f（x，y）是具体实现不可见的函数。</p>
<p>实际有效的信息只有两条：</p>
<ol>
<li><strong>f（x，y）是单调递增函数</strong></li>
<li><strong>x，y的取值范围均为 [1, 1000]</strong></li>
</ol>
<p>那么我们可以采用枚举的方式（遍历），分别将x，y的值设为区间的两端（原因后面可以体会到）</p>
<p><strong>x初始为1最小，y初始为1000最大（即x只能递增，y只能递减）</strong>，计算f（x，y）有三种结果</p>
<ul>
<li>当f（x，y）&lt; z 时，由单调性可知，f（x，y-1）同样小于z，而我们的目标是等于z，此时唯一的动作就是x++；</li>
<li>当f（x，y）&gt; z 时，同理，只能y–；</li>
<li>当f（x，y）== z 时，存储这一对x，y，同时x++，y–（两个同时增减，因为只变动一个没有意义，必然不可能等于z）。</li>
</ul>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*
 * &#x2F;&#x2F; This is the custom function interface.
 * &#x2F;&#x2F; You should not implement it, or speculate about its implementation
 * class CustomFunction &#123;
 * public:
 *     &#x2F;&#x2F; Returns f(x, y) for any given positive integers x and y.
 *     &#x2F;&#x2F; Note that f(x, y) is increasing with respect to both x and y.
 *     &#x2F;&#x2F; i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)
 *     int f(int x, int y);
 * &#125;;
 *&#x2F;

class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        int x &#x3D; 1, y &#x3D; 1000;
        while(x &lt;&#x3D; 1000 &amp;&amp; y) &#123;
            int rst &#x3D; customfunction.f(x, y);
            if (rst &lt; z) 
                x++;
            else if (rst &gt; z)
                y--;
            else
                res.push_back(&#123;x++, y--&#125;);
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-20"><a href="#2023-2-20" class="headerlink" title="2023.2.20"></a>2023.2.20</h2><h3 id="2347-最好的扑克手牌"><a href="#2347-最好的扑克手牌" class="headerlink" title="2347.最好的扑克手牌"></a>2347.最好的扑克手牌</h3><h4 id="题干-13"><a href="#题干-13" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <strong>ranks</strong> 和一个字符数组 <strong>suit</strong> 。你有 <strong>5</strong> 张扑克牌，第 <strong>i</strong> 张牌大小为 <strong>ranks[i]</strong> ，花色为 <strong>suits[i]</strong> 。</p>
<p>下述是<strong>从好到坏</strong>你可能持有的 手牌类型 ：</p>
<ul>
<li>“<strong>Flush</strong>“：同花，五张相同花色的扑克牌。</li>
<li>“<strong>Three of a Kind</strong>“：三条，有 3 张大小相同的扑克牌。</li>
<li>“<strong>Pair</strong>“：对子，两张大小一样的扑克牌。</li>
<li>“<strong>High Card</strong>“：高牌，五张大小互不相同的扑克牌。</li>
</ul>
<p>请你返回一个字符串，表示给定的 5 张牌中，你能组成的 <strong>最好</strong>手牌类型 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：ranks &#x3D; [13,2,3,1,9], suits &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]
输出：&quot;Flush&quot;</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：ranks &#x3D; [4,4,2,4,4], suits &#x3D; [&quot;d&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
输出：&quot;Three of a Kind&quot;</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：ranks &#x3D; [10,10,2,12,9], suits &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;d&quot;]
输出：&quot;Pair&quot;</code></pre>

<h4 id="解法-13"><a href="#解法-13" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>简单题，没啥说的，翻译一下就是：</p>
<ol>
<li>先判断suits里的元素是否均相同；</li>
<li>再判断ranks里是否存在三个/两个/不存在相同的元素；</li>
</ol>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string bestHand(vector&lt;int&gt;&amp; ranks, vector&lt;char&gt;&amp; suits) &#123;
        if (equal(suits.begin()+1, suits.end(), suits.begin()))
            return &quot;Flush&quot;;
        int cnt[14] &#x3D; &#123;0&#125;;
        bool isPair &#x3D; false;
        for(int i &#x3D; 0; i &lt; ranks.size(); ++i)&#123;
            if(++cnt[ranks[i]] &#x3D;&#x3D; 3)
                return &quot;Three of a Kind&quot;;
            isPair |&#x3D; cnt[ranks[i]] &#x3D;&#x3D; 2;
        &#125;
        return isPair ? &quot;Pair&quot; : &quot;High Card&quot;;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-24"><a href="#2023-2-24" class="headerlink" title="2023.2.24"></a>2023.2.24</h2><h3 id="2357-使数组中所有元素都等于0"><a href="#2357-使数组中所有元素都等于0" class="headerlink" title="2357.使数组中所有元素都等于0"></a>2357.使数组中所有元素都等于0</h3><h4 id="题干-14"><a href="#题干-14" class="headerlink" title="题干"></a>题干</h4><p>给你一个非负整数数组 <strong>nums</strong> 。在一步操作中，你必须：</p>
<ul>
<li>选出一个正整数 <strong>x</strong> ，<strong>x</strong> 需要<strong>小于或等于</strong> <strong>nums</strong> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li>
<li><strong>nums</strong> 中的每个<strong>正整数</strong>都减去 <strong>x</strong>。</li>
</ul>
<p>返回使 <strong>nums</strong> 中所有元素都等于 <strong>0</strong> 需要的 <strong>最少</strong> 操作数。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：nums &#x3D; [1,5,0,3,5]
输出：3
解释：
第一步操作：选出 x &#x3D; 1 ，之后 nums &#x3D; [0,4,0,2,4] 。
第二步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,2,0,0,2] 。
第三步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,0,0,0,0] 。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：nums &#x3D; [0]
输出：0</code></pre>

<h4 id="解法-14"><a href="#解法-14" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>简单题，没啥说的，每一步都找一个最小的正整数减掉，直到全为0。</p>
<p>不必要真去减，如示例1，第一步减1后3变成2，正好是第二步减的数，也就是说只需要记录之前减的总数（上一个需要被减的数本身）就行。</p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumOperations(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());
        int lastNum &#x3D; 0, cnt &#x3D; 0;
        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;
            if (nums[i] - lastNum &gt; 0) &#123;
                lastNum &#x3D; nums[i];
                cnt++;
            &#125;
        &#125;
        return cnt;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-25"><a href="#2023-2-25" class="headerlink" title="2023.2.25"></a>2023.2.25</h2><h3 id="1247-交换字符使得字符串相同"><a href="#1247-交换字符使得字符串相同" class="headerlink" title="1247.交换字符使得字符串相同"></a>1247.交换字符使得字符串相同</h3><h4 id="题干-15"><a href="#题干-15" class="headerlink" title="题干"></a>题干</h4><p>有两个长度相同的字符串 <strong>s1</strong> 和 <strong>s2</strong>，且它们其中 只含有 字符 “<strong>x</strong>“ 和 “<strong>y</strong>“，你需要通过「<strong>交换字符</strong>」的方式使这两个字符串相同。</p>
<p>每次「<strong>交换字符</strong>」的时候，你都可以在两个字符串中各选一个字符进行交换。</p>
<p>交换只能发生在<strong>两个不同的字符串之间</strong>，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 **s1[i] 和 s2[j]**，但不能交换 **s1[i] 和 s1[j]**。</p>
<p>最后，请你返回使 s1 和 s2 相同的<strong>最小</strong>交换次数，如果没有方法能够使得这两个字符串相同，则返回 <strong>-1</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：s1 &#x3D; &quot;xx&quot;, s2 &#x3D; &quot;yy&quot;
输出：1
解释：交换 s1[0] 和 s2[1]，得到 s1 &#x3D; &quot;yx&quot;，s2 &#x3D; &quot;yx&quot;。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：s1 &#x3D; &quot;xy&quot;, s2 &#x3D; &quot;yx&quot;
输出：2
解释：
交换 s1[0] 和 s2[0]，得到 s1 &#x3D; &quot;yy&quot;，s2 &#x3D; &quot;xx&quot; 。
交换 s1[0] 和 s2[1]，得到 s1 &#x3D; &quot;xy&quot;，s2 &#x3D; &quot;xy&quot; 。</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：s1 &#x3D; &quot;xx&quot;, s2 &#x3D; &quot;xy&quot;
输出：-1</code></pre>

<h4 id="解法-15"><a href="#解法-15" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>首先统计两个字符串同一位置下的字符不同的数量，因为交换只会发生在不同处。</p>
<p>不同有两种情况，xy和yx。</p>
<p>根据上述三个示例可以得出结论，对于每<strong>2对</strong>不同的字符：</p>
<ul>
<li>若为同一形式（均为xy），只需要对角交换1次即可相同；</li>
<li>若为不同形式（xy和yx），需要先同位置交换1次变为示例1，再对角交换一次；</li>
<li>若仅有一对不同，无法交换至相同。</li>
</ul>
<p>可以得出结论：</p>
<ol>
<li>xy、yx和为奇数，无法相同，返回-1；</li>
<li>若和为偶数，分为两种情况，xy、yx均为偶数或奇数；</li>
<li>若均为偶数，按照每两对1次的情况，只需要 <strong>xy / 2 + yx / 2</strong> 次</li>
<li>若均为奇数，则在除去每两对一次的情况下，会留存一对示例2情况；</li>
<li>结合3、4可得共 <strong>xy / 2 + yx / 2 + xy % 2 + yx % 2</strong> 次。</li>
</ol>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumSwap(string s1, string s2) &#123;
        int xy &#x3D; 0, yx &#x3D; 0;
        for(int i &#x3D; 0; i &lt; s1.length(); ++i)&#123;
            xy +&#x3D; s1[i] &lt; s2[i];
            yx +&#x3D; s1[i] &gt; s2[i];
        &#125;
        if ((xy + yx) % 2)
            return -1;
        return xy &#x2F; 2 + yx &#x2F; 2 + xy % 2 + yx % 2;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-27"><a href="#2023-2-27" class="headerlink" title="2023.2.27"></a>2023.2.27</h2><h3 id="1144-递减元素使数组成锯齿状"><a href="#1144-递减元素使数组成锯齿状" class="headerlink" title="1144.递减元素使数组成锯齿状"></a>1144.递减元素使数组成锯齿状</h3><h4 id="题干-16"><a href="#题干-16" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 <strong>nums</strong>，每次操作会从中<strong>选择一个元素</strong>并<strong>将该元素的值减少 1</strong>。</p>
<p>如果符合下列情况<strong>之一</strong>，则数组 <strong>A</strong> 就是 <strong>锯齿数组</strong>：</p>
<ul>
<li>每个偶数索引对应的元素都大于相邻的元素，即 <strong>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; …</strong></li>
<li>每个奇数索引对应的元素都大于相邻的元素，即 <strong>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; …</strong></li>
</ul>
<p>返回将数组 <strong>nums</strong> 转换为锯齿数组所需的<strong>最小</strong>操作次数。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：nums &#x3D; [1,2,3]
输出：2
解释：我们可以把 2 递减到 0，或把 3 递减到 1。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：nums &#x3D; [9,6,1,6,2]
输出：4</code></pre>

<h4 id="解法-16"><a href="#解法-16" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>枚举呗。</p>
<p>奇数和偶数下标各遍历一遍，每次都判断和两边的差值，记录最大值求和即可。</p>
<p>排除掉当元素处于数组边界时越界的问题，最后比较两种哪种小。</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) &#123;
        int cnt[2] &#x3D; &#123;0&#125;;
        for(int i &#x3D; 0; i &lt; 2; ++i)&#123;
            for(int j &#x3D; i; j &lt; nums.size(); ++j, ++j)&#123;
                int step &#x3D; 0;
                if(j)   step &#x3D; max(step, nums[j] - nums[j - 1] + 1);
                if(j &lt; nums.size()-1)   step &#x3D; max(step, nums[j] - nums[j + 1] + 1);
                cnt[i] +&#x3D; step;
            &#125;
        &#125;
        return min(cnt[0], cnt[1]);
    &#125;
&#125;;</code></pre>



<h3 id="面试题16-07-最大数值"><a href="#面试题16-07-最大数值" class="headerlink" title="面试题16.07.最大数值"></a>面试题16.07.最大数值</h3><h4 id="题干-17"><a href="#题干-17" class="headerlink" title="题干"></a>题干</h4><p>编写一个方法，找出两个数字 <strong>a</strong> 和 <strong>b</strong> 中<strong>最大</strong>的那一个。<strong>不得使用if-else或其他比较运算符</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入： a &#x3D; 1, b &#x3D; 2
输出： 2</code></pre>

<h4 id="解法-17"><a href="#解法-17" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>首先考虑到的就是不用比较符号如何出现控制输出a还是b呢？</p>
<p>想到了类似门电路，用0和1控制就行，也就是 <strong>a * (condition ^ 1) + b * condition</strong> ;</p>
<p>那么什么运算结果是0和1呢，很容易想到通过位运算获取符号位。</p>
<p>于是得到以下代码：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maximum(int a, int b) &#123;
        &#x2F;&#x2F; 注意当值为负数时，右移高位是会补1的，因此需要把计算结果转为无符号
        int signSub &#x3D; static_cast&lt;unsigned&gt;(a - b) &gt;&gt; 31;
        return a * (signSub ^ 1) + b * signSub;
    &#125;
&#125;;</code></pre>

<p>提交时出现了问题  <font color="red"><code>signed integer overflow: 2147483647 - -2147483648 cannot be represented in type &#39;int&#39;</code></font></p>
<p>忘记考虑了溢出的问题，在 a - b 时就溢出了。当a和b同号时，不存在溢出问题，可以直接用上述方法，只有当ab异号时需要考虑溢出问题。</p>
<p>可以发现，当a和b异号时，若a为负数，符号位1，需要输出b，也就是signSub = 1；a为正数，符号位0，输出a，signSub = 0.</p>
<p>可以得到此时的处理方法，<strong>signSub = a符号位  ^ b符号位 ^ b符号位</strong>。    </p>
<p>在不使用比较运算符的情况下，可以用 &amp;&amp; 作为if判断使用。</p>
<p>代码</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maximum(int a, int b) &#123;
        int signA &#x3D; static_cast&lt;unsigned&gt;(a) &gt;&gt; 31;
        int signB &#x3D; static_cast&lt;unsigned&gt;(b) &gt;&gt; 31;

        int signSub &#x3D; signA ^ signB ^ signB;
        int temp &#x3D; (signA ^ signB ^ 1) &amp;&amp; (signSub &#x3D; static_cast&lt;unsigned&gt;(a - b) &gt;&gt; 31);

        return a * (signSub ^ 1) + b * signSub;
    &#125;
&#125;;</code></pre>



<h2 id="2023-2-28"><a href="#2023-2-28" class="headerlink" title="2023.2.28"></a>2023.2.28</h2><h3 id="2363-合并相似的物品"><a href="#2363-合并相似的物品" class="headerlink" title="2363.合并相似的物品"></a>2363.合并相似的物品</h3><h4 id="题干-18"><a href="#题干-18" class="headerlink" title="题干"></a>题干</h4><p>给你两个二维整数数组 <strong>items1</strong> 和 <strong>items2</strong> ，表示两个物品集合。每个数组 <strong>items</strong> 有以下特质：</p>
<ul>
<li><strong>items[i] = [valuei, weighti]</strong> 其中 <strong>valuei</strong> 表示第 <strong>i</strong> 件物品的 <strong>价值</strong> ，<strong>weighti</strong> 表示第 <strong>i</strong> 件物品的 <strong>重量</strong> 。</li>
<li>items 中每件物品的价值都是 <strong>唯一</strong> 的 。</li>
</ul>
<p>请你返回一个二维数组 <strong>ret</strong>，其中 **ret[i] = [valuei, weighti]**， <strong>weighti</strong> 是所有价值为 <strong>valuei</strong> 物品的 <strong>重量之和</strong> 。</p>
<p>注意：</p>
<ul>
<li><p><strong>ret</strong> 应该按<strong>价值</strong> <strong>升序</strong> 排序后返回。</p>
</li>
<li><p><code>1 &lt;= valuei, weighti &lt;= 1000</code></p>
</li>
</ul>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：items1 &#x3D; [[1,1],[4,5],[3,8]], items2 &#x3D; [[3,1],[1,5]]
输出：[[1,6],[3,9],[4,5]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：items1 &#x3D; [[1,1],[3,2],[2,3]], items2 &#x3D; [[2,1],[3,2],[1,3]]
输出：[[1,4],[2,4],[3,4]]</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：items1 &#x3D; [[1,3],[2,2]], items2 &#x3D; [[7,1],[2,2],[1,4]]
输出：[[1,7],[2,4],[7,1]]</code></pre>

<h4 id="解法-18"><a href="#解法-18" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>就是求出现过的每种价值的总重量，价值不重复，自然想到了哈希，开一个 <strong>cnt[1001]</strong> ，下标表示价值。</p>
<p>刚好，需要按照价值升序排序，从小到大遍历cnt即可。</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) &#123;
        vector&lt;vector&lt;int&gt;&gt; ret;
        int cnt[1001] &#x3D; &#123;0&#125;;
        for(int i &#x3D; 0; i &lt; items1.size(); ++i)&#123;
            cnt[items1[i][0]] +&#x3D; items1[i][1];
        &#125;
        for(int i &#x3D; 0; i &lt; items2.size(); ++i)&#123;
            cnt[items2[i][0]] +&#x3D; items2[i][1];
        &#125;
        for(int i &#x3D; 0; i &lt; 1001; ++i)&#123;
            if(cnt[i])
                ret.push_back(&#123;i, cnt[i]&#125;);
        &#125;
        return ret;
    &#125;
&#125;;</code></pre>



<h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h3><h4 id="题干-19"><a href="#题干-19" class="headerlink" title="题干"></a>题干</h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<p><strong>提示：</strong>输入必须是长度为 <strong><code>32</code></strong> 的 <strong>二进制串</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：n &#x3D; 00000000000000000000000000001011
输出：3</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：n &#x3D; 11111111111111111111111111111101
输出：31</code></pre>

<h4 id="解法-19"><a href="#解法-19" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>位运算，每位都和1与一下就行。</p>
<p>尝试了一下发现，1移位和n与 ，比 n移位和1与 速度快。</p>
<h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int hammingWeight(uint32_t n) &#123;
        int cnt &#x3D; 0;
        for(int i &#x3D; 0; i &lt; 32; ++i)&#123;
            if ((n &amp; (1 &lt;&lt; i)) &gt; 0)
                cnt++;
        &#125;
        return cnt;
    &#125;
&#125;;</code></pre>



<h2 id="2023-3-1"><a href="#2023-3-1" class="headerlink" title="2023.3.1"></a>2023.3.1</h2><h3 id="2373-矩阵中的局部最大值"><a href="#2373-矩阵中的局部最大值" class="headerlink" title="2373.矩阵中的局部最大值"></a>2373.矩阵中的局部最大值</h3><h4 id="题干-20"><a href="#题干-20" class="headerlink" title="题干"></a>题干</h4><p>给你一个大小为 <strong>n x n</strong> 的整数矩阵 <strong>grid</strong> 。</p>
<p>生成一个大小为 <strong>(n - 2) x (n - 2)</strong> 的整数矩阵  <strong>maxLocal</strong> ，并满足：</p>
<p><strong>maxLocal[i] [j]</strong> 等于 <strong>grid</strong> 中以 <strong>i + 1</strong> 行和 <strong>j + 1</strong> 列为中心的 <strong>3 x 3 矩阵</strong>中的 <strong>最大值</strong> 。<br>换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。</p>
<p>返回生成的矩阵</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：grid &#x3D; [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
输出：[[9,9],[8,6]]</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：grid &#x3D; [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
输出：[[2,2,2],[2,2,2],[2,2,2]]</code></pre>

<h4 id="解法-20"><a href="#解法-20" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>暴力for循环。。</p>
<h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; largestLocal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int size &#x3D; grid.size();
        vector&lt;vector&lt;int&gt;&gt; res(size - 2, vector&lt;int&gt;(size - 2));
        for(int i &#x3D; 0; i &lt; size - 2; ++i)&#123;
            for(int j &#x3D; 0; j &lt; size - 2; ++j)&#123;
                for(int x &#x3D; i; x &lt; i + 3; ++x)&#123;
                    for(int y &#x3D; j; y &lt; j + 3; ++y)&#123;
                        res[i][j] &#x3D; max(res[i][j], grid[x][y]);
                    &#125;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-3-2"><a href="#2023-3-2" class="headerlink" title="2023.3.2"></a>2023.3.2</h2><h3 id="面试题05-02-二进制数转字符串"><a href="#面试题05-02-二进制数转字符串" class="headerlink" title="面试题05.02.二进制数转字符串"></a>面试题05.02.二进制数转字符串</h3><h4 id="题干-21"><a href="#题干-21" class="headerlink" title="题干"></a>题干</h4><p>二进制数转字符串。给定一个介于<strong>0和1之间</strong>的<strong>实数</strong>（如0.72），类型为<strong>double</strong>，打印它的二进制表达式。</p>
<p>如果该数字无法精确地用<strong>32位以内</strong>的二进制表示，则打印“<strong>ERROR</strong>”。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p>32位包括输出中的 <code>&quot;0.&quot;</code> 这两位。</p>
</li>
<li><p>题目保证输入用例的小数位数最多只有 <code>6</code> 位</p>
</li>
</ul>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
 输入：0.625
 输出：&quot;0.101&quot;</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
 输入：0.1
 输出：&quot;ERROR&quot;
 提示：0.1无法被二进制准确表示</code></pre>

<h4 id="解法-21"><a href="#解法-21" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>double小数的二进制转化方法，以<strong>0.625</strong>为例：</p>
<ol>
<li> 0.625 * 2 = 1.25，取整数位1作为小数点后第一位；</li>
<li>（1.25 - 1）* 2 = 0.5，取整数位0作为小数点后第二位；</li>
<li> 0.5 * 2 = 1，取整数位1作为小数点后第三位；</li>
<li>此时剩余数1 - 1 = 0，不再继续。</li>
</ol>
<p><strong>解法2：</strong></p>
<p>一种数学证明过程。</p>
<p><img src="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20230302225256469.png" alt="image-20230302225256469"></p>
<h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string printBin(double num) &#123;
        string res &#x3D; &quot;0.&quot;;
        while(res.size() &lt; 32 &amp;&amp; num)&#123;
            num *&#x3D; 2;
            if (num &lt; 1)
                res +&#x3D; &quot;0&quot;;
            else &#123;
                res +&#x3D; &quot;1&quot;;
                --num;
            &#125;
        &#125;
        return num ? &quot;ERROR&quot; : res;
    &#125;
&#125;;</code></pre>



<h2 id="2023-3-3"><a href="#2023-3-3" class="headerlink" title="2023.3.3"></a>2023.3.3</h2><h3 id="1487-保证文件名唯一"><a href="#1487-保证文件名唯一" class="headerlink" title="1487.保证文件名唯一"></a>1487.保证文件名唯一</h3><h4 id="题干-22"><a href="#题干-22" class="headerlink" title="题干"></a>题干</h4><p>给你一个长度为 <strong>n</strong> 的字符串数组 <strong>names</strong> 。你将会在文件系统中创建 <strong>n</strong> 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。</p>
<p>由于两个文件<strong>不能共享相同的文件名</strong>，因此如果新建文件夹使用的文件名已经被占用，系统会以 <strong>(k)</strong> 的形式为新文件夹的文件名添加后缀，其中 <strong>k</strong> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p>
<p>返回长度为 <strong>n</strong> 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的<strong>实际名称</strong>。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：names &#x3D; [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]
输出：[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：names &#x3D; [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;]
输出：[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;]</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：names &#x3D; [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]
输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]
解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。</code></pre>

<h4 id="解法-22"><a href="#解法-22" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>看到 “ 唯一 ” ，马上就想到了哈希表。key为实际文件名，value记录当前文件名加上后缀时当前存在的最大值。</p>
<p>直接使用输入的names，用哈希表判断是否有重名，只对重名的元素进行修改并记录在哈希表中，节约空间。</p>
<p>执行用时只击败了18%用户，，，不知时间上还可以怎么缩减。</p>
<h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; getFolderNames(vector&lt;string&gt;&amp; names) &#123;
        unordered_map&lt;string, int&gt; hash;
        for(int i &#x3D; 0; i &lt; names.size(); ++i)&#123;
            if(hash[names[i]])&#123;
                int cnt &#x3D; hash[names[i]] - 1;
                while(hash[names[i] + &quot;(&quot; + to_string(++cnt) + &quot;)&quot;]);
                hash[names[i]] &#x3D; cnt;
                names[i] +&#x3D; &quot;(&quot; + to_string(cnt) + &quot;)&quot;;
            &#125;
            hash[names[i]] &#x3D; 1;
        &#125;
        return names;
    &#125;
&#125;;</code></pre>



<h3 id="1967-作为子字符串出现在单词中的字符串数目"><a href="#1967-作为子字符串出现在单词中的字符串数目" class="headerlink" title="1967.作为子字符串出现在单词中的字符串数目"></a>1967.作为子字符串出现在单词中的字符串数目</h3><h4 id="题干-23"><a href="#题干-23" class="headerlink" title="题干"></a>题干</h4><p>给你一个字符串数组 <strong>patterns</strong> 和一个字符串 <strong>word</strong> ，统计 <strong>patterns</strong> 中有多少个字符串是 <strong>word</strong> 的<strong>子字符串</strong>。返回字符串<strong>数目</strong>。</p>
<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：patterns &#x3D; [&quot;a&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;d&quot;], word &#x3D; &quot;abc&quot;
输出：3</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：patterns &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], word &#x3D; &quot;aaaaabbbbb&quot;
输出：2</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：patterns &#x3D; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;], word &#x3D; &quot;ab&quot;
输出：3</code></pre>

<h4 id="解法-23"><a href="#解法-23" class="headerlink" title="解法"></a>解法</h4><p>一开始看到字符串匹配，第一反应就是经典的<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52622200/article/details/110563434">KMP算法</a>。(印象深刻，考研那会儿在k = next[k];上卡了好久hhh)</p>
<p>然而在实际场景中，需要匹配的字符串都是较短且无序随机的，初始化的时间开销、额外的空间开销反而会更消耗资源，在字符串搜索中并不实用。因此提交代码后发现执行用时和内存消耗都不低。</p>
<p>查询了一下，在例如Java的String.indexOf中，使用的是暴力方法进行字符串匹配。在glibc中的strstr函数，则采用的是Two-Way算法。</p>
<p>这些库函数均未使用KMP算法，原因在于：</p>
<ol>
<li>KMP需要对字符串预处理，这个需要花时间，如果做多次查找的话，这部分预处理的时间可以分摊到多次查找里面，平摊后时间较短，但是如果只做一次查找，这部分时间是不能忽略的。</li>
<li>KMP的核心思想是跳跃遍历(而不是逐个字节遍历)但是跳跃遍历破坏了CPU对内存的预取且不能进行SIMD优化。</li>
</ol>
<h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; getNextArr(string p)&#123;
        vector&lt;int&gt; next(p.length());
        next[0] &#x3D; -1;
        int k &#x3D; -1, j &#x3D; 0;
        while(j &lt; p.length() - 1)&#123;
            if(k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k])
                next[++j] &#x3D; ++k;
            else
                k &#x3D; next[k];
        &#125;
        return next;
    &#125;

    int kmp(string pattern, string word)&#123;
        int i &#x3D; 0, j &#x3D; 0;
        int pLen &#x3D; pattern.length(), wLen &#x3D; word.length();
        vector&lt;int&gt; next &#x3D; getNextArr(pattern);
        while(i &lt; wLen &amp;&amp; j &lt; pLen)&#123;
            if(j &#x3D;&#x3D; -1 || word[i] &#x3D;&#x3D; pattern[j])&#123;
                ++i;
                ++j;
            &#125;
            else&#123;
                j &#x3D; next[j];
            &#125;
        &#125;
        return j &#x3D;&#x3D; pattern.length() ? 1 : 0;
    &#125;

    int numOfStrings(vector&lt;string&gt;&amp; patterns, string word) &#123;
        int cnt &#x3D; 0;
        for(int i &#x3D; 0; i &lt; patterns.size(); ++i)
            cnt +&#x3D; kmp(patterns[i], word);
        return cnt;
    &#125;
&#125;;</code></pre>



<h2 id="2023-3-5"><a href="#2023-3-5" class="headerlink" title="2023.3.5"></a>2023.3.5</h2><h3 id="1599-经营摩天轮的最大利润"><a href="#1599-经营摩天轮的最大利润" class="headerlink" title="1599.经营摩天轮的最大利润"></a>1599.经营摩天轮的最大利润</h3><h4 id="题干-24"><a href="#题干-24" class="headerlink" title="题干"></a>题干</h4><p>你正在经营一座摩天轮，该摩天轮共有 <strong>4</strong> 个座舱 ，每个座舱 最多可以容纳 <strong>4</strong> 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 <strong>runningCost</strong> 。摩天轮每次轮转都恰好转动 1 / 4 周。</p>
<p>给你一个长度为 <strong>n</strong> 的数组 <strong>customers</strong> ， <strong>customers[i]</strong> 是在第 <strong>i</strong> 次轮转（下标从 <strong>0</strong> 开始）之前到达的<strong>新游客的数量</strong>。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <strong>boardingCost</strong> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p>
<p>你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将<strong>免费进行所有后续轮转</strong> 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。</p>
<p>返回<strong>最大化利润</strong>所需执行的 <strong>最小轮转次数</strong> 。 如果不存在利润为正的方案，则返回 <strong>-1</strong> 。</p>
<p><strong>示例</strong></p>
<pre class="language-none"><code class="language-none">示例 1:
输入：customers &#x3D; [8,3], boardingCost &#x3D; 5, runningCost &#x3D; 6
输出：3
解释：座舱上标注的数字是该座舱的当前游客数。
1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 &#x3D; $14 。
2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 &#x3D; $28 。
3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 &#x3D; $37 。
轮转 3 次得到最大利润，最大利润为 $37 。</code></pre>

<pre class="language-none"><code class="language-none">示例 2:
输入：customers &#x3D; [10,9,6], boardingCost &#x3D; 6, runningCost &#x3D; 4
输出：7
解释：
1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 &#x3D; $20 。
2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 &#x3D; $40 。
3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 &#x3D; $60 。
4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 &#x3D; $80 。
5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 &#x3D; $100 。
6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 &#x3D; $120 。
7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 &#x3D; $122 。
轮转 7 次得到最大利润，最大利润为$122 。</code></pre>

<pre class="language-none"><code class="language-none">示例 3:
输入：customers &#x3D; [3,4,0,5,1], boardingCost &#x3D; 1, runningCost &#x3D; 92
输出：-1
解释：
1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 &#x3D; -$89 。
2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 &#x3D; -$177 。
3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 &#x3D; -$269 。
4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 &#x3D; -$356 。
5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 &#x3D; -$447 。
利润永不为正，所以返回 -1 。</code></pre>

<h4 id="解法-24"><a href="#解法-24" class="headerlink" title="解法"></a>解法</h4><p>基本思路：</p>
<p>最开始直接排除掉哪怕坐满（4个游客）都不盈利的情况。</p>
<p>之后一遍for循环肯定是要的，得到在没有新游客来时，轮转的最大收益及所在轮次。</p>
<p>这时计算出每次轮转盈利时需要的最小游客数。</p>
<p>对剩下排队的人数进行判断，如果剩下的人数超过了最小值，则按照4个一轮的最大收益方案计算，一定为最大收益。轮次数加上剩余人数 / 4的商，若余数依旧大于最小值，再加一。</p>
<p>需要注意的是，存在之前for循环中前面的轮次的盈利额与后面轮次的盈利额相同时不更新轮次数的情况，因此有多余人数的情况下，需要先更新轮次数至n。</p>
<p>（总感觉逻辑有哪里不完善。。）</p>
<h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) &#123;
        if(4 * boardingCost - runningCost &lt;&#x3D; 0)  return -1;
        int curP &#x3D; 0, leftP &#x3D; 0, curVal &#x3D; 0, maxVal &#x3D; 0;
        int turns &#x3D; -1;
        for(int i &#x3D; 0; i &lt; customers.size(); ++i)&#123;
            leftP +&#x3D; customers[i];
            curP &#x3D; min(4, leftP);
            curVal +&#x3D; curP * boardingCost - runningCost;
            leftP -&#x3D; curP;
            if(curVal &gt; maxVal)&#123;
                turns &#x3D; i + 1;
                maxVal &#x3D; curVal;
            &#125;
        &#125;
        int minP &#x3D; runningCost &#x2F; boardingCost + 1;
        if (leftP &gt;&#x3D; minP)&#123;
            if(turns &lt; customers.size())
                turns &#x3D; customers.size();
            turns +&#x3D; leftP &#x2F; 4 + (leftP % 4 &gt;&#x3D; minP ? 1 : 0);
        &#125;
        return turns;
    &#125;
&#125;;</code></pre>



</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/CPP/">CPP</a></div><div class="post_share"><div class="social-share" data-image="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Ejs%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"><img class="next-cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于js跨源请求的解决方案</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Szh</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shen962806862"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临 我的快乐</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98"><span class="toc-text">记录每日一题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-11-4"><span class="toc-text">2022.11.4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#754-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97"><span class="toc-text">754.到达终点数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-text">优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-11-7"><span class="toc-text">2022.11.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#816-%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87"><span class="toc-text">816.模糊坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-1"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-1"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-11-8"><span class="toc-text">2022.11.8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1684-%E7%BB%9F%E4%B8%80%E4%B8%80%E8%87%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">1684.统一一致字符串的数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-2"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-2"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-11-9"><span class="toc-text">2022.11.9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#764-%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97"><span class="toc-text">764.最大加号标志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-3"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-3"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-11-11"><span class="toc-text">2022.11.11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1704-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E5%8D%8A%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC"><span class="toc-text">1704.判断字符串的两半是否相似</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-4"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-4"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-12-6"><span class="toc-text">2022.12.6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1805-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">1805.字符串中不同整数的数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-5"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-5"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-12-7"><span class="toc-text">2022.12.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1775-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89"><span class="toc-text">1775.通过最少操作次数使数组的和相等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-6"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-6"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-12-9"><span class="toc-text">2022.12.9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1780-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C"><span class="toc-text">1780.判断一个数字是否可以表示成三的幂的和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-7"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-7"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-8"><span class="toc-text">2023.2.8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%88%E6%9C%AA%E5%AE%8C%E7%BB%93%EF%BC%89"><span class="toc-text">1233.删除子文件夹（未完结）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-8"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-8"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-9"><span class="toc-text">2023.2.9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1797-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F"><span class="toc-text">1797.设计一个验证系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-9"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-9"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-11"><span class="toc-text">2023.2.11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2335-%E8%A3%85%E6%BB%A1%E6%9D%AF%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E7%9F%AD%E6%80%BB%E6%97%B6%E9%95%BF"><span class="toc-text">2335.装满杯子所需的最短总时长</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-10"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-10"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-13"><span class="toc-text">2023.2.13</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1234-%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1234.替换子串得到平衡字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-11"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-11"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-18"><span class="toc-text">2023.2.18</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1237-%E6%89%BE%E5%87%BA%E7%BB%99%E5%AE%9A%E6%96%B9%E7%A8%8B%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3"><span class="toc-text">1237.找出给定方程的正整数解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-12"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-12"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-20"><span class="toc-text">2023.2.20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2347-%E6%9C%80%E5%A5%BD%E7%9A%84%E6%89%91%E5%85%8B%E6%89%8B%E7%89%8C"><span class="toc-text">2347.最好的扑克手牌</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-13"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-13"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-24"><span class="toc-text">2023.2.24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2357-%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E7%AD%89%E4%BA%8E0"><span class="toc-text">2357.使数组中所有元素都等于0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-14"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-14"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-25"><span class="toc-text">2023.2.25</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1247-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%BE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C"><span class="toc-text">1247.交换字符使得字符串相同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-15"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-15"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-27"><span class="toc-text">2023.2.27</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1144-%E9%80%92%E5%87%8F%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E6%88%90%E9%94%AF%E9%BD%BF%E7%8A%B6"><span class="toc-text">1144.递减元素使数组成锯齿状</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-16"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-16"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9816-07-%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC"><span class="toc-text">面试题16.07.最大数值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-17"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-17"><span class="toc-text">解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-2-28"><span class="toc-text">2023.2.28</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2363-%E5%90%88%E5%B9%B6%E7%9B%B8%E4%BC%BC%E7%9A%84%E7%89%A9%E5%93%81"><span class="toc-text">2363.合并相似的物品</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-18"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-18"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">191.位1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-19"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-19"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-3-1"><span class="toc-text">2023.3.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2373-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">2373.矩阵中的局部最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-20"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-20"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-3-2"><span class="toc-text">2023.3.2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9805-02-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">面试题05.02.二进制数转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-21"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-21"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-3-3"><span class="toc-text">2023.3.3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1487-%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80"><span class="toc-text">1487.保证文件名唯一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-22"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-22"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1967-%E4%BD%9C%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%8D%95%E8%AF%8D%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE"><span class="toc-text">1967.作为子字符串出现在单词中的字符串数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-23"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-23"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2023-3-5"><span class="toc-text">2023.3.5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1599-%E7%BB%8F%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-text">1599.经营摩天轮的最大利润</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-24"><span class="toc-text">题干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-24"><span class="toc-text">解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" title="LeetCode每日一题"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode每日一题"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" title="LeetCode每日一题">LeetCode每日一题</a><time datetime="2022-11-04T06:33:06.000Z" title="发表于 2022-11-04 14:33:06">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Ejs%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="关于js跨源请求的解决方案"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于js跨源请求的解决方案"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/%E5%85%B3%E4%BA%8Ejs%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="关于js跨源请求的解决方案">关于js跨源请求的解决方案</a><time datetime="2022-04-17T15:32:36.000Z" title="发表于 2022-04-17 23:32:36">2022-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/%E5%9F%BA%E4%BA%8ESTM32F103%E7%9A%84%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="基于STM32F103的实时操作系统"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于STM32F103的实时操作系统"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/%E5%9F%BA%E4%BA%8ESTM32F103%E7%9A%84%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="基于STM32F103的实时操作系统">基于STM32F103的实时操作系统</a><time datetime="2022-04-08T05:41:30.000Z" title="发表于 2022-04-08 13:41:30">2022-04-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Szh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>