<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>常用数据结构和算法的CPP实现 | 小涵的米奇妙妙屋</title><meta name="keywords" content="算法,CPP"><meta name="author" content="Szh"><meta name="copyright" content="Szh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构堆堆的定义满二叉树如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。具有如下性质  满二叉树中第 i 层的节点数为 2 ^ (i - 1) 个。 深度为 k 的满二叉树必有 2 ^ k - 1 个节点 ，叶子数为 **2 ^ (k - 1)**。 满二叉树中不存在度为 1 的节点，每一个分支点中都有两棵深度相同的子树，且叶子节点都在最底层。 具有 n 个节点的满二叉树">
<meta property="og:type" content="article">
<meta property="og:title" content="常用数据结构和算法的CPP实现">
<meta property="og:url" content="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="小涵的米奇妙妙屋">
<meta property="og:description" content="数据结构堆堆的定义满二叉树如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。具有如下性质  满二叉树中第 i 层的节点数为 2 ^ (i - 1) 个。 深度为 k 的满二叉树必有 2 ^ k - 1 个节点 ，叶子数为 **2 ^ (k - 1)**。 满二叉树中不存在度为 1 的节点，每一个分支点中都有两棵深度相同的子树，且叶子节点都在最底层。 具有 n 个节点的满二叉树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg">
<meta property="article:published_time" content="2023-06-06T01:55:34.000Z">
<meta property="article:modified_time" content="2023-06-09T10:14:48.616Z">
<meta property="article:author" content="Szh">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg"><link rel="shortcut icon" href="/img/Sign.ico"><link rel="canonical" href="https://www.hanhan0223.cn/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a8ed5b37dd0aaae924c52eb382109c5d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常用数据结构和算法的CPP实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-09 18:14:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 脚本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/scripts/genshin/"><i class="fa-fw fas fa-gamepad"></i><span> 我焯!原!</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小涵的米奇妙妙屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 脚本</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/scripts/genshin/"><i class="fa-fw fas fa-gamepad"></i><span> 我焯!原!</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常用数据结构和算法的CPP实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T01:55:34.000Z" title="发表于 2023-06-06 09:55:34">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T10:14:48.616Z" title="更新于 2023-06-09 18:14:48">2023-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8E%9F%E7%90%86/">原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.9k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常用数据结构和算法的CPP实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>如果二叉树中除了叶子结点，每个结点的度都为 <strong>2</strong>，则此二叉树称为<strong>满二叉树</strong>。具有如下性质</p>
<ol>
<li>满二叉树中第 <strong>i</strong> 层的节点数为 <strong>2 ^ (i - 1)</strong> 个。</li>
<li>深度为 <strong>k</strong> 的满二叉树必有 <strong>2 ^ k - 1</strong> 个节点 ，叶子数为 **2 ^ (k - 1)**。</li>
<li>满二叉树中不存在度为 1 的节点，每一个分支点中都有两棵深度相同的子树，且叶子节点都在最底层。</li>
<li>具有 <strong>n</strong> 个节点的满二叉树的深度为 **log2(n+1)**。</li>
</ol>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为<strong>完全二叉树</strong>。</p>
<h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>堆是一个树形结构，底层是一棵<strong>完全二叉树</strong>。而完全二叉树是一层一层按照进入的顺序排成的。按照这个特性，我们可以用<strong>数组</strong>来按照完全二叉树实现堆。</p>
<img src="/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/70.png" alt="img" style="zoom:67%;">

<p>上图就是一个完全二叉树，也是一个最大堆。而最大堆有一个性质：<strong>每一个节点的值都小于它父节点的值</strong>。</p>
<p>需要注意的是，<strong>每一个节点的值的大小与它所处的深度没有必然的联系</strong>。如第三层的六号和七号节点都小于处于最后一层的八号和十号节点。</p>
<h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><h4 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h4><p>如果将这个最大堆存入数组中，黑色的数字就是存储的顺序。可以根据任意一个节点的索引(除去根节点)找到它的父节点的索引，如果当前节点的索引为index，那么：</p>
<ul>
<li>当前节点的父节点 = index / 2(这里我们将结果取整)。</li>
<li>当前节点的左子节点 = index * 2</li>
<li>当前节点的右子节点 = index * 2 + 1。</li>
<li></li>
</ul>
<h4 id="堆的插入删除"><a href="#堆的插入删除" class="headerlink" title="堆的插入删除"></a>堆的插入删除</h4><p><strong>1.建立堆</strong></p>
<p>数组具有对应的树表示形式。一般情况下，树并不满足堆的条件，通过重新排列元素，可以建立一颗“堆化”的树。以下以大根堆为例。</p>
<p><strong>2.插入元素</strong></p>
<p>新元素被插入到列表层（即完全二叉树最后的位置），将其和父节点比较。如果新元素比父节点大，那么交换两者。交换之后，继续和新的父节点比较，直至新元素不比父节点大，随后树被更新以恢复堆次序。（其时间复杂度为<strong>O(logN)<strong>），以上操作称为</strong>上溯</strong>（<strong>percolate up</strong>）操作。</p>
<p><strong>3.删除元素</strong></p>
<p>删除总是发生在<strong>根节点</strong>处。树中最后一个元素被用来填补空缺位置，称为暂时根节点，然后将暂时根节点不断和子节点（<strong>左右两子节点中大的那一个节点</strong>）进行比较，如果他比子节点小，则交换节点位置，直到暂时根节点不小于任何一个子节点，结果树被更新以恢复堆条件。以上操作被称为<strong>下溯</strong>（<strong>percolate down</strong>）。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><strong>简单版本：</strong></p>
<p>一个固定空间大小，支持选择基础数据类型的大根堆。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;
class MaxHeapStable&#123;
private:
    T* data;
    int idx;
    int len;

    void percolate_up(int i)&#123;
        while(i &gt; 1 &amp;&amp; data[i] &gt; data[i&#x2F;2])&#123;
            swap(data[i], data[i&#x2F;2]);
            i &#x2F;&#x3D; 2;
        &#125;
    &#125;
    void percolate_down(int i)&#123;
        while(i * 2 &lt;&#x3D; idx)&#123;
            int child &#x3D; i * 2;
            if(child + 1 &lt;&#x3D; idx &amp;&amp; data[child] &lt; data[child + 1])	child +&#x3D; 1;
            if(data[i] &gt;&#x3D; data[child])	break;
            swap(data[i], data[child]);
            i &#x3D; child;
        &#125;
    &#125; 
public:
    MaxHeapStable(int len)&#123;
        data &#x3D; new T[len + 1];
        idx &#x3D; 0;
        this-&gt;len &#x3D; len;
    &#125;
    ~MaxHeapStable()&#123;
        delete [] data;
    &#125;
    int size()&#123;
        return idx;
    &#125;
    bool isEmpty()&#123;
        return idx &#x3D;&#x3D; 0;
    &#125;
    void push(T val)&#123;
        assert(idx &lt; len);
        data[++idx] &#x3D; val;
        percolate_up(idx);
    &#125;
    T pop()&#123;
        assert(idx &gt; 0);
        T res &#x3D; data[1];
        swap(data[1], data[idx]);
        idx--;
        percolate_down(1);
        return res;
    &#125;
&#125;;</code></pre>

<p><strong>2.0版本</strong></p>
<p>底层改用vector实现，支持动态大小、选择基础数据类型的大根堆。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;
class MaxHeapBase&#123;
private:
    vector&lt;T&gt; data;
    int idx;

    void big_percolate_up(int i)&#123;
        while(i &gt; 1 &amp;&amp; data[i] &gt; data[i&#x2F;2])&#123;
            swap(data[i], data[i&#x2F;2]);
            i &#x2F;&#x3D; 2;
        &#125;
    &#125;
    void big_percolate_down(int i)&#123;
        while(i * 2 &lt;&#x3D; idx)&#123;
            int child &#x3D; i * 2;
            if(child + 1 &lt;&#x3D; idx &amp;&amp; data[child] &lt; data[child + 1])	child +&#x3D; 1;
            if(data[i] &gt;&#x3D; data[child])	break;
            swap(data[i], data[child]);
            i &#x3D; child;
        &#125;
    &#125; 
public:
    MaxHeapBase()&#123;
        data.emplace_back(0);
    &#125;
    MaxHeapBase(int len)&#123;
        data.resize(len + 1);
        data.emplace_back(0);
    &#125;
    MaxHeapBase(initializer_list&lt;T&gt; vals)&#123;
        data.resize(vals.size() + 1);
        idx &#x3D; 0;
        for(auto v : vals)
            push(v);
    &#125;
    ~MaxHeapBase() &#123; vector&lt;T&gt;().swap(data); &#125;

    int size() &#123; return idx; &#125;
    int capacity() &#123; return data.capacity(); &#125;
    int depth() &#123; return ceil(log2(idx + 1)); &#125;
    bool isEmpty() &#123; return idx &#x3D;&#x3D; 0; &#125;
    void clear() &#123; 
        data.clear(); 
        idx &#x3D; 0;
    &#125;

    void push(T val)&#123;
        idx++;
        if(idx &lt; capacity())
            data[idx] &#x3D; val;
        else
            data.emplace_back(val);
        big_percolate_up(idx);
    &#125;
    T pop()&#123;
        assert(idx &gt; 0);
        swap(data[1], data[idx]);
        idx--;
        big_percolate_down(1);
        return data[idx+1];
    &#125;
    T top()&#123;
        return data[1];
    &#125;
&#125;;</code></pre>

<h4 id="STL版本（priority-queue）"><a href="#STL版本（priority-queue）" class="headerlink" title="STL版本（priority_queue）"></a>STL版本（priority_queue）</h4><p>刚好写了道算法题，打算测试2.0时，发现需要对 pair&lt;int, int&gt; 类型进行排序，也就意味着需要真正的泛型编程，支持自定义比较方式，才能支持底层容器vector能支持的全部类型。</p>
<p>注意，使用template实现模板类和函数时，必须将实现也放在头文件中，因为模板类和函数的实例化都是在预处理阶段，而不是编译、链接。若将其声明和定义分开，在预处理阶段在CPP文件填入声明时，找不到定义会报错。</p>
<p><strong>学习STL源码：</strong></p>
<p>1.首先形成一个堆的核心结构在于两个算法：<strong>上溯和下溯</strong>。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 上溯
template&lt;typename _Iterator, typename _Distance, typename _Tp, typename _Compare&gt;
void _push_heap_S(_Iterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __cp) &#123;
    &#x2F;&#x2F; 获取它的父节点
    _Distance __parent &#x3D; (__holeIndex - 1) &#x2F; 2;
    &#x2F;&#x2F; 不断向上更新直至不满足_Compare规则
    while(__holeIndex &gt; __topIndex &amp;&amp; __cp(__first + __parent, __value)) &#123;
        *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(*(__first + __parent));
        __holeIndex &#x3D; __parent;
        __parent &#x3D; (__holeIndex - 1) &#x2F; 2;
    &#125;
    *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(__value);
&#125;</code></pre>

<p>在上溯中， <strong>__holeIndex</strong>就是新加入的需要调整的节点序号（从0开始）， <strong>__value</strong>是该节点的值， <strong>__cp</strong>是一个实现自定义比较方式的 <strong>funtor仿函数</strong>的临时对象。</p>
<p><strong>__topIndex</strong>需要和后文结合起来看才明白意义，这里只是表明在调整过程中新加节点的位置不得超过它。</p>
<p>只要满足上述条件并且满足 <strong>__cp</strong>规则，就将父节点的值赋给新节点处，并更新待调整节点及其父节点位置。直至不满足 <strong>__cp</strong>规则，将 <strong>__value</strong>赋给当前待调整节点。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 下溯
template&lt;typename _Iterator, typename _Distance, typename _Tp, typename _Compare&gt;
void _adjust_heap_S(_Iterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __cp) &#123;
    &#x2F;&#x2F; __topIndex是保持整体结构不出问题的关键
    const _Distance __topIndex &#x3D; __holeIndex;
    _Distance __secondChild &#x3D; __holeIndex;
    &#x2F;&#x2F; 将非叶子节点沉入叶子节点深度
    while (__secondChild &lt; (__len - 1) &#x2F; 2) &#123;
        &#x2F;&#x2F; 取子节点中更符合__Compare的节点
        __secondChild &#x3D; 2 * (__secondChild + 1);
        if (__cp(__first + __secondChild, __first + (__secondChild - 1)))
            __secondChild--;
        &#x2F;&#x2F; 交换两者位置（此时不比较）
        *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(*(__first + __secondChild));
        __holeIndex &#x3D; __secondChild;
    &#125;
    &#x2F;&#x2F; 当size()为偶数，且洞节点被移至这个最小的非叶节点时，需要特殊处理（因为只有左节点）
    if ((__len &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; __secondChild &#x3D;&#x3D; (__len - 2) &#x2F; 2) &#123;
        __secondChild &#x3D; 2 * (__secondChild + 1);
        *(__first + __holeIndex) &#x3D; _GLIBCXX_MOVE(*(__first + (__secondChild - 1)));
        __holeIndex &#x3D; __secondChild - 1;
    &#125;
    &#x2F;&#x2F; 此时洞节点为最右的叶子节点，前面的节点均调整至了符合__cp规则的情况（合理的堆），相当于将这个洞节点的值插入前面的堆中
    _push_heap_S(__first, __holeIndex, __topIndex, _GLIBCXX_MOVE(__value),
            __gnu_cxx::__ops::__iter_comp_val(__cp));
&#125;</code></pre>

<p>该函数表现为以 <strong>__holeIndex</strong> 为根节点的局部下溯操作。当 <strong>__holeIndex = 0</strong> 为根节点时，该函数表现为全局的下溯操作。</p>
<p>while循环负责将 <strong>__holeIndex</strong> 节点逐层下沉直至叶子节点深度。</p>
<p><font color="red">注意：</font>当size()为奇数时，最后一个非叶节点有两个叶子节点，此时正常完成循环，选择符合 <strong>__cp</strong> 规则的子节点交换沉入；但当size()为偶数时， <strong>(__len - 1) / 2</strong>计算得到的序号为最后的非叶节点，但实际上该节点依旧可以下沉一步，因此由下面的if处理特殊情况。</p>
<p>size()为偶数时， <strong>(__len - 1) / 2</strong>和 <strong>(__len - 2) / 2</strong>的计算结果是一致的（后者用于计算最后的非叶节点序号）。</p>
<p>此时，已经完成了一次下溯操作，，除去刚下沉至最后的那个叶子节点， <strong>__holeIndex</strong>及以下的节点已经调整至了符合 <strong>__cp</strong>规则的情况（合理的堆），此时又进行了一次上溯操作，相当于将这个节点插入堆中（<font color="red">TODO：这里不太明白为什么不直接下溯一步到位，要排除这个下沉元素再重新上溯一次</font>）。</p>
<p>2.其次，在初始化堆时，需要执行建堆操作。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename _Iterator, typename _Compare&gt;
void _make_heap_S(_Iterator __first, _Iterator __last, _Compare __cp) &#123;
    typedef typename iterator_traits&lt;_Iterator&gt;::value_type
    _ValueType;
    typedef typename iterator_traits&lt;_Iterator&gt;::difference_type
    _DistanceType;

    if (__last - __first &lt; 2)
	    return;
    &#x2F;&#x2F; size()
    const _DistanceType __len &#x3D; __last - __first;
    &#x2F;&#x2F; 获取最后一个非叶子节点的位置
    _DistanceType __parent &#x3D; (__len - 2) &#x2F; 2;
    &#x2F;&#x2F; 从后向前遍历所有非叶子节点，每个节点都仅与其下面的节点按照_Compare进行调整，不影响树的整体结构
    while (true) &#123;
        &#x2F;&#x2F; 取出每个非叶子节点的值
        &#x2F;&#x2F; _GLIBCXX_MOVE根据_Compare版本选择使用std::move还是直接赋值。
        _ValueType __value &#x3D; _GLIBCXX_MOVE(*(__first + __parent));
        _adjust_heap_S(__first, __parent, __len, _GLIBCXX_MOVE(__value), __cp);
        if (__parent &#x3D;&#x3D; 0)
            return;
        __parent--;
	&#125;
&#125;
&#x2F;&#x2F; make heap
template&lt;typename _Iterator&gt; inline 
void make_heap_S(_Iterator _first, _Iterator _last) &#123;
    _make_heap_S(_first, _last, 
        __gnu_cxx::__ops::__iter_less_iter());
&#125;
template&lt;typename _Iterator, typename _Compare&gt; inline 
void make_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123;
    _make_heap_S(_first, _last, 
        __gnu_cxx::__ops::__iter_comp_iter(_cp));
&#125;</code></pre>

<p><font color="red">注意：</font>这里有个关键点就是把 <strong>__parent</strong>作为 <strong>__topIndex</strong>参数传入，保证非叶节点在调整时不会和节点上方的父节点有交集，影响树的整体结构。</p>
<p>举个例子：大根堆中，根节点序号0是整个堆的最小值，而最后一个非叶节点序号2是整个堆的最大值，此时按照 <strong>_adjust_heap_S()</strong> 函数的逻辑，2将下沉至叶子节点然后上溯。若没有 <strong>__topIndex</strong>限制，2回到原本位置后并不会停止，而是会继续向上与根节点比较，来到根节点的位置。此时根节点最小值被换到了2原本的位置，但2这个位置在 <strong>_make_heap_S()</strong> 中已经遍历结束了，不再碰了。但实际上这个节点是比它的叶子节点更小的，却没有处理的机会了，这就破坏了堆的结构。</p>
<p>3.然后就是堆的<strong>插入、删除</strong>。</p>
<p>插入就是在底层容器vector中加入新元素，然后调用上文中的上溯函数调整即可。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; push heap
template&lt;typename _Iterator&gt; inline 
void push_heap_S(_Iterator _first, _Iterator _last) &#123;
    typedef typename iterator_traits&lt;_Iterator&gt;::value_type
    _ValueType;
    typedef typename iterator_traits&lt;_Iterator&gt;::difference_type
    _DistanceType;
    _ValueType _value &#x3D; _GLIBCXX_MOVE(*(_last - 1));
    _push_heap_S(_first, _DistanceType(_last - _first - 1), _DistanceType(0),
        _value, __gnu_cxx::__ops::__iter_less_val());
&#125;
template&lt;typename _Iterator, typename _Compare&gt; inline 
void push_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123;
    typedef typename iterator_traits&lt;_Iterator&gt;::value_type
    _ValueType;
    typedef typename iterator_traits&lt;_Iterator&gt;::difference_type
    _DistanceType;
    _ValueType _value &#x3D; _GLIBCXX_MOVE(*(_last - 1));
    _push_heap_S(_first, _DistanceType(_last - _first - 1), _DistanceType(0),
        _value, __gnu_cxx::__ops::__iter_comp_val(_cp));
&#125;</code></pre>

<p>删除是对 <strong>_adjust_heap_S()</strong> 函数的应用。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename _Iterator, typename _Compare&gt; inline 
void _pop_heap_S(_Iterator __first, _Iterator __last, _Iterator __res, _Compare __cp) &#123;
    typedef typename iterator_traits&lt;_Iterator&gt;::value_type
    _ValueType;
    typedef typename iterator_traits&lt;_Iterator&gt;::difference_type
    _DistanceType;
    _ValueType __value &#x3D; _GLIBCXX_MOVE(*__res);
    *__res &#x3D; _GLIBCXX_MOVE(*__first);
    _adjust_heap_S(__first, _DistanceType(0), _DistanceType(__last - __first),
        _GLIBCXX_MOVE(__value), __cp);
&#125;
&#x2F;&#x2F;pop heap
template&lt;typename _Iterator&gt; inline 
void pop_heap_S(_Iterator _first, _Iterator _last) &#123;
    if(_last - _first &gt; 1)&#123;
        --_last;
        _pop_heap_S(_first, _last, _last, __gnu_cxx::__ops::__iter_less_iter());
    &#125;
&#125;
template&lt;typename _Iterator, typename _Compare&gt; inline 
void pop_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123;
    if(_last - _first &gt; 1)&#123;
        --_last;
        _pop_heap_S(_first, _last, _last, __gnu_cxx::__ops::__iter_comp_iter(_cp));
    &#125;
&#125;</code></pre>

<p>这里 <strong>__last</strong>自减后再计算 <strong>_DistanceType(last - first)</strong> ，相当于忽略最后一个元素（被换下来的根节点），从第一个元素（被换到根节点的叶节点）开始进行下溯操作。</p>
<p>4.最后是<strong>堆排序</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename _Iterator, typename _Compare&gt;
void _sort_heap_S(_Iterator __first, _Iterator __last, _Compare __cp) &#123;
    typedef typename iterator_traits&lt;_Iterator&gt;::value_type
    _ValueType;
    typedef typename iterator_traits&lt;_Iterator&gt;::difference_type
    _DistanceType;
    while(__last - __first &gt; 1)&#123;
        --__last;
        _pop_heap_S(__first, __last, __last, __cp);
    &#125;
&#125;
template&lt;typename _Iterator&gt; inline 
void sort_heap_S(_Iterator _first, _Iterator _last) &#123;
    _sort_heap_S(_first, _last, 
        __gnu_cxx::__ops::__iter_less_iter());
&#125;
template&lt;typename _Iterator, typename _Compare&gt; inline 
void sort_heap_S(_Iterator _first, _Iterator _last, _Compare _cp) &#123;
    _sort_heap_S(_first, _last, 
        __gnu_cxx::__ops::__iter_comp_iter(_cp));
&#125;</code></pre>

<p>堆排序在建堆完成之后就非常简单了，就是不断将堆顶元素弹出，加入到迭代器末端end()的过程。之后end()前移，继续在 <strong>[ begin(),  end() )</strong> 范围内完成pop操作直至范围内仅剩一个元素。</p>
<p>5.以上堆的方法函数设计好后，就可以通过它们定义一些利用堆特性的类了，例如<strong>优先队列</strong>。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename _Tp, typename _Sequence &#x3D; vector&lt;_Tp&gt;,
	typename _Compare  &#x3D; less&lt;typename _Sequence::value_type&gt; &gt;
class priority_queue_S&#123;
public:
    typedef typename _Sequence::value_type                value_type;
    typedef typename _Sequence::reference                 reference;
    typedef typename _Sequence::const_reference           const_reference;
    typedef typename _Sequence::size_type                 size_type;
    typedef          _Sequence                            container_type;
public:
    _Sequence sq;
    _Compare  cp;
public:
    explicit
    priority_queue_S(const _Sequence&amp; _s, const _Compare&amp; _c)
    : sq(_s), cp(_c) &#123;
        make_heap_S(sq.begin(), sq.end(), cp);
    &#125;
    explicit
    priority_queue_S(const _Sequence&amp; _s &#x3D; _Sequence(), _Compare&amp;&amp; _c &#x3D; _Compare())
    : sq(move(_s)), cp(_c) &#123;
        make_heap_S(sq.begin(), sq.end(), cp);
    &#125;

    bool empty() const &#123; return sq.empty(); &#125;
    size_type size() const &#123; return sq.size(); &#125;
    size_type depth() const &#123; return ceil(log2(this-&gt;size() + 1)); &#125;
    void clear() &#123; sq.clear(); &#125;
   
    const_reference top() const &#123; 
        __glibcxx_requires_nonempty();
        return sq.front(); 
    &#125;

    void push(const value_type&amp; _x)&#123;
        sq.push_back(_x);
        push_heap_S(sq.begin(), sq.end(), cp);
    &#125;
    void push(value_type&amp;&amp; _x)&#123;
        sq.push_back(move(_x));
        push_heap_S(sq.begin(), sq.end(), cp);
    &#125;

    template&lt;typename... _Args&gt;
    void emplace(_Args&amp;&amp;... _args)&#123;
        sq.emplace_back(forward&lt;_Args&gt;(_args)...);
        push_heap_S(sq.begin(), sq.end(), cp);
    &#125;
    
    void pop()&#123;
        __glibcxx_requires_nonempty();
        pop_heap_S(sq.begin(), sq.end(), cp);
        sq.pop_back();
    &#125;
&#125;;</code></pre>



<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="堆排序-O-n-log-n"><a href="#堆排序-O-n-log-n" class="headerlink" title="堆排序 - O(n*log(n))"></a>堆排序 - O(n*log(n))</h3><h4 id="1-函数调用"><a href="#1-函数调用" class="headerlink" title="1.函数调用"></a>1.函数调用</h4><p>实现堆排序其实仅需两个步骤：建堆、排序（将堆顶元素依次下溯）。</p>
<p>承接上文中的STL写法，实现仅需调用两个对应的函数：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; a &#x3D; &#123;33, 1, 44, 2, 999, 77&#125;;
make_heap_S(a.begin(), a.end(), greater&lt;int&gt;());
sort_heap_S(a.begin(), a.end(), greater&lt;int&gt;());</code></pre>

<p>注意，make heap和sort heap操作，要求<strong>堆的比较方式是相同的</strong>才行，也就是说如果不使用默认比较方式（less），就需要在两个函数中均传入同一个比较仿函数。</p>
<p>再注意，<strong>sort_heap_S()</strong> 排序的容器内的元素必须为一个堆，在排序后，这些元素将不再组成一个堆。</p>
<h4 id="2-简单数组实现"><a href="#2-简单数组实现" class="headerlink" title="2.简单数组实现"></a>2.简单数组实现</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">void adjustHeap(vector&lt;int&gt;&amp; arr, int start, int end) &#123;
    int parent &#x3D; start;
    &#x2F;&#x2F; 这里选择左子节点，因为可能存在没有右子节点的情况
    int child &#x3D; 2 * start + 1;
    while(child &lt;&#x3D; end)&#123;
        if(child+1 &lt;&#x3D; end &amp;&amp; arr[child] &lt; arr[child+1])
            ++child;
        if(arr[child] &lt; arr[parent])
            return;
        else&#123;
            swap(arr[child], arr[parent]);
            parent &#x3D; child;
            child &#x3D; 2 * parent + 1;
        &#125;
    &#125;
&#125;
void heapSort(vector&lt;int&gt;&amp; arr)&#123;
    int len &#x3D; arr.size();
    &#x2F;&#x2F; 第一步：建堆
    for(int i &#x3D; (len - 2) &#x2F; 2; i &gt;&#x3D; 0; --i)
        adjustHeap(arr, i, len - 1);
    &#x2F;&#x2F; 第二步：排序
    for(int i &#x3D; len - 1; i &gt; 0; --i)&#123;
        swap(arr[i], arr[0]);
        adjustHeap(arr, 0, i - 1);
    &#125;
&#125;</code></pre>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/CPP/">CPP</a></div><div class="post_share"><div class="social-share" data-image="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/"><img class="next-cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LeetCode--2023Q2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/" title="LeetCode--2023Q2"><img class="cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="title">LeetCode--2023Q2</div></div></a></div><div><a href="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--3%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/" title="LeetCode每日一题--3月及以前"><img class="cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">LeetCode每日一题--3月及以前</div></div></a></div><div><a href="/%E5%8E%9F%E7%90%86/opencv%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/" title="opencv图像算法"><img class="cover" src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-23</div><div class="title">opencv图像算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Szh</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shen962806862"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临 我的快乐</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">堆的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-text">二叉堆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">堆的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">堆的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-text">堆的插入删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E7%89%88%E6%9C%AC%EF%BC%88priority-queue%EF%BC%89"><span class="toc-text">STL版本（priority_queue）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-O-n-log-n"><span class="toc-text">堆排序 - O(n*log(n))</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">1.函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.简单数组实现</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/" title="常用数据结构和算法的CPP实现"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用数据结构和算法的CPP实现"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84CPP%E5%AE%9E%E7%8E%B0/" title="常用数据结构和算法的CPP实现">常用数据结构和算法的CPP实现</a><time datetime="2023-06-06T01:55:34.000Z" title="发表于 2023-06-06 09:55:34">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/" title="LeetCode--2023Q2"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode--2023Q2"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/LeetCode--2023Q2/" title="LeetCode--2023Q2">LeetCode--2023Q2</a><time datetime="2023-04-01T02:32:55.000Z" title="发表于 2023-04-01 10:32:55">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--3%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/" title="LeetCode每日一题--3月及以前"><img src="https://myweb-1259751480.cos.ap-shanghai.myqcloud.com/images/cover/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode每日一题--3月及以前"/></a><div class="content"><a class="title" href="/%E5%8E%9F%E7%90%86/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98--3%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/" title="LeetCode每日一题--3月及以前">LeetCode每日一题--3月及以前</a><time datetime="2022-11-04T06:33:06.000Z" title="发表于 2022-11-04 14:33:06">2022-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Szh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>